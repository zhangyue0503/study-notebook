<html>
<head>
  <title>Docker容器与容器云</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="2861"/>
<h1>Docker容器与容器云</h1>

<div>
<span><div><span style="font-weight: bold; font-size: 24px;">一、从容器到容器云</span></div><div>1.容器技术的好处：</div><ul><li>持续部署与测试</li><li>跨云平台支持</li><li>环境标准化和版本控制</li><li>高资源利用率与隔离</li><li>容器跨平台性与镜像</li><li>易于理解且易用</li><li>应用镜像仓库</li></ul><div>2.容器云：以容器为资源分割和调度的基本单位，封装整个软件运行时环境，为开发者和系统管理员提供用于构建、发布和运行分布式应用的平台</div><div><br/></div><div><span style="font-weight: bold; font-size: 24px;">二、Docker基础</span></div><div>1.docker rmi命令删除镜像；docker rm删除容器；都提供-f选项，可强制删除存在容器的镜像或启动中的容器</div><div><br/></div><div><span style="font-weight: bold; font-size: 24px;">三、Docker核心原理解读</span></div><div><span style="font-weight: bold;">A.Docker背后的内核知识</span></div><div>1.Docker容器本质上是宿主机上的进程，通过namespace实现了资源隔离，通过cgroups实现了资源限制，通过写时复制机制（copy-on-write）实现了高效的文件操作</div><div>2.6种namespace资源隔离：UTS（主机名与域名）、IPC（信号量、消息队列和共享内存）、PID（进程编号）、Network（网络设备、网络栈、端口等）、Mount（挂载点，文件系统）、User（用户和用户组）</div><div>3.cgroups是Linux内核提供的一种机制，这种机制可以根据需求把一系列系统任务及其子任务融合（或分隔）到按资源划分等级的不同组内，从而为系统资源管理提供一个统一的框架，本质上是内核附加在程序上的一系列钩子（hook），通过程序运行时对资源的调度触发相应的钩子以达到资源追踪和限制的目的</div><div><br/></div><div><span style="font-weight: bold;">B.Docker架构概览</span></div><div>1.docker/docker.go是所有命令的起始</div><div>2.api目录下是所有与“client如何发送请求”“server如何响应请求”相关的文件</div><div>3.api/client/xxx.go中定义Cmdxxx函数，其中调用的cli.client.xxx函数指明了该命令发起何种HTTP请求</div><div>4.每个请求的处理函数都会对应一个daemon/xxx.go文件，daemon会使用其中相应的函数来对请求进行处理</div><div>5.daemon所使用到的Container对象即container/container_unix.go</div><div><br/></div><div><span style="font-weight: bold;">C.libcontainer</span></div><div>1.libcontainer本身主要分为三大块工作内容，一是的创建及初始化，二是容器生命周期管理，三是进程管理，调用方为Docker的execdriver</div><div><br/></div><div><span style="font-weight: bold;">D.Docker镜像管理</span></div><div>1.Docker镜像是一个只读的Docker容器模板，含有启动Docker容器所需的文件系统结构及其内容，因此是启动一个Docker容器的基础，镜像文件内容以及一些运行Docker容器的配置文件组成了Docker容器的静态文件系统运行环境——rootfs</div><div>2.rootfs是Docker容器在启动时内部进程可见的文件系统，即Docker容器的根目录</div><div>3.Docker镜像的主要特点：分层、写时复制、内容寻址、联合挂载</div><div>4.镜像关键概念：registry、manifest、image和layer、Dockerfile</div><div><br/></div><div><span style="font-weight: bold;">E.Docker存储管理</span></div><div>1.常用存储驱动：aufs、btrfs、zfs、devicemapper、overlay和vfs</div><div><br/></div><div><span style="font-weight: bold;">F.Docker数据卷</span></div><div>1.volume是存在于一个或多个容器中的特定文件或文件夹，这个目录以独立于联合文件系统的形式在宿主机中存在，提供以下便利：</div><ul><li>在容器创建时就会初始化，在容器运行时就可以使用其中的文件</li><li>能在不同的容器之间共享和重用</li><li>对volume中数据的操作会马上生效</li><li>对volume中数据的操作不会影响到镜像本身</li><li>volume的生存周期独立于容器的生存周期</li></ul><div><br/></div><div><span style="font-weight: bold;">G.Docker网络管理</span></div><div>1.Docker在1.9版本引入了一整套的docker network子命令和跨主机的网络支持，在libnetwork中使用了CNM（Container Network Model），CNM定义了构建容器虚拟化网络的模型，同时还提供了可以用于开发多种网络驱动的标准化接口和组件</div><div>2.CNM的3个核心组件：沙盒、端点、网络</div><div>3.libnetwork中的5种内置驱动：bridge驱动、host驱动、overlay驱动、remote驱动、null驱动</div><div>4.docker network connect命令会在所连接的容器中创建新的网卡，以完成其与所指定网络的连接</div><div><br/></div><div><span style="font-weight: bold;">H.Docker与容器安全</span></div><div>1.Docker安全问题</div><ul><li>磁盘资源限制问题</li><li>容器逃逸问题</li><li>容器DoS攻击与流量限制问题</li><li>超级权限问题</li></ul><div>2.Docker安全的解决方案：SELinux、磁盘限额、宿主机内容器流量限制、GRSecurity内核安全增强工具</div><div><br/></div><div><span style="font-weight: bold; font-size: 24px;">四、Docker高级实践技巧</span></div><div><span style="font-weight: bold;">A.容器化思维</span></div><div>1.容器的本质是一个进程以及运行该进程所需要的各种依赖</div><div>2.我们不需要去备份一个容器，而是应该把需要备份的数据放在容器外挂的volume里或者数据库里</div><div><br/></div><div><span style="font-weight: bold;">B.Dockerfile最佳实践</span></div><div>1.Dockerfile实践心得：使用标签、谨慎选择基础镜像、充分利用缓存、正确使用ADD与COPY指令、RUN指令、CMD和ENTRYPOINT指令、不要在Dockerfile中做端口映射、使用Dockerfile共享Docker镜像</div><div><br/></div><div><span style="font-weight: bold;">C.Docker容器的监控手段</span></div><div>1.监控命令：docker ps、docker images、docker stats、docker inspect、docker top、docker port</div><div>2.常用监控工具：Google的cAdvisor、Datadog、SoundCloud的Prometheus</div><div><br/></div><div><span style="font-weight: bold;">D.容器化应用构建的基础：高可用配置中心</span></div><div>1.etcd是一个键值存储仓库，用于配置共享和服务发现，特点：简单、安全、快速、可信</div><div>2.服务发现就是在同一个分布式集群中的进程和服务，互相感知并建立连接</div><div><br/></div><div><span style="font-weight: bold; font-size: 24px;">五、构建自己的容器云</span></div><div><br/></div><div><b><font style="font-size: 24px;">六、专注编排与部署：三剑客与Fleet</font></b></div><div><b>A.编排小神器Fig/Compose</b></div><div>1.编排，即orchestration，它根据被部署对象之间的耦合关系，以及被部署对象对环境依赖，制定部署流程中各个动作的执行顺序，部署过程所需要的依赖文件和被部署文件的存储位置和获取 方式，以及如何验证部署成功</div><div>2.部署，即deployment，是指按照编排所指定的内容和流程，在目标机器 上执行编排指定环境初始化，存放指定的依赖和文件，运行指定的部署动作，最终按照编排中的规则来确认部署成功</div><div>3.Dockerfile重现一个容器，Compose重现容器的配置和集群</div><div>4.docker-compose的局限性：面向单宿主机部署，网络和存储也很棘手</div><div><br/></div><div><span style="font-weight: bold;">B.跨平台宿主环境管理工具Machine</span></div><div>1.Machine把用户搭建Docker环境的各种方案汇集在一起，既一目了然又简化了Docker环境的搭建过程，让用户能继续将时间投入到应用开发上，而不是无谓地花费在环境搭建上</div><div><br/></div><div><span style="font-weight: bold;">C.集群抽象具Swarm</span></div><div>1.Swarm最大程序兼容Docker的远程API，使得所有直接调用Docker远程API的程序能方便地将后端替换为Swarm，包括Docker官方客户端，以及Fig、Flynn和Deis这类集群化管理使用Docker的工具</div><div><br/></div><div><span style="font-weight: bold;">D.编排之秀Fleet</span></div><div>1.每台安装了CoreOS的机器本身就是这个容器云的一个节点，操作系统提供对容器编排、部署、管理、运维的功能，</div><div>2.Fleet说白了就是一个面向服务器集群来控制systemd的管理工具而已</div><div><br/></div><div><b><font style="font-size: 24px;">七、专注应用支撑和运行时：Flynn和Deis</font></b></div><div><b>A.Flynn，一个小而美的两层架构</b></div><div>1.Flynn，一个具有Layer0和Layer1两层架构的类PaaS项目，严格意义上是一套面向“服务发布”的框架</div><div><ul><li>Layer0：分布式配置和协调、任务调度、服务发现、宿主机抽象 <br/></li><li>Layer1：API控制器、Git接收器、Buildpacks、路由组件<br/></li></ul></div><div><br/></div><div><b>B.谈Deis与Flynn</b></div><div>1.Deis是纯粹的面向应用发布的架构，严格区分“服务”和“应用”的关系，是一个更加贴近应用和经典PaaS平台的真正意义上的Docker PaaS云</div><div><br/></div><div><b><font style="font-size: 24px;">八、一切皆容器：Kubernetes</font></b></div><div>1.脱胎于Google内部的大规模集群管理工具Borg，还是一个管理跨主机容器化应用的系统，实现了包括应用部署、高可用管理和弹性伸缩在内的一系列基础功能并封装成为一套完事、简单易用的RESTful API对象提供服务</div><div><br/></div></span>
</div></body></html> 