<html>
<head>
  <title>深入理解JavaScript</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="2080"/>
<h1>深入理解JavaScript</h1>

<div>
<span><div><b><font style="font-size: 24px;">一、基础JavaScript</font></b></div><div><b>A.背景</b></div><div>1.早期没有异常</div><div>2.支持函数式编程（高阶函数、内置的map和reduce）和面向对象编程（对象、继承）的混合编程风格</div><div><br/></div><div><b>B.语法</b></div><div>1.原始值包括布尔值、数字、字符串、null和undefined，其他的值都对象。</div><div>2.typeof主要用于原始值，instanceof用于对象</div><div><br/></div><div><b><font style="font-size: 24px;">二、为什么选择JavaScript</font></b></div><div><br/></div><div><b><font style="font-size: 24px;">三、JavaScript的性质</font></b></div><div><b>A.JavaScript的本质</b></div><div>1.它是动态的</div><div>2.它是动态类型</div><div>3.它是函数式和面向对象的</div><div>4.它静默失败</div><div>5.它部署的是开源代码</div><div>6.它是网络平台的一部分</div><div><br/></div><div><b><font style="font-size: 24px;">四、JavaScript是如何创造出来的</font></b></div><div><b><br/></b></div><div><b><font style="font-size: 24px;">五、标准化ECMAScript</font></b></div><div><b><br/></b></div><div><b><font style="font-size: 24px;">六、JavaScript的历史里程碑</font></b></div><div><br/></div><div><b><font style="font-size: 24px;">七、JavaScript的语法</font></b></div><div><b>A.表达式与语句</b></div><div>1.表达式：表达式将会产生一个值，它可以写在任何需要值的地方。</div><div>2.语句：语句表示了一种行为，如循环和if语句，一个程序基本上就是语句的序列。凡是在JS期望语句的地方都可以写表达式，这样的语句叫做表达式语句。反之则不然，不能在需要表达式的地主使用语句。</div><div>3.eval需要返回对象时需要小括号，立即调用函数表达式最外层也需要小括号。</div><div><br/></div><div><b>B.严格模式</b></div><div>1.严格格式需要注意：启用严格模式可能会破坏再有的代码；细心打包；变量必须显式声明；函数必须在作用域的顶部声明；设置或删除不可改变的属性会抛出异常；不合格标识符不能删除；with语句不能再被调用；没有八进制的数字 ；</div><div><br/></div><div><b><font style="font-size: 24px;">八、值</font></b></div><div><b>A.JavaScript中的类型体系</b></div><div>1.JS是动态类型的语言：变量的类型在编译的时候是不确定的；</div><div>2.JS内置的转换机制只支持布尔值、数字、字符串和对象。</div><div><br/></div><div><b>B.原始值和对象</b></div><div>1.每一个对象有唯一的标识符并且只（严格）和自身相等；所有的原始值，只要编码值相同，则被认为相等；</div><div>2.原始值：按值进行比较；不可改变；固定类型的组合；</div><div>3.对象：常见对象（简单对象，对象字面量来创建；数组，可以通过数组字面量创建；正则表达式；），特点（按引用进行比较；默认可变；用户可扩展；）</div><div><br/></div><div><b>C.undefined和null</b></div><div>1.undefined：表示“没有值”（既不是原始值也不是对象）。</div><div><ul><li>出现场景：未初始化的变量、缺失的参数、访问一个不存在的属性、函数中没有显式地返回任何值会隐式返回undefined。<br/></li><li>检测：if(x===undefined)<br/></li></ul></div><div>2.null：意思是“没有对象”。在用到对象时它表示空值。</div><div><ul><li>出现场景：null是原型链最顶端的元素、当字符串中没有匹配到正则表态式的结果时<br/></li><li>检测：if(x===null)<br/></li></ul></div><div><br/></div><div><b>D.原始值的包装对象</b></div><div>1.布尔值、数字和字符串这三种原始值都有相应的构造函数：Boolean、Number、String。它们的实例（称为包装对象）包含原始值。两种用法：作为构造函数，它们创建的对象和它们包装的原始值有很大的不同；作为函数，它们会将值转换为相应的原始值。</div><div>2.一种使用包装对象的场景：在你需要对一个原始值增加属性时，首先要对这个原始值进行包装并且给包装后的对象增加属性，而当你要使用值之前需要先对它进行去包装。通过调用包装构造函数来对原始值进行包装，通过调用valueOf(0来对原始值进行去包装（布尔值不能正确提取）。</div><div>3.原始值没有私有方法，但是它会从各自的包装器中借调方法。宽松模式中，原始值会在运行过程中转换为包装器；严格模式中，对包装器原型方法的调用是透明的；</div><div><br/></div><div><b>E.强制类型转换</b></div><div>1.强制类型转换会隐藏bug</div><div><br/></div><div>/speakingjavascript/8.js</div><div><br/></div><div><b><font style="font-size: 24px;">九、运算符</font></b></div><div><b>A.运算符和对象</b></div><div>1.所有的运算符都会强制要求它们的运算为合适的类型。会被转换为原始值。数组会转换成字符串然后再把它们拼接起来。</div><div><br/></div><div><b>B.赋值运算符</b></div><div>1.赋值运算是一种表达式，它用来计算要被赋予的值。因此可以进行链式赋值。</div><div>2.复合赋值运算符：+=、*=、/=、%=、-=，&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=、&amp;=、^=、|=</div><div><br/></div><div><b>C.等号运算符：===和==</b></div><div>1.两种方式判断两个值是否相等</div><div><ul><li>严格相等（===）和严格不等（!==）要求比较的值必须是相同的类型<br/></li><li>普通（或者“宽松”）相等（==）和不等（!=）会先尝试将两个不同类型的值进行转换，再使用严格相等进行比较。<br/></li></ul></div><div>2.严格相等</div><div><ul><li>比较两个对象：当且仅当x和y是同一个对象时，x===y；<br/></li><li>NaN和本身不相等<br/></li></ul></div><div>3.普通（宽松）相等（==，!=）</div><div><ul><li>相等和转换为布尔值的工作原理是不同的。<br/></li></ul></div><div><br/></div><div><b>D.通过typeof和instanceof判断值类型</b></div><div><ul><li>typeof运算符能区分原始值和对象，并检测出原始值的类型<br/></li><li>instanceof运算符可以检测一个对象是否是特定构造函数的一个实例。<br/></li></ul></div><div><br/></div><div><b><font style="font-size: 24px;">十、布尔类型</font></b></div><div><b>A.转换成布尔值</b></div><div>1.undefined:false、null:false、布尔值:与输入相同、数字:0,NaN为false、字符串:’’为false、对象:总为true</div><div>2.手动转换：Boolean(value)、value?true:false、!!value</div><div><br/></div><div><b><font style="font-size: 24px;">十一、数字</font></b></div><div><b>A.转换为数字</b></div><div>1.Number(value) --推荐</div><div>2.parseFloat(str) —对非字符串净系低</div><div><br/></div><div><b>B.特殊的数字值</b></div><div>1.两个错误值NaN和Infinity</div><div>2.两个零值，+0和-0</div><div>3.NaN和它本身不相等，使用isNaN()判断</div><div>4.Infinity：表示大到无法表示的数字，或者除以了0，使用isFinite()可检查一个值是否是实际的值（既不是Infinity也不是NaN）</div><div><br/></div><div><b>C.安全的范围</b></div><div>1.Math.pow(2,1023)正常Math.pow(2,1024)返回Infinity</div><div>2.安全的整型：Number.MAX_SAFE_INTEGER = Math.pwo(2,53)-1</div><div><br/></div><div><b>D.转换为整数</b></div><div>1.Math函数：Math.floor()、Math.ceil()、Math.round()</div><div>2.定制的ToInteger()函数：return x&lt;0?Math.ceil(x):Math.floor(x);</div><div>3.二进制位运算操作符</div><div>4.全局函数parseInt()</div><div><br/></div><div><b>E.Number原型方法</b></div><div>1.Number.prototype.toFixed(N)：返回不使用指数表示的数字，舍入到小数点后第N位，默认为0，如果数字大于或等于10的21次方，这个方法的作用和toString()相同</div><div>2.Number.prototype.toPrecision(N)：在使用类似toString()等转换算法前会将尾数精确到N位，如果没有给出N，直接使用toString()</div><div>3.Number.prototype.toString(N)：参数N指定了显示数字的系统使用的基数。指数标注：如果一个数字的小数点前有多于21个的数字；如果一个数字以0开头，并且紧跟了超过多于五个0和一个非0的数字；</div><div>4.Number.prototype.toExponential(N)：强制使用指数标注来表示一个数字。</div><div><br/></div><div><b><font style="font-size: 24px;">十二、字符串</font></b></div><div><b>A.手动转换为字符串</b></div><div>1.String(value)</div><div>2.’’+value</div><div>3.value.toString()</div><div><br/></div><div><b><font style="font-size: 24px;">十三、语句</font></b></div><div><b>A.循环语句和条件主体</b></div><div>1.不要用for-in来遍历数组：for-in只会遍历索引而不是数组元素；for-in还会遍历所有的（非索引）属性值；</div><div><br/></div><div><b>B.with语句</b></div><div>1.已被废弃</div><div>2.性能问题、代码可能会产生不可预期的结果、代码压缩工具无法压缩</div><div><br/></div><div><b><font style="font-size: 24px;">十四、异常捕获</font></b></div><div><b>A.什么是异常捕获</b></div><div>两个原则：如果一处出错的含义不能被描述，那么就抛错；找到一个可以捕获错误的位置，捕获异常；</div><div><br/></div><div><b>B.JavaScript中的异常捕获</b></div><div>1.thorw new Error(‘……’);</div><div><br/></div><div><b>C.Error构造器</b></div><div>Error是通用异常构造器</div><div>RangeError表示一个数值超出了允许的范围</div><div>ReferenceError表示发现了一个非法的引用值，通常这是一个未知的变量</div><div>SyntaxError表示产生了一个语法解析错误</div><div>TypeError表示一个被操作值的实际类型与其期望的类型不一致</div><div>URIError表示某个全局的URI控制函数的使用不兼容其定义</div><div><br/></div><div><b>D.栈跟踪</b></div><div>使用e.stack</div><div><br/></div><div>/speakingjavascript/14.js<br/></div><div><br/></div><div><b><font style="font-size: 24px;">十五、函数</font></b></div><div><b>A.JavaScript中函数的3种形式</b></div><div>非方法的函数（“普通函数”）：id(‘hello')</div><div>构造器：new Date()</div><div>方法：obj.method()</div><div><br/></div><div><b>B.定义函数</b></div><div>1.函数表达式：var a = function(){}，具名函数表达式（使得函数表达式可以引用它自己，对于递归有用）：var a = function m(){}</div><div>2.函数声明：function a(){}，等于函数表达式var a = function(){}</div><div>3.Function构造器：var a = new Function()，相对比较慢，并且把代码放在了字符串中。</div><div><br/></div><div><b>C.函数提升</b></div><div>1.函数提升：将函数的声明放到作用域的开始。函数声明是做了完全提升的，而变量声明则是部分提升。</div><div><br/></div><div><b>D.函数声明还是函数表达式</b></div><div>1.函数声明会做代码提升，因此你可以在源码中先于函数的定义来调用函数</div><div>2.函数声明具有名字</div><div><br/></div><div><b>E.控制函数调用：call()、apply()和bind()</b></div><div>1.func.apply(thisValue,argArray)，thisValue可以指定执行func时的this值</div><div>2.func.bind(thisValue,arg1,……argN)，这个方法会执行部分的函数功能，它会创建一个新的函数，这个函数会调用func，并会将thisValue指定为this，同时应用参数arg1至argN，紧随其后的是新函数的实际参数。</div><div><br/></div><div><b>F.参数缺失或者超出时的处理</b></div><div>1.arguments变量只存在于函数中（包括方法）。它是一个类数组的对象，包含了当前函数调用的所有实参。</div><div>2.arguments是类数组的，但又非数组，有一个length属性，但没有数组的方法</div><div>3.arguments是一个对象，因此它支持所有的对象方法和操作。</div><div>4.模拟参数的引用传递需要把值放在数组中，JS没有引用传递</div><div><br/></div><div><b>G.具名参数</b></div><div>1.优点：它们对函数的参数进行了描述，同时它们对于处理可选参数的场景也很有用。</div><div>2.JS不支持具名参数，但可以通过对象字面量来命名参数，并将对象作为一个实参传入函数。</div><div><br/></div><div>/speakingjavascript/15.js<br/></div><div><br/></div><div><b>十六、变量：作用域、环境和闭包</b></div><div><b>A.变量以函数为作用域</b></div><div>1.只有函数可以产生新的作用域，代码块在作用域中是不起作用的。</div><div>2.赋值给一个未定义的变量，不通过var的话，会产生一个全局的变量。</div><div><br/></div><div><b>B.通过IIFE引入新的作用域</b></div><div>1.立即执行的函数表达式(IIFE)，(function(){/*内容*/}());，它是立即执行的，必须是一个表达式，最后必须要有分号。</div><div>2.IIFE变体：前缀运算符，使用!或void，!function(){}();，void function(){}();，可以忘了分号结尾</div><div>3.IIFE变体：预内置表达式上下文，为IIFE强制执行表达式上下文并不是必需的，如果已经在一个表达式的上下文里面，那么你不必使用括号或者前缀操作符。</div><div>4.IIFE变体：传参的IIFE，var x = 23;(function(twice){console.log(twice);}(x*2));</div><div>5.IIFE的应用</div><div><ul><li>避免全局变量，隐藏全局作用域的变量<br/></li><li>创建新的环境，避免共享<br/></li><li>保持全局的数据对于构造器的数据相对独立<br/></li><li>将全局数据附加到单例对象上<br/></li><li>将全局数据附加到方法中<br/></li></ul></div><div><br/></div><div><b>C.全局变量</b></div><div>1.避免创建全局变量：程序中依赖全局作用域的代码片段会产生一些边缘效应，程序可能不够健壮，会产生一些不可预期的效果，重用性更低；一个WEB页面上面所有JS都共享一个相同的全局作用域以及其全局变量，可能产生名字的冲突问题。</div><div>2.模块系统可以减少全局变量的引入</div><div><br/></div><div><b>D.全局对象</b></div><div>1.在全局作用域中，this指向全局对象</div><div>2.在浏览器this是window对象，在node.js中this是global</div><div><br/></div><div><b>E.环境：变量的管理</b></div><div>1.当程序运行到变量所在的作用域时，变量被创建。这时它需要一个存储的空间，而JS中提供存储空间的数据结构就被称为环境。</div><div>2.动态维度：调用函数，执行上下文的栈，函数每调用一次就会创建一个新的环境将标识符和变量做映射。</div><div>3.词法维度：与外部作用域进行关联，环境链，JS会通过内部属性[[Scope]]来记录函数的作用域，在函数调用时，JS会为这个函数所有的新作用域创建一个环境，这个环境有一个外层域(outer)，它通过[[Scope]]创建并指向了外部作用域的环境。</div><div><br/></div><div><b>F.闭包：使得函数可以维持其创建时所在的作用域</b></div><div>1.如果一个函数离开了它被创建时的作用域，它还是会与这个作用域以及其外部的作用域的变量相关联。</div><div>2.闭包是一个函数外加上该函数创建时所建立的作用域。闭包的名字来源于闭包“关闭”了一个函数中自由变量的访问权。</div><div>3.闭包是一个代码执行完成之后离开作用域环境依旧存在的例子。</div><div><br/></div><div>/speakingjavascript/16.html<br/></div><div><br/></div><div><b><font style="font-size: 24px;">十七、对象与继承</font></b></div><div><b>A.单一对象</b></div><div>1.笼统的说，JS中所有的对象都是从字符串(string)到值(value)的映射。一个对象中的某一项（键、值）称为属性。属性的键始终是文本字符串。属性的值可以是任何JS值，包括函数。方法是值为函数的属性。</div><div>2.属性的种类：属性（property，数据属性）、访问器（Accessor）、内置属性（Internal property）</div><div>3.对象字面量：你可以在没有类的情况下直接创建对象，然后进行抽象处理。</div><div>4.delete删除自有属性时返回false，其他都返回true</div><div>5.通过.和[]都可以访问对象属性，如obj.v和obj[‘v’]</div><div><br/></div><div><b>B.this作为函数和方法的隐式参数</b></div><div>1.当你调用一个函数时，this总是作为一个（隐式）参数</div><div>2.在调用函数时设置this：call()、apply()和bind()</div><div>3.缺陷：提取方法时丢失this，使用bind()</div><div>4.缺陷：方法中的函数会掩盖this：使用that、使用bind()、使用forEach的thisValue</div><div><br/></div><div><b>C.对象间的原型关系</b></div><div>1.两个对象间的原型关系类似继承：每个对象都可以把另一个对象作为它的原型，并继承原型的所有属性。</div><div>2.对象通过内部属性[[Prototype]]指定它的原型。通过[[Prototype]]属性连接成的对象链称为原型链。</div><div>3.原型链的行为就好像它是一个单独的对象。一个对象的属性可以覆写之后对象的相同键的属性，前者被先找到。</div><div>4.原型对于对象间数据共享十分有用：多个对象可以有相同的原型，这个原型持有所有的共享属性。</div><div>5.特殊属性__proto__，可以直接访问[[Prototype]]，否则使用Object.create(原型,对象);</div><div><br/></div><div><b>D.遍历和检测属性</b></div><div>1.遍历和检测属性的相关操作受到两个情况影响：继承（自有属性与继承属性）、枚举（枚举属性与非枚举属性）</div><div><br/></div><div><b>E.属性特性和属性描述符</b></div><div>1.属性特性是属性的原子构建块，具有[[Value]]、[[Writable]]、[[Get]]、[[Set]]、[[Enumerable]]、[[Configurable]]</div><div>2.属性描述符：是一个编码属性特性的对象，每个描述符的属性对应一个特性。</div><div>3.一些操作可能通过属性描述符获取和设置属性的特性</div><div><ul><li>Object.getOwnPropertyDescriptor(obj,propKey)：返回obj对象的propKey键的自有属性描述符，如果没有返回undefined<br/></li><li>Object.defineProperty(obj,propKey,propDesc)：创建或改变obj对象的propKey键的属性，并通过propDesc指定这个属性的特性，会返回修改后的对象<br/></li><li>Object.defineProperties(obj,propDescObj)：Object.defineProperty()的批量处理脚本<br/></li><li>Object.create(proto,propDescObj?)：创建原型为proto的对象，如果指定了propDescObj，用类似Object.defineProperties的同样方式给对象添加属性<br/></li></ul></div><div>4.复制对象：拷贝必须具有与原对象相同的原型；拷贝必须具有与原对象相同的属性和特性；</div><div>5.枚举性：最佳实践</div><div><ul><li>一般情况下，系统创建的属性不可枚举，用户创建的属性可枚举<br/></li><li>影响：for-in循环、Object.keys()（列出自有的属性）、JSON.stringify()<br/></li><li>最佳实践：对于自己的代码，通常可以忽略枚举性，且应该避免使用for-in循环；通常不应该给内置原型和对象添加属性，如果这么做了，应该设置属性不可枚举，避免破坏现有代码；<br/></li></ul></div><div><br/></div><div><b>F.保护对象</b></div><div>1.防止扩展：使用Object.preventExtensions(obj)</div><div>2.封闭：Object.seal(obj)，防止扩展，并设置所有的属性“不可配置”</div><div>3.冻结：Object.freeze(obj)，使所有的属性不可写，且封装obj，obj不能扩展，所有的属性都是只读的，且不能改变</div><div>4.保护对象只是浅层的，它影响自有属性，但不影响这些属性的值</div><div><br/></div><div><b>G.构造函数——实例工厂</b></div><div>1.构造函数（简称构造器）帮助生成对象，构造函数在某些方面和普通函数类似，但命名、设置和调用不同。</div><div>2.构造函数创建的对象称为实例。包括两部分：</div><div><ul><li>数据是由实例指定的，并存储在实例对象的自有属性中<br/></li><li>行为被所有的实例所共享，它们公用一个带有方法的原型对象<br/></li></ul></div><div>3.new操作符执行步骤：</div><div><ul><li>首先设置行为：创建一个新对象，其原型为Person.prototype<br/></li><li>然后设置数据：Person接受对象作为隐式参数this，并添加实例属性<br/></li></ul></div><div>4.new操作符：可以从构造函数返回一个任意的对象，它成为new操作符的返回结果。</div><div>5.实例的constructor属性</div><div><ul><li>默认每个函数C包含一个实例原型对象C.prototype，它的constructor属性指回C，因为每个实例都从原型中继承了constructor属性，所以你可以使用它得到实例的构造函数。<br/></li><li>可以切换对象的构造函数、确定对象的构造函数名、创建相似对象、指向父构造函数<br/></li><li>instanceof运算符不依赖constructor属性<br/></li><li>最佳实践：确保C.prototype.constructor === C<br/></li></ul></div><div>6.instanceof运算符</div><div><ul><li>value instanceof Constr<br/></li><li>判断value是由构造函数Constr还是子构造函数（subconstructor）创建的，它是检测Constr.prototype是否在value的原型链上。<br/></li></ul></div><div>7.实现构造函数的小技巧</div><div><ul><li>防止遗漏new：严格模式（宽松模式下不会得到实例而是创建了全局变量）<br/></li><li>从构造函数返回任意对象<br/></li></ul></div><div><br/></div><div><b>H.原型属性中的数据</b></div><div>1.对于实例属性，避免使用带初始值的原型属性</div><div><ul><li>不应共享默认值<br/></li><li>根据需要创建实例属性<br/></li></ul></div><div>2.避免非多态的原型属性</div><div>3.多态的原型属性</div><div><br/></div><div><b>I.保持数据私有性</b></div><div>1.构造函数环境中的私有数据（Crockford私有模式）</div><div><ul><li>在调用构造函数时，创建了两个东西：构造函数实例和环境。该实例由构造函数初始化，而该环境保持了构造函数的参数和局部变量。每个在构造函数内部创建的函数（包括方法）都会保存此环境（创建函数时的环境）的引用。由于保存了此环境的引用 ，即使在构造函数执行结束后，也仍然可以访问这个环境。这种函数和环境的结合称为闭包。构造函数的环境是独立于实例的数据存储，且与实例关联只因为这两个是同时创建的。<br/></li><li>公有属性：给定的构造函数有两种属性是公有的，任何人都可以访问。原型属性存储在Obj.prototype中并被所有实例共享，实例属性是每个实例所独有的，这些属性通常在构造函数中添加并保存数据。<br/></li><li>私有值：构造函数的环境由参数和局部变量组成，只能从构造函数内部访问，因此被实例所私有。<br/></li><li>特权方法：函数在构造函数内部创建，并被添加作为实例的方法。这种函数可以访问私有数据，它是公有的且因此对原型方法可见。<br/></li><li>利弊：不是很优雅、是完全安全的、可能比较慢、消耗更多的内存<br/></li></ul></div><div>2.使用标记的键的属性保存私有数据</div><div><ul><li>利弊：提供了更自然的编码风格、污染了属性的命名空间、可以从“外部”访问私有属性、会导致键的冲突<br/></li></ul></div><div>3.使用具体化键的属性保存私有数据</div><div>4.通过IIFE保持全局数据私有</div><div><ul><li>把私有全局数据存储于一个单例对象<br/></li><li>保持全局数据对所有构造函数私有<br/></li><li>把全局数据放在一个方法中<br/></li></ul></div><div><br/></div><div><b>J.构造函数之间的继承</b></div><div>1.继承实例属性：实例的属性是在它自己的构造函数中设置的，因此继承父构造函数的实例属性会涉及调用其父构造函数，不要通过new调用Super，因为这样会创建一个新的Super实例。使用Super.call(this,……)</div><div>2.继承原型属性：指定Sub.prototype的原型为Super.prototype，使用Object.create()</div><div>3.确保instanceof正常工作：意味着每个Sub的实例必须也是Super的实例。</div><div>4.覆写方法</div><div>5.父调用：从（原型中的）当前方法中的主对象“之后”，开始查找；查找方法；用当前的this调用此方法，基本原理是，父方法（supermethod）必须作为当前方法使用同一实例调用，父方法必须可以访问同一实例的属性；</div><div>6.避免硬编码父构造函数的名字：可以通过把父原型赋值给Sub的一个属性来避免这个问题。</div><div><br/></div><div><b>K.所有对象的方法</b></div><div>1.转换为原始值</div><div><ul><li>Object.prototype.toString()：转换为字符串<br/></li><li>Object.prototype.valueOf()：转换为数字<br/></li></ul></div><div>2.Object.prototype.toLocaleString()：返回特定于本地语言环境的代表对象的字符串</div><div>3.原型式继承和属性</div><div><ul><li>Object.prototype.isPrototypeOf(obj)：如果接收者属于obj原型链的一部分，则返回true<br/></li><li>Object.prototype.hasOwnProperty(key)：如果this拥有键为key的属性，则返回true<br/></li><li>Object.prototype.propertyIsEnumerable(propKey)：如果接收者具有键为propKey的可枚举属性，则返回true，否则返回false<br/></li></ul></div><div><br/></div><div><b>L.泛型方法：借用原型方法</b></div><div>1.通过字面量访问Object.prototype和Array.prototype</div><div><ul><li>{}.hasOwnProperty.call(obj,’propKey’)<br/></li><li>[].join.call(str,’-')<br/></li></ul></div><div>2.类似数组的对象和泛型方法：像数组但没有数组的方法且没有数组的原型链</div><div><ul><li>特殊变量arguments<br/></li><li>使用document.getElementsBy*返回的DOM节点对象<br/></li><li>类数组的字符串<br/></li><li>var arr = Array.prototype.slice.call(arguments);<br/></li></ul></div><div><br/></div><div><b>M.缺陷：Object作为Map使用</b></div><div>1.继承影响读取属性</div><div>2.覆写会影响调用方法</div><div>3.特殊属性__proto__：对象不能在键为’__proto__’的属性中存储映射数据，如果允许使用，属性对它进行转义</div><div>4.字典模式：没有原型的对象更适合用作映射，没有继承的属性</div><div><br/></div><div><b>N.备忘录：对象的使用*P267</b></div><div><br/></div><div>/speakingjavascript/17-1.js<br/></div><div>/speakingjavascript/17-2.js<br/></div><div><br/></div><div><b><font style="font-size: 24px;">十八、数组</font></b></div><div><b>A.概述</b></div><div>1.数组是映射，不是元组</div><div>2.数组也可以具有属性：但并不认为属性是数组的一部分</div><div><br/></div><div><b>B.创建数组</b></div><div>1.字面量创建数组，后面的逗号会被忽略</div><div>2.数组构造函数：使用Array，可以创建给定长度的空数组，或给定元素的数组。new是可选的，作为普通函数调用和作为构造函数调用是相同的。</div><div>3.尽量避免使用给定元素的数组</div><div><br/></div><div><b>C.数组索引</b></div><div>1.范围：0&lt;=i&lt;2^32-1，在这个范围之外的索引被视为普通的属性键。它们不会作为数组元素呈现，且不影响length属性。</div><div>2.delete删除数组元素，会产生空缺（不会更新属性length），也可以通过减少数组长度来删除数组尾部的元素。</div><div>3.ECMAScript规范的索引解释：</div><div><ul><li>属性键P(字符串)是某个数组的索引当且仅当ToString(ToUnit32(P))等于P且ToUnit32(P)不等于2^32-1<br/></li><li>数组属性的键是数组索引，这个属性称为元素<br/></li></ul></div><div>4.属性键(P)必须等于以下计算结果：</div><div><ul><li>把P转换为数字<br/></li><li>把数字化为32位无符号整型<br/></li><li>把整型转化为字符串<br/></li></ul></div><div>5.属性键(P)字符串：</div><div><ul><li>字符串不能包含总是可以转化为0的数字，字符串化之后，并不等于字符串<br/></li><li>范围之外的字符串化的整型也会转化成完全不同的整型，字符串化后并不等于这个字符串<br/></li><li>字符串化的非整型数字转换为整型，结果也是不相等的<br/></li></ul></div><div><br/></div><div><b>D.长度</b></div><div>1.length的基本功能是追踪数组的最大索引，因此不计算元素的个数，必须编写函数来实现，先用forEach跳过空缺的元素</div><div><br/></div><div><b>E.数组中的“空缺”</b></div><div>1.数组是由索引（indice）到值（value）的映射。这意味着数组可以有“空缺”（hole），索引个数小于数组长度说明数据缺少一些元素。在缺少元素的索引处读取该元素会返回undefined</div><div>2.含有空缺的数组称为稀疏（sparse），不含空缺的数组称为密集（dense）。密集数组是连续的，且在每个索引处（从0开始，到length-1结束）都存在元素。</div><div>3.涉及数组的一些操作会忽略空缺</div><div><ul><li>数组遍历方法：forEach()遍历时跳过空缺、every()也会跳过空缺、map()虽然会跳过，但保留空缺、filter()去除了空缺<br/></li><li>其他数组方法：join()把空缺、undefined和null转化为空字符串、sort()在排序时保留空缺<br/></li><li>For-in循环：可以正确地列出属性键<br/></li><li>Function.prototype.apply()：会把空数组中的空缺转换为undefined，但不能用来填补做生意数组（包含或不包含空缺）的空缺。<br/></li></ul></div><div><br/></div><div><b>F.添加和删除元素（破坏性地）</b></div><div><ul><li>Array.prototype.shift()：移除索引0处的元素并返回该元素。随后元素的索引依次减1<br/></li><li>Array.prototype.unshift()：在数组最前面增加给定元素，返回新的数组长度<br/></li><li>Array.prototype.pop()：移除数组最后的元素并返回该元素<br/></li><li>Array.prototype.push()：在数组的尾部增加给定元素，返回新的数组长度<br/></li><li>Array.prototype.push.apply()：破坏性地把数组arr2添加到另一个数组arr1之后<br/></li><li>Array.prototype.splice(start,deleteCount?,elem1?,elem2?……)：从索引start开始，移除deleteCount个元素，并插入给定的元素。换句话说，用elem1、elem2等元素替换了从索引start开始的deleteCount个元素。该方法返回被移除的元素<br/></li></ul></div><div><br/></div><div><b>G.排序和颠倒元素顺序（破坏性地）</b></div><div><ul><li>Array.prototype.reverse()：颠倒数组中的元素，并返回指向原（修改后）数组的引用<br/></li><li>Array.prototype.sort()：数组排序，并返回排序后的数组<br/></li></ul></div><div><br/></div><div><b>H.合并、切分和连接（非破坏性地）</b></div><div><ul><li>Array.prototype.concat()：创建一个新数组，其中包括接受者的所有元素，其次是数组arr1的所有元素。如果其中一个参数不是数组，那么它作为元素添加到结果中<br/></li><li>Array.prototype.slice(begin?,end?)：把数组从begin开始到end（不包含end）的元素复制到新数组中<br/></li><li>Array.prototype.join()：通过对所有数组元素应用toString()创建字符串，并用separator连接字符串。如果缺少separator，默认使用’,’<br/></li></ul></div><div><br/></div><div><b>I.值的查找（非破坏性地）</b></div><div><ul><li>Array.prototype.indexOf(searchValue,startIndex?)：从数组的startIndex开始，查找searchValue。返回第一次出现的索引，如果没找到返回-1<br/></li><li>Array.prototype.lastIndexOf(searchElement,startIndex?)：从数组的startIndex开始，反向查找searchValue<br/></li></ul></div><div><br/></div><div><b>J.迭代（非破坏性地）</b></div><div>1.检测方法：arr.examinationMethod(callback,thisValue?)</div><div><ul><li>Array.prototype.forEach(callback,thisValue?)：遍历数组中的元素<br/></li><li>Array.prototype.every(callback, thisValue?)：如果对每个元素，回调函数都返回true，则返回true。一旦回调函数返回false，则停止迭代<br/></li><li>Array.prototype.some(call,thisValue?)：如果回调函数至少有一个元素返回true，则返回true。一旦函数返回true，则停止迭代。<br/></li></ul></div><div>2.转化方法：function callback(element,index,array)</div><div><ul><li>Array.prototype.map(callback,thisValue?)：输出数组的每个元素是对输入元素应用callback后的结果<br/></li><li>Array.prototype.filter(callback,thisValue?)：输入数组只包含callback返回为true的输入元素。<br/></li></ul></div><div>3.归约函数：function callback(previousValue,currentElement,currentIndex,array)</div><div><ul><li>Array.prototype.reduce(callback,initialValue?)：从左到右进行迭代，并按照之前描述的调用回调函数。这个方法的结果是由回调函数返回的最后的值<br/></li><li>Array.prototype.reduceRight(callback,initialValue?)：与reduce()原理相同，但从右到左<br/></li></ul><div><br/></div><div>/speakingjavascript/18.js<br/></div></div><div><br/></div><div><b><font style="font-size: 24px;">十九、正则表达式</font></b></div><div><b>A.创建正则表达式</b></div><div>1.字面量：/xyz/i，加载时编译</div><div>2.构造函数：new RegExp(‘xyz’,’i')，运行时编译</div><div>3.标识：</div><div><ul><li>g（global），给定的正则可以匹配多次<br/></li><li>i（ignoreCase），试图匹配给定的正则时忽略大小写<br/></li><li>M（multiline），在多行模式时，开始操作符^和结束操作符$匹配每一行<br/></li></ul></div><div><br/></div><div><b>B.正则方法</b></div><div><ul><li>RegExp.prototype.test()：是否存在匹配<br/></li><li>String.prototype.search()：匹配位置的索引<br/></li><li>RegExp.prototype.exec()：捕获分组<br/></li><li>String.prototype.match()：捕获分组或返回所有匹配的子字符串<br/></li><li>String.prototype.replace()：查找和替换<br/></li></ul></div><div><br/></div><div><b>C.标识/g的一些问题</b></div><div>1.带有/g的正则表达式不能内联</div><div>2.带有/g的正则表达式作为参数：为了安全起见，应该设置lastIndex为0（test()和exec()时）</div><div>3.共享带有/g的正则表达式：需要把lastIndex设置为0</div><div><br/></div><div><b>D.提示与技巧</b></div><div>1.缺少断言（例如^、$）的正则表达式可以在任意位置匹配</div><div>2.匹配一切：new RegExp(‘’).test()或/(?:)/，不匹配任何字符：/.^/</div><div><br/></div><div><b>E.正则表达式备忘单：P310</b></div><div><br/></div><div>/speakingjavascript/19.js<br/></div><div><br/></div><div><b><font style="font-size: 24px;">二十、Date</font></b></div><div><b>A.Date构造函数</b></div><div>1.new Date(year, month,date?,hours?,minutes?,seconds?,milliseconds?)</div><div><br/></div><div><b>B.Date原型方法</b></div><div><ul><li>Date.prototype.get&lt;&lt;Unit&gt;&gt;()：根据当地时间返回单位时间<br/></li><li>Date.prototype.set&lt;&lt;Unit&gt;&gt;()：根据当地时间设置单位时间<br/></li><li>Date.prototype.getUTC&lt;&lt;Unit&gt;&gt;()：根据世界时间返回单位时间<br/></li><li>Date.prototype.setUTC&lt;&lt;Unit&gt;&gt;()：根据世界时间设置单位时间<br/></li><li>Date.prototype.getTime()：返回毫秒数（从1970.1.1开始）<br/></li><li>Date.prototype.setTime()：以毫秒数为单位指定日期<br/></li><li>Date.prototype.valueOf()：当日期转换成数值的时候调用此方法<br/></li><li>Date.prototype.getTimezoneOffset()：以分钟为单位返回当地时间与世界时间的偏差<br/></li><li>Date.prototype.getFullYear()：获取年<br/></li><li>Date.prototype.setFullYear()：设置年<br/></li><li>Date.prototype.toTimeString()：返回当前时区的时间<br/></li><li>Date.prototype.toLocaleTimeString()：返回的时间格式是具备地区特性的<br/></li><li>Date.prototype.toDateString()：返回日期<br/></li><li>Date.prototype.toLocaleDateString()：具备地区特性的日期<br/></li><li>Date.prototype.toString()：返回的日期和时间落在当前的时区内不包含毫秒<br/></li><li>Date.prototype.toLocaleString()：具备地区特性<br/></li><li>Date.prototype.toUTCString()：返回世界时间<br/></li><li>Date.prototype.toISOString()：所有的内部属性都出现在返回的字符串中<br/></li><li>Date.prototype.toJSON()：以日期为对象转换成JSON字符串<br/></li></ul></div><div><br/></div><div><b><font style="font-size: 24px;">二十一、Math</font></b></div><div><b>A.Math属性</b></div><div>Math.E（欧拉常数）、Math.LN2（2的自然对数）、Math.LN10（10的自然对数）、Math.LOG2E（以2为底的e的对数）、Math.LOG10E（以10为底的e的对数）、Math.PI（圆周率）、Math.SQRT1_2（1/2的平方根）、Math.SQRT2（2的平方根）</div><div><br/></div><div><b>B.数值函数</b></div><div><ul><li>Math.abs()：绝对值<br/></li><li>Math.ceil(x)：返回大于等于x的最小整数 <br/></li><li>Math.exp(x)：返回e的x次幂<br/></li><li>Math.floor(x)：返回小于等于x的最大整数<br/></li><li>Math.log(x)：返回x的自然对数<br/></li><li>Math.pow(x)：返回x的y次幂<br/></li><li>Math.round(x)：返回最接近x的整数 <br/></li><li>Math.sqrt(x)：返回根号x<br/></li></ul></div><div><br/></div><div><b>C.三角函数</b></div><div><ul><li>Math.acos(x)：返回x的反余弦值<br/></li><li>Math.atan(x)：返回x的反正切值<br/></li><li>Math.cos(x)：返回x的余弦值<br/></li><li>Math.sin(x)：返回x的正弦值<br/></li><li>Math.tan(x)：返回x的正切值<br/></li></ul></div><div><br/></div><div><b>D.其他函数</b></div><div><ul><li>Math.min(……)：返回参数中最小的数字，通过apply可以应用于数组<br/></li><li>Math.max(……)：返回参数中最大的数字，通过apply可以应用于数组<br/></li><li>Math.random()：返回一个伪随机数，0&lt;=r&lt;=1<br/></li></ul></div><div><br/></div><div><b><font style="font-size: 24px;">二十二、JSON</font></b></div><div><b>A.背景</b></div><div>1.遵循两个原则</div><div><ul><li>字符串必须使用双引号，字符串字面量是无效的<br/></li><li>属性键也必须使用双引号<br/></li></ul></div><div><br/></div><div><b>B.JSON.stringify(value, replacer?,space?)</b></div><div>1.将值valueOf转换成JSON字符串</div><div>2.replacer用于转换前替换参数value：节点访问函数、属性键白名单</div><div>3.space影响输出格式，没有这个参数将以单行文本输出：可选数字和字符来控制缩进</div><div>4.解析不被JSON支持的内容：</div><div><ul><li>一个不被支持的值返回undefined，如JSON.stringify(function(){})<br/></li><li>不被支持的属性直接被忽略，如JSON.stringify({foo:function(){}})<br/></li><li>不被支持的值在数组中被解析成null，如JSON.stringify([function(){}])<br/></li></ul></div><div>5.JSON.stringify()遇到一个对象具有toJSON方法，则直接该方法来获得字符串化的值，内置toJSON的：</div><div>Boolean.prototype.toJSON()、Number.prototype.toJSON()、String.prototype.toJSON()、Date.prototype.toJSON()</div><div><br/></div><div><b>C.JSON.parse(text, reviver?)</b></div><div>1.解析方便格式的JSON数据，返回相应的值</div><div>2.reviver是一个节点访问函数，可以用来转换解析后的数据</div><div><br/></div><div><b><font style="font-size: 24px;">二十三、标准全局变量</font></b></div><div><b>A.构造器</b></div><div>Array、Boolean、Date、Function、Number、Object、RegExp、String</div><div><br/></div><div><b>B.Error构造器</b></div><div>Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError</div><div><br/></div><div><b>C.非构造器函数</b></div><div><ul><li>encodeURI(uri)：用百分号来编码特殊字符，除了;,/?:@&amp;=+$#a-zA-z0-9-_.!~*’()<br/></li><li>encodeURIComponent(uriComponent)：编码，除了a-zA-Z0-9-_.!~*’()<br/></li><li>decodeURI()：解码encodeURI<br/></li><li>decodeURIComponent()：解码encodeURIComponent<br/></li><li>废弃函数：escape()、unescape()<br/></li><li>isFinite(number)检测是否为infinity、isNaN()、parseFloat()、parseInt()<br/></li></ul></div><div><br/></div><div><b>D.通过eval()和new Function()来动态执行JS代码</b></div><div>1.非严格模式中，eval所执行的代码会在当前作用域下创建本地变量，而严格模式下不会</div><div>2.执行eval()的方式有两种</div><div><ul><li>直接调用：直接调用eval函数<br/></li><li>间接调用：通过将eval()存储在另一个名称下并通过call()方法来调用<br/></li></ul></div><div>3.new Function()会创建全局作用域的函数</div><div>4.尽可能使用new Function()来替代eval执行代码，参数更为没弄明白</div><div>5.最佳实践是尽量避免使用eval()和new Function()。动态执行代码通常相对比较慢并且存在安全隐患</div><div><br/></div><div><b>E.Console API</b></div><div>console.clear()、console.debug()、console.error()、console.exception()、console.info()、console.log()、console.trace()、console.warn()、console.assert()、console.count()、console.dir()、console.dirxml()、console.group()、console.groupCollapsed()、console.groupEnd()、console.table()、console.markTimeline()、console.profile()、console.profileEnd()、console.time()、console.timeEnd()、console.timeStamp()</div><div><br/></div><div><b><font style="font-size: 24px;">二十四、编码和JavaScript</font></b></div><div>1.对于你自己的应用，可以使用Unicode。但是必须声明app的HTML页面是UTF-8编码的</div><div><br/></div><div><b><font style="font-size: 24px;">二十五、ECMAScript 5 的新特性</font></b></div><div>P366-p369</div><div><br/></div><div><b><font style="font-size: 24px;">二十六、元编程风格指南</font></b></div><div><b>A.通用技巧</b></div><div>1.代码应该具有一致性</div><div>2.代码应该易于理解：简短并不总是更好的；好的代码是一本教科书（代码应该解释正在发生的事情，注释应该解释事情为什么发生、文档应该填补代码和注释留下的空白）；</div><div>3.不要自作聪明，不要让人思考</div><div>4.避免优化代码速度或大小</div><div><br/></div><div><b>B.普遍认可的最佳实践</b></div><div>1.使用严格模式；总是使用分号；总是使用严格相等（===）和严格不等（!==）；只有空格或只用制表符缩进，但不要混合使用；引用字符串；避免全局变量；</div><div>2.括号风格：使用1TBS，左括号开始于同一行的语句头部之后，if(x){这样</div><div>3.推荐字面量而不是构造函数</div><div>4.不要自作聪明：不要嵌套条件操作符；使用逻辑操作符时，不要简写if语句；使用自增或自减操作符作为语句而不要作为表达式；检查undefined；使用Math.round()转换整数；</div><div>5.可接受的技巧：使用或(||)提供默认值；使用泛型方法，把Object.prototype简写为{}，把Array.prototype简写为[]；ECMAScript5中末尾的逗号是合法的；ECMAScript5允许使用保留字作为属性键；</div><div><br/></div><div><b>C.具有争议的规则</b></div><div>1.面向对象</div><div><ul><li>推荐构造函数而不是其他实例创建模式<br/></li><li>避免私有数据使用闭包<br/></li><li>即使构造函数没有参数，也要写括号<br/></li><li>小心操作符优先级<br/></li></ul></div><div><br/></div><div><b><font style="font-size: 24px;">二十七、调试的语言机制</font></b></div><div><ul><li>调试器声明的行为类似于设置数点并启动调试器<br/></li><li>console.log(x)把x的值输出到JS引擎的控制台<br/></li><li>console.trace()把堆栈跟踪信息打印到引擎的控制台<br/></li></ul></div><div><br/></div><div><b><font style="font-size: 24px;">二十八、子类化内置构造函数</font></b></div><div><b>A.术语</b></div><div>1.使用“子类化内置构造函数(subclass a built-in)”，而避免采用“扩展(extend)”</div><div><br/></div><div><b>B.障碍1：具有内部属性的实例</b></div><div>1.在JS中常用的子类化技术是在子类构造函数中调用超类构造函数，且作用域中this指向子类自身</div><div>2.解决方法：直接复制方法和属性到实例中</div><div><br/></div><div><b>C.障碍2：内置的构造函数不能作为方法调用</b></div><div>1.解决方法：在子类构造函数中，新建一个超类实例，并且将超类实例的属性复制到子类实例中</div><div><br/></div><div><b>D.另一种解决方案：委托</b></div><div><br/></div><div><b><font style="font-size: 24px;">二十九、JSDoc：生成API文档</font></b></div><div>1.通过/**来标记内容</div><div><br/></div><div><b><font style="font-size: 24px;">三十、类库</font></b></div><div>1.shim和polyfill，在旧的JS引擎上改造新的功能</div><div><br/></div><div><b><font style="font-size: 24px;">三十一、模块系统和包管理器</font></b></div><div><b>A.模块系统</b></div><div>1.CommonJS模块(CommonJS Module,CJS)：化身就是Node.js模块，紧凑的语法、同步加载的设计、主要用于服务端</div><div>2.异步模块定义（Asynchronous Module Definition,AMD）：典型就是Requirejs，语法稍复杂但不通过eval或者静态编译步骤就可以工作、异步加载的设计、主要用于浏览器</div><div><br/></div><div><b>B.包管理器</b></div><div>npm、Bower、Browserify</div><div><br/></div><div><b><font style="font-size: 24px;">三十二、其他工具</font></b></div><div>1.代码检测：JSLint、JSHint、ESLint</div><div>2.单元测试：Jasmine、mocha</div><div>3.压缩：UglifyJS、YUI Compressor、Closure Compiler</div><div><br/></div></span>
</div></body></html> 