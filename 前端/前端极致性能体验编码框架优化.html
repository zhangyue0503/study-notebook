<html>
<head>
  <title>前端极致性能体验编码框架优化</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="2134"/>
<h1>前端极致性能体验编码框架优化</h1>

<div><span><div><span style="-en-paragraph:true;">我们说的“快”，并不仅仅指浏览器器加载页面快，就是常说的秒开率，一般指DomContentLoad时间。但是“快”其实包含更多的含义，除了前面说的浏览器</span><span style="color: #ff0000;-en-paragraph:true;">加载快</span><span style="-en-paragraph:true;">，还包含浏览器</span><span style="color: #ff0000;-en-paragraph:true;">解析快</span><span style="color: #000000;-en-paragraph:true;">（Javascript脚本发布时通常都会做代码压缩混淆，不仅是减少体积，也为了安全性），JS脚本</span><span style="color: #ff0000;-en-paragraph:true;">编译快</span><span style="color: #000000;-en-paragraph:true;">（我们知道javascript在浏览器的javascript虚拟机【managed runtime environment for JavaScript，JavaScript托管运行时环境】中运行的，所以也需要编辑JS脚本成字节码，才能运行），最后一个就是javascript</span><span style="color: #ff0000;-en-paragraph:true;">执行快</span><span style="color: #000000;-en-paragraph:true;">。</span><span style="-en-paragraph:true;">
</span></div><h1>优化策略
</h1><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">链路优化中，我们已经解决了JavaScript下载加速的问题，那么剩下的优化工作主要集中在优化浏览器解析、编译并执行JS脚本。影响浏览器解析和执行JS脚本的因素主要是JS脚本的体积大小和代码的复杂程度。所以编程代码优化实践主要是减少代码的体积和按需降低代码复杂度，实现浏览器</span><span style="color: #ff0000;-en-paragraph:true;">解析快，</span><span style="color: #000000;-en-paragraph:true;">JS脚本</span><span style="color: #ff0000;-en-paragraph:true;">编译快</span><span style="-en-paragraph:true;">。
</span></div><ul><li><div>代码体积大，加载就会耗时，而且占用cdn存储资源和http请求资源，浏览器解析时暂用内存多，分析代码耗时。</div></li><li><div>代码复杂度高，代码解析就比较耗时。如果依赖一些复杂的类库，还要考虑库的解析和执行时间。浏览器解析代码会占用更多内存，使用堆栈更深，执行耗时。</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;"> 
</span></div><h2>首屏渲染
</h2><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">有许多方法可以用来减少程序的初始化加载时间。最小化加载的 JavaScript 数量：代码越少，解析耗时越少，运行时间越少。为了达到此目的，可以用特殊的方法传输必需的代码而不是一股劳地加载一大坨代码。比如，</span><a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/" style="-en-paragraph:true;">PRPL</a><span style="-en-paragraph:true;"> 模式即表示该种代码传输类型。或者，可以检查依赖然后查看是否有无用、冗余的依赖导致代码库的膨胀。然而，这些东西需要很大的篇幅来进行讨论。可以先参考下：</span><a href="https://www.fed123.com/javascriptnodejs/3447.html" style="-en-paragraph:true;">提升javascript代码编译速度的几点建议</a><span style="-en-paragraph:true;">。这里我们主要介绍PRPL模型。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">移动网络非常慢。这些年，网络已从以文档为中心的平台演化为一流的应用平台。 有赖于平台本身的进步（例如</span><a href="https://developers.google.com/web/fundamentals/getting-started/primers/service-workers" style="-en-paragraph:true;">服务工作线程</a><span style="-en-paragraph:true;">）以及我们用于构建应用的工具和技术，用户在网络上几乎可以通过虚拟方式执行任何操作，就像在本机应用中操作一样。同时，我们大量的计算也已经发生变化，从使用快速、稳定网络连接的强大桌面设备转移到连接经常较慢、不稳定（或两者兼有）的相对欠强大的移动设备上。特别是在孕育着下一批十亿用户的地方，这一点体现得尤为真切。很遗憾，我们在桌面时代设计用于构建和部署强大、功能丰富的网络应用的模式通常会导致应用在移动设备上的加载时间过长 – 漫长的时间让很多用户选择放弃应用。这为创建新模式提供了机会，新模式需要利用现代网络平台功能更快速、更精细地提供移动网络体验。PRPL 就是这样一种模式。
</span></div><h3>PRPL 模式
</h3><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">PRPL 是一种用于结构化和提供 Progressive Web App (PWA) 的模式，该模式强调应用交付和启动的性能。 它代表：
</span></div><ul><li><div><span style="font-weight: bold;">推送</span> – 为初始网址路由推送关键资源。</div></li><li><div><span style="font-weight: bold;">渲染</span> – 渲染初始路由。</div></li><li><div><span style="font-weight: bold;">预缓存</span> – 预缓存剩余路由。</div></li><li><div><span style="font-weight: bold;">延迟加载</span> – 延迟加载并按需创建剩余路由。</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">除了针对 PWA 的基本目标和标准外，PRPL 还竭力在以下方面进行优化：
</span></div><ul><li><div>尽可能减少交互时间</div></li><ul><li><div>特别是第一次使用（无论入口点在何处）</div></li><li><div>特别是在真实的移动设备上</div></li></ul><li><div>尽可能提高缓存效率，特别是在发布更新时</div></li><li><div>开发和部署的简易性</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">PRPL 的灵感来源于一套现代网络平台功能，不必在首字母缩略词中打出每个字母或使用每个功能就可以应用这一模式。实际上，PRPL 更多的是一种思维模式和提高移动网络性能的长期愿景，而不仅仅是特定技术或技巧。PRPL 背后的理念并不新，但该方法由 Polymer 团队构建框架和命名，并在 </span><a href="https://www.youtube.com/watch?v=J4i0xJnQUzU" style="-en-paragraph:true;">Google I/O 2016</a><span style="-en-paragraph:true;"> 上公布。如果您的单页面应用 (SPA) 采用以下结构，PRPL 完全适用：
</span></div><ul><li><div>应用的主_进入点_从每个有效的路由提供。 此文件应非常小，它从不同网址提供，因此会被缓存多次。 进入点的所有资源网址都需要是绝对网址，因为它可以从非顶级网址提供。</div></li><li><div><span style="font-style: italic;">Shell</span> 或 App Shell，包含顶级应用逻辑、路由器，等等。</div></li><li><div>延迟加载的应用_片段_。片段可以表示特定视图的代码，或可延迟加载的其他代码（例如，首次绘制不需要的部分主应用，如用户与应用交互前未显示的菜单）。Shell 负责在需要时动态导入片段。</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">服务器和服务工作线程协同为非活动路由预缓存资源。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">用户切换路由时，应用会延迟加载尚未缓存的任何所需资源，并创建所需视图。 路由重复访问应当可以立即交互。 服务工作线程这时可以提供很大帮助。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">下图显示了使用</span><a href="http://webcomponents.org/" style="-en-paragraph:true;">web components</a><span style="-en-paragraph:true;">构建的一个简单应用的组件：
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">在此图表中，实线表示_静态依赖项_：使用 </span><span style="-en-paragraph:true;">&lt;link&gt;</span><span style="-en-paragraph:true;"> 和 </span><span style="-en-paragraph:true;">&lt;script&gt;</span><span style="-en-paragraph:true;"> 标记在文件中标识的外部资源。 虚线表示_动态_或_按需加载的依赖项_：根据 Shell 所需加载的文件。构建过程会构建一个包含所有这些依赖项的图表，服务器会使用此信息高效地提供文件。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这里是简单介绍了PRPL的思想，后续文章会介绍具体PRPL应用。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">首屏渲染的含义主要是要开发者关注自己所开发页面的重点，能够有意识的区分出首屏关键内容和资源和非首屏内容。正如</span><a href="https://www.fed123.com/pwa/2390.html" style="-en-paragraph:true;">本系列课程</a><span style="-en-paragraph:true;">开篇中提到，要求开发者首先要了解业务。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">了解开发的重点，那么我们在开发中可以将首屏编码和非首屏分开，着重优化首屏模块，优先加载和执行，打包策略上也可以有所侧重和区分。待首屏渲染完成，再去加载其他资源，</span><span style="color: #ff6600;-en-paragraph:true;">渲染用户不可见部分内容</span><span style="-en-paragraph:true;">（可能是一个全屏弹窗，可能是一个二级页面，或者是首页的下半部分页面）。具体使用可以先参考这里：</span><a href="https://houssein.me/thinking-prpl" style="-en-paragraph:true;">thinking-prpl</a><span style="-en-paragraph:true;">
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;"> 
</span></div><h2>懒加载组件
</h2><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">LazyLoad懒加载组件是为了实现页面数据懒加载，主要是实现图片懒加载和页面模块懒加载。
</span></div><ul><li><div>图片懒加载，我们渲染页面模块时，通常是一个组件，如果是商品列表这种，组件最后渲染出来的html就包含了许多img标签，如果立马加载这些图片会占用浏览器资源。特别是在首屏渲染时，会影响首屏时间。如果图片很多，很大，通常我们会做图片占位，然后懒加载，如果图片不多，图片位置也不大，那么可以预判下是否影响首屏，可以不做懒加载。</div></li><li><div>模块懒加载，在用户交互操作中，判断模块是否在可是窗口内，如果在视口，那么就要渲染，当然通常是留有余量的，比如下拉滚动页面，需要在快到达视口的时候就初始化模块。</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">因为在手机端H5页面基本都会是下拉加载展示的形态，所以懒加载是必不可少的基础功能组件。我们可以采用H5最新的IntersectionObserver方法轻松实现判断元素是否进入视口，当然对于不支持这个API的浏览器依然可以使用getBoundingClientRect这个api拿到元素的位置信息进行计算作为退化方案。代码如下：
</span></div><ul><li><div>// the attribute that save image src</div></li><li><div>const ATTR_IMAGE_URL = 'data-src';</div></li><li><div>// the img's className</div></li><li><div>const CLASSNAME = 'fe-lazyload';</div></li><li><div>// the unloaded img's selector</div></li><li><div>const IMG_SELECTOR = `img[${ATTR_IMAGE_URL}].${CLASSNAME}`;</div></li><li><div>// the default rootMargin Y</div></li><li><div>const DEFAULT_ROOTMARGINY = 667;</div></li><li><div>// the default rootMargin X</div></li><li><div>const DEFAULT_ROOTMARGINX = 0;</div></li><li><div>/**</div></li><li><div>* @method onload</div></li><li><div>* @param callback {Function}</div></li><li><div>* @private</div></li><li><div>*/</div></li><li><div>function onload(callback) {</div></li><li><div>let run = function () {</div></li><li><div>setTimeout(callback, 10);</div></li><li><div>};</div></li><li><div>if (document.readyState === 'complete') {</div></li><li><div>run();</div></li><li><div>} else {</div></li><li><div>window.addEventListener('load', run);</div></li><li><div>}</div></li><li><div>}</div></li><li><div>/**</div></li><li><div>* _.throttle from Underscore.js</div></li><li><div>* @param func</div></li><li><div>* @param wait</div></li><li><div>* @returns {Function}</div></li><li><div>* @private</div></li><li><div>*/</div></li><li><div>function throttle(func, wait, options) {</div></li><li><div>var context, args, result;</div></li><li><div>var timeout = null;</div></li><li><div>var previous = 0;</div></li><li><div>if (!options) options = {};</div></li><li><div>var _now = function () {</div></li><li><div>return window.performance ? performance.now() : Date.now();</div></li><li><div>}</div></li><li><div>var later = function () {</div></li><li><div>previous = options.leading === false ? 0 : _now();</div></li><li><div>timeout = null;</div></li><li><div>result = func.apply(context, args);</div></li><li><div>if (!timeout) context = args = null;</div></li><li><div>};</div></li><li><div>return function () {</div></li><li><div>var now = _now();</div></li><li><div>if (!previous &amp;&amp; options.leading === false) previous = now;</div></li><li><div>var remaining = wait - (now - previous);</div></li><li><div>context = this;</div></li><li><div>args = arguments;</div></li><li><div>if (remaining &lt;= 0 || remaining &gt; wait) {</div></li><li><div>clearTimeout(timeout);</div></li><li><div>timeout = null;</div></li><li><div>previous = now;</div></li><li><div>result = func.apply(context, args);</div></li><li><div>if (!timeout) context = args = null;</div></li><li><div>} else if (!timeout &amp;&amp; options.trailing !== false) {</div></li><li><div>timeout = setTimeout(later, remaining);</div></li><li><div>}</div></li><li><div>return result;</div></li><li><div>}</div></li><li><div>}</div></li><li><div>/**</div></li><li><div>* convert anything to an array that contain elements</div></li><li><div>* @method processElement</div></li><li><div>* @param container</div></li><li><div>* @returns {*}</div></li><li><div>* @private</div></li><li><div>*/</div></li><li><div>function processElement(container) {</div></li><li><div>if (typeof container === 'string') {</div></li><li><div>// return [...document.querySelectorAll(container)]</div></li><li><div>return Array.from(document.querySelectorAll(container))</div></li><li><div>} else if (container instanceof HTMLElement) {</div></li><li><div>return [container];</div></li><li><div>} else if (container instanceof HTMLCollection) {</div></li><li><div>// return [...container];</div></li><li><div>return Array.from(container);</div></li><li><div>} else {</div></li><li><div>return container;</div></li><li><div>}</div></li><li><div>}</div></li><li><div>// store innerHeight &amp; innerWidth</div></li><li><div>let _innerHeight;</div></li><li><div>let _innerWidth;</div></li><li><div>const getInnerHeight = function () {</div></li><li><div>return _innerHeight || (_innerHeight = window.innerHeight);</div></li><li><div>};</div></li><li><div>const getInnerWidth = function () {</div></li><li><div>return _innerWidth || (_innerWidth = window.innerWidth);</div></li><li><div>};</div></li><li><div>/**</div></li><li><div>* a lazyload component</div></li><li><div>*/</div></li><li><div>class Lazyload {</div></li><li><div>/**</div></li><li><div>* @param {String|HTMLElement|HTMLCollection} [container=document.body] - the images' container, support</div></li><li><div>* @param {Object} [config]</div></li><li><div>* @param {Number} [config.rootMarginY=0] - same as the IntersectionObserver's rootMargin. The default is 0, and will auto increase to 667 after onload, then check if the images are need to load</div></li><li><div>* @param {Number} [config.rootMarginX=0] - same as the IntersectionObserver's rootMargin.</div></li><li><div>* @param {String|HTMLElement} [config.scroller=window] - the scroll element, same as the IntersectionObserver's root</div></li><li><div>* @param {Function} [config.processor] - the function to change the image's src before load</div></li><li><div>*/</div></li><li><div>constructor(container, config = {}) {</div></li><li><div>this._containers = container ? processElement(container) : [document.body];</div></li><li><div>this._config = Object.assign({</div></li><li><div>scroller: window,</div></li><li><div>rootMarginY: 0,</div></li><li><div>rootMarginX: 0</div></li><li><div>}, config);</div></li><li><div>if (typeof this._config.scroller === 'string') {</div></li><li><div>this._config.scroller = document.querySelector(this._config.scroller);</div></li><li><div>}</div></li><li><div>if (!config.rootMarginY) {</div></li><li><div>onload(() =&gt; {</div></li><li><div>this._config.rootMarginY = DEFAULT_ROOTMARGINY;</div></li><li><div>if (window.IntersectionObserver) {</div></li><li><div>this.pause();</div></li><li><div>this.resume();</div></li><li><div>} else {</div></li><li><div>this._check();</div></li><li><div>}</div></li><li><div>});</div></li><li><div>}</div></li><li><div>this.refresh();</div></li><li><div>}</div></li><li><div>/**</div></li><li><div>* recollect images, and load images which is in viewport immediately</div></li><li><div>*/</div></li><li><div>refresh() {</div></li><li><div>this.pause();</div></li><li><div>this._containers.forEach((container) =&gt; {</div></li><li><div>// container.images = [...container.querySelectorAll(IMG_SELECTOR)];</div></li><li><div>container.images = Array.from(container.querySelectorAll(IMG_SELECTOR));</div></li><li><div>});</div></li><li><div>this.resume();</div></li><li><div>}</div></li><li><div>/**</div></li><li><div>* pause the listener</div></li><li><div>*/</div></li><li><div>pause() {</div></li><li><div>if (!this._runing) {</div></li><li><div>return;</div></li><li><div>}</div></li><li><div>this._runing = false;</div></li><li><div>if (this._io) {</div></li><li><div>this._io.disconnect();</div></li><li><div>} else {</div></li><li><div>this._config.scroller.removeEventListener('scroll', this._listener, {</div></li><li><div>passive: true</div></li><li><div>});</div></li><li><div>if (this._config.scroller !== window) {</div></li><li><div>window.removeEventListener('scroll', this._listener, {</div></li><li><div>passive: true</div></li><li><div>});</div></li><li><div>}</div></li><li><div>window.removeEventListener('orientationchange', this._listener);</div></li><li><div>}</div></li><li><div>}</div></li><li><div>/**</div></li><li><div>* resume the listener, and load images which is in viewport immediately</div></li><li><div>*/</div></li><li><div>resume() {</div></li><li><div>if (this._runing) {</div></li><li><div>return;</div></li><li><div>}</div></li><li><div>this._runing = true;</div></li><li><div>if (window.IntersectionObserver) {</div></li><li><div>this._io = new IntersectionObserver(entries =&gt; {</div></li><li><div>entries.forEach(entry =&gt; {</div></li><li><div>if (entry.intersectionRatio &gt; 0) {</div></li><li><div>let target = entry.target;</div></li><li><div>this._load(target);</div></li><li><div>this._io.unobserve(target);</div></li><li><div>if (this._containers.every(container =&gt; {</div></li><li><div>container.images = container.images.filter(img =&gt; {</div></li><li><div>return img !== target;</div></li><li><div>});</div></li><li><div>return !container.images.length;</div></li><li><div>})) {</div></li><li><div>this.pause();</div></li><li><div>}</div></li><li><div>}</div></li><li><div>});</div></li><li><div>}, {</div></li><li><div>//root: this._config.scroller === window ? null : this._config.scroller,</div></li><li><div>rootMargin: `${this._config.rootMarginY}px ${this._config.rootMarginX}px`,</div></li><li><div>threshold: 0.0001</div></li><li><div>});</div></li><li><div>this._containers.forEach(container =&gt; {</div></li><li><div>container.images.forEach(img =&gt; {</div></li><li><div>this._io.observe(img);</div></li><li><div>});</div></li><li><div>});</div></li><li><div>} else {</div></li><li><div>this._listener = throttle(() =&gt; {</div></li><li><div>this._check();</div></li><li><div>}, 50);</div></li><li><div>this._config.scroller.addEventListener('scroll', this._listener, {</div></li><li><div>passive: true</div></li><li><div>});</div></li><li><div>if (this._config.scroller !== window) {</div></li><li><div>window.addEventListener('scroll', this._listener, {</div></li><li><div>passive: true</div></li><li><div>});</div></li><li><div>}</div></li><li><div>window.addEventListener('orientationchange', this._listener);</div></li><li><div>this._check();</div></li><li><div>}</div></li><li><div>}</div></li><li><div>/**</div></li><li><div>* add container that contain images, and load images which is in viewport immediately</div></li><li><div>* @param {String|HTMLElement} el - the images' container</div></li><li><div>*/</div></li><li><div>addContainer(el) {</div></li><li><div>this._containers = this._containers.concat(processElement(el));</div></li><li><div>this.refresh();</div></li><li><div>}</div></li><li><div>/**</div></li><li><div>* load image</div></li><li><div>* @param {HTMLElement} el - the image element</div></li><li><div>* @private</div></li><li><div>*/</div></li><li><div>_load(el) {</div></li><li><div>let source = el.getAttribute(ATTR_IMAGE_URL);</div></li><li><div>if (source) {</div></li><li><div>let processor = this._config.processor;</div></li><li><div>if (processor) {</div></li><li><div>source = processor(source, el);</div></li><li><div>}</div></li><li><div>el.addEventListener('load', () =&gt; {</div></li><li><div>el.classList.remove(CLASSNAME);</div></li><li><div>});</div></li><li><div>el.src = source;</div></li><li><div>el.removeAttribute(ATTR_IMAGE_URL);</div></li><li><div>}</div></li><li><div>}</div></li><li><div>/**</div></li><li><div>* check if the image is in viewport, and load images which is in viewport immediately</div></li><li><div>* @private</div></li><li><div>*/</div></li><li><div>_check() {</div></li><li><div>let rootMarginY = this._config.rootMarginY;</div></li><li><div>let rootMarginX = this._config.rootMarginX;</div></li><li><div>let isInViewPort = this.constructor.isInViewPort;</div></li><li><div>let notEmptyContainers = this._containers.filter((container) =&gt; {</div></li><li><div>// if the container is not in the viewport, then return</div></li><li><div>if (!isInViewPort(container, {</div></li><li><div>rootMarginX,</div></li><li><div>rootMarginY</div></li><li><div>})) {</div></li><li><div>return true;</div></li><li><div>}</div></li><li><div>let loadImgs = (imgs) =&gt; {</div></li><li><div>return imgs.filter((img) =&gt; {</div></li><li><div>let is = isInViewPort(img, {</div></li><li><div>rootMarginX,</div></li><li><div>rootMarginY</div></li><li><div>});</div></li><li><div>if (is) {</div></li><li><div>// maybe other instance had done</div></li><li><div>if (!img.getAttribute(ATTR_IMAGE_URL)) {</div></li><li><div>return false;</div></li><li><div>}</div></li><li><div>this._load(img);</div></li><li><div>}</div></li><li><div>return !is;</div></li><li><div>});</div></li><li><div>};</div></li><li><div>// load images and filter them from the list</div></li><li><div>container.images = loadImgs(container.images);</div></li><li><div>return container.images.length;</div></li><li><div>});</div></li><li><div>if (!notEmptyContainers.length) {</div></li><li><div>// pause self after all images had loaded</div></li><li><div>this.pause();</div></li><li><div>}</div></li><li><div>}</div></li><li><div>/**</div></li><li><div>* observe an element when entering into the viewport</div></li><li><div>* @static</div></li><li><div>* @param {String|HTMLElement|HTMLCollection} el - the element to be observed</div></li><li><div>* @param {Function} callback - the callback function</div></li><li><div>* @param {Object} [config]</div></li><li><div>* @param {Number} [config.rootMarginY] - same as the IntersectionObserver's rootMargin.</div></li><li><div>* @param {Number} [config.rootMarginX] - same as the IntersectionObserver's rootMargin.</div></li><li><div>* @param {String|HTMLElement} [config.scroller=window] - the scroll element, same as the IntersectionObserver's root</div></li><li><div>*/</div></li><li><div>static addListener(el, callback, config) {</div></li><li><div>if (typeof el === 'string') {</div></li><li><div>el = document.querySelector(el);</div></li><li><div>}</div></li><li><div>config = Object.assign({</div></li><li><div>scroller: window,</div></li><li><div>rootMarginY: DEFAULT_ROOTMARGINY,</div></li><li><div>rootMarginX: DEFAULT_ROOTMARGINX</div></li><li><div>}, config);</div></li><li><div>let isInViewPort = this.isInViewPort;</div></li><li><div>if (window.IntersectionObserver) {</div></li><li><div>let io = new IntersectionObserver(entries =&gt; {</div></li><li><div>if (entries[0].intersectionRatio &gt; 0) {</div></li><li><div>callback();</div></li><li><div>io.disconnect();</div></li><li><div>}</div></li><li><div>}, {</div></li><li><div>root: config.scroller === window ? null : config.scroller,</div></li><li><div>rootMargin: `${config.rootMarginY}px ${config.rootMarginX}px`,</div></li><li><div>threshold: 0.0001</div></li><li><div>});</div></li><li><div>io.observe(el);</div></li><li><div>} else {</div></li><li><div>let check = function () {</div></li><li><div>return isInViewPort(el, {</div></li><li><div>rootMarginX: config.rootMarginX,</div></li><li><div>rootMarginY: config.rootMarginY</div></li><li><div>});</div></li><li><div>}</div></li><li><div>if (check()) {</div></li><li><div>return callback();</div></li><li><div>}</div></li><li><div>let listener = throttle(() =&gt; {</div></li><li><div>if (check()) {</div></li><li><div>config.scroller.removeEventListener('scroll', listener, {</div></li><li><div>passive: true</div></li><li><div>});</div></li><li><div>window.removeEventListener('orientationchange', listener);</div></li><li><div>callback();</div></li><li><div>}</div></li><li><div>}, 50);</div></li><li><div>config.scroller.addEventListener('scroll', listener, {</div></li><li><div>passive: true</div></li><li><div>});</div></li><li><div>window.addEventListener('orientationchange', listener);</div></li><li><div>}</div></li><li><div>}</div></li><li><div>/**</div></li><li><div>* to detect if the element is in the viewport</div></li><li><div>* @param {HTMLElement} el - the element that to be detected</div></li><li><div>* @param {Object} [config]</div></li><li><div>* @param {Number} [config.rootMarginY=0] - same as the IntersectionObserver's rootMargin</div></li><li><div>* @param {Number} [config.rootMarginX=0] - same as the IntersectionObserver's rootMargin</div></li><li><div>* @returns {boolean}</div></li><li><div>* @static</div></li><li><div>*/</div></li><li><div>static isInViewPort(el, config) {</div></li><li><div>if (!_innerHeight || !_innerWidth) {</div></li><li><div>window.addEventListener('orientationchange', function () {</div></li><li><div>_innerHeight = window.innerHeight;</div></li><li><div>_innerWidth = window.innerWidth;</div></li><li><div>});</div></li><li><div>}</div></li><li><div>config = Object.assign({</div></li><li><div>rootMarginX: 0,</div></li><li><div>rootMarginY: 0</div></li><li><div>}, config);</div></li><li><div>let clientRect = el.getBoundingClientRect();</div></li><li><div>return !(</div></li><li><div>(!clientRect.width &amp;&amp; !clientRect.height) ||</div></li><li><div>clientRect.top - getInnerHeight() &gt; config.rootMarginY ||</div></li><li><div>clientRect.bottom + config.rootMarginY &lt; 0 ||</div></li><li><div>clientRect.left - getInnerWidth() &gt; config.rootMarginX ||</div></li><li><div>clientRect.right + config.rootMarginX &lt; 0</div></li><li><div>)</div></li><li><div>}</div></li><li><div>}</div></li><li><div>export default Lazyload;</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">注意：代码中监听了orientationchange事件，在手机横竖屏切换时，需要重新计算。
</span></div><h2>滚动加载分页组件
</h2><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">对于移动端页面，最常见的交互形式莫过于下拉长列表。常见的实现方式有两种：
</span></div><ul><li><div>基于Virtual DOM方式，基于数据驱动开发，像使用React、Vue等框架开发，通过追加数据实现长列表加载展示。这样的开发方式比较简单，但是问题多多。首先就是性能问题，每次要重新渲染整个DOM，这也是为什么一般React、Vue在检查列表循环的时候都要求为循环组件提供一个唯一的key，这样方便快速比对diff DOM更新。然后就是对于稍微复杂的交互处理起来很麻烦，比如多TAB切换时，做DOM回收和复用，就很难做到。</div></li><li><div> 基于DOM操作方式，其实基于ES6模块和字符模板也是很好的开发方式。DOM的操作方式更灵活，但是对于这种下拉滚动加载的情况，需要我们统一处理下拉滚动事件。主要是判断container是否滚动到底部，如果滚动到底部，抛出事件回调。</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">对于滚动加载组件，比简单的方法是在container内最后面插入一个loading元素，然后判断这个loading元素是否进入视口，进入视口可以采用lazyload懒加载的判断逻辑。那么整体思路就清晰了，参考一下代码。
</span></div><ul><li><div>import EE from &quot;eventemitter3&quot;</div></li><li><div>/**</div></li><li><div>* append elements to items container</div></li><li><div>*</div></li><li><div>* @param {String|HTMLElement} elements - the elements appended to the container</div></li><li><div>* @param {HTMLElement} container - the target container</div></li><li><div>* @private</div></li><li><div>*/</div></li><li><div>function append(elements, container) {</div></li><li><div>if (typeof elements === 'string') {</div></li><li><div>let c = document.createElement('div');</div></li><li><div>c.innerHTML = elements;</div></li><li><div>elements = document.createDocumentFragment();</div></li><li><div>[...c.childNodes].forEach(el =&gt; {</div></li><li><div>elements.appendChild(el);</div></li><li><div>})</div></li><li><div>}</div></li><li><div>container.appendChild(elements);</div></li><li><div>}</div></li><li><div>/**</div></li><li><div>* A scrollview which support infinite scroll.</div></li><li><div>* @extends eventemitter3</div></li><li><div>*/</div></li><li><div>class InfiniteScroll extends EE {</div></li><li><div>/**</div></li><li><div>* @param {Object} config</div></li><li><div>* @param {String|HTMLElement} config.container - the container</div></li><li><div>* @param {String|HTMLElement} [config.scroller=window] - the scroll element，need be seted in ios, because need bind scroll event</div></li><li><div>* @param {String|HTMLElement} [config.itemsContainer=.items] - the container of items</div></li><li><div>* @param {String|HTMLElement} [config.indicator=.indicator] - the loading indicator</div></li><li><div>* @param {Number} [config.rootMarginY=200] - the distance to determine when to load the next page</div></li><li><div>*/</div></li><li><div>constructor(config = {}) {</div></li><li><div>super();</div></li><li><div>config = Object.assign({</div></li><li><div>rootMarginY: 200,</div></li><li><div>scroller: window,</div></li><li><div>itemsContainer: '.items',</div></li><li><div>indicator: '.indicator'</div></li><li><div>}, config);</div></li><li><div>let getEl = function (el, container) {</div></li><li><div>return typeof el === 'string' ? (container || document).querySelector(el) : el;</div></li><li><div>}</div></li><li><div>/**</div></li><li><div>* @property {HTMLElement} container - the infinite scroll's container</div></li><li><div>*/</div></li><li><div>this.container = getEl(config.container);</div></li><li><div>this._itemsContainer = getEl(config.itemsContainer, this.container);</div></li><li><div>this._scroller = getEl(config.scroller, this.container);</div></li><li><div>this._indicator = getEl(config.indicator, this.container);</div></li><li><div>this._rootMarginY = config.rootMarginY;</div></li><li><div>/**</div></li><li><div>* @property {Number} page - the current page's index (start from 0)</div></li><li><div>*/</div></li><li><div>this.page = 0;</div></li><li><div>}</div></li><li><div>/**</div></li><li><div>* the common plug interface to add functions</div></li><li><div>* @param {Object} Plugin - the plugin</div></li><li><div>* @param {Object} [config] - the plugin's config</div></li><li><div>*/</div></li><li><div>use(Plugin, config) {</div></li><li><div>return Plugin.init(this, config)</div></li><li><div>}</div></li><li><div>/**</div></li><li><div>* strat infinite scroll, and request the first page of data</div></li><li><div>*/</div></li><li><div>init() {</div></li><li><div>// init infinite scroll</div></li><li><div>if (window.IntersectionObserver) {</div></li><li><div>this._io = new IntersectionObserver((entries) =&gt; {</div></li><li><div>if (entries[0].intersectionRatio &gt; 0) {</div></li><li><div>this.pause();</div></li><li><div>this._requestAndRender();</div></li><li><div>}</div></li><li><div>}, {</div></li><li><div>root: this._scroller === window ? null : this._scroller,</div></li><li><div>threshold: 0.000001,</div></li><li><div>rootMargin: `${this._rootMarginY}px 0px`</div></li><li><div>})</div></li><li><div>} else {</div></li><li><div>this._listener = () =&gt; {</div></li><li><div>if (this._check()) {</div></li><li><div>this.pause();</div></li><li><div>this._requestAndRender();</div></li><li><div>}</div></li><li><div>};</div></li><li><div>}</div></li><li><div>// request first page</div></li><li><div>this._requestAndRender();</div></li><li><div>}</div></li><li><div>/**</div></li><li><div>* reset state, empty the items container, resume infinite scroll</div></li><li><div>*/</div></li><li><div>reset() {</div></li><li><div>this._itemsContainer.innerHTML = '';</div></li><li><div>this._indicator.style.display = '';</div></li><li><div>this.page = 0;</div></li><li><div>this._requestAndRender();</div></li><li><div>}</div></li><li><div>/**</div></li><li><div>* resume infinite scroll</div></li><li><div>*/</div></li><li><div>resume() {</div></li><li><div>if (this._io) {</div></li><li><div>this._io.observe(this._indicator);</div></li><li><div>} else if (this._listener) {</div></li><li><div>this._scroller.addEventListener('scroll', this._listener);</div></li><li><div>}</div></li><li><div>}</div></li><li><div>/**</div></li><li><div>* pause infinite scroll</div></li><li><div>*/</div></li><li><div>pause() {</div></li><li><div>if (this._io) {</div></li><li><div>this._io.unobserve(this._indicator);</div></li><li><div>} else if (this._listener) {</div></li><li><div>this._scroller.removeEventListener('scroll', this._listener);</div></li><li><div>}</div></li><li><div>}</div></li><li><div>/**</div></li><li><div>* request data and render</div></li><li><div>* @private</div></li><li><div>*/</div></li><li><div>_requestAndRender() {</div></li><li><div>this.request({</div></li><li><div>page: this.page</div></li><li><div>}).then((res) =&gt; {</div></li><li><div>if (res) {</div></li><li><div>append(this.render(res), this._itemsContainer);</div></li><li><div>/**</div></li><li><div>* after new items appended to items container</div></li><li><div>* @event InfiniteScroll#append</div></li><li><div>*/</div></li><li><div>this.emit('append');</div></li><li><div>}</div></li><li><div>if (res &amp;&amp; res.hasMore) {</div></li><li><div>this.page++;</div></li><li><div>this.resume();</div></li><li><div>} else {</div></li><li><div>this._indicator.style.display = 'none';</div></li><li><div>/**</div></li><li><div>* after loaded the last page</div></li><li><div>* @event InfiniteScroll#finish</div></li><li><div>*/</div></li><li><div>this.emit('finish');</div></li><li><div>}</div></li><li><div>}, () =&gt; {</div></li><li><div>this._indicator.style.display = 'none';</div></li><li><div>/**</div></li><li><div>* request data error</div></li><li><div>* @event InfiniteScroll#error</div></li><li><div>*/</div></li><li><div>this.emit('error');</div></li><li><div>});</div></li><li><div>}</div></li><li><div>/**</div></li><li><div>* try again to load the current page and render</div></li><li><div>*/</div></li><li><div>retry() {</div></li><li><div>this._indicator.style.display = '';</div></li><li><div>this._requestAndRender();</div></li><li><div>}</div></li><li><div>/**</div></li><li><div>* you must achieve this interface to request data, you should return a promise</div></li><li><div>* @method InfiniteScroll#request</div></li><li><div>* @param {Object} params - the request data</div></li><li><div>* @param {Number} params.page - the page number</div></li><li><div>* @return {Promise}</div></li><li><div>*/</div></li><li><div>/**</div></li><li><div>* you must achieve this interface to render view</div></li><li><div>* @method InfiniteScroll#render</div></li><li><div>* @param {*} params - the data return by the request interface</div></li><li><div>* @return {String|HTMLElement}</div></li><li><div>*/</div></li><li><div>/**</div></li><li><div>* detect if need to request next page</div></li><li><div>* @returns {boolean}</div></li><li><div>* @private</div></li><li><div>*/</div></li><li><div>_check() {</div></li><li><div>let scrollerIsWindow = this._scroller === window;</div></li><li><div>let height = (scrollerIsWindow ? document.body : this._scroller).scrollHeight;</div></li><li><div>let top = scrollerIsWindow ? window.pageYOffset : this._scroller.scrollTop;</div></li><li><div>let offset = scrollerIsWindow ? window.innerHeight : this._scroller.clientHeight;</div></li><li><div>return (height - top - offset) &lt;= this._rootMarginY;</div></li><li><div>}</div></li><li><div>}</div></li><li><div>export default InfiniteScroll</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">注意：为了不影响性能，我们在监听scroll事件的时候最后都要加上passive: true这个参数，以免阻塞浏览器UI渲染。
</span></div><h2>web worker
</h2><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;"> 
</span></div><h2>task切分
</h2><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;"> 
</span></div><h2>代码分割与打包
</h2><ol><li><div>按需引用</div></li><li><div>打包代码拆分</div></li></ol><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;"> 
</span></div><h2>项目架构优化
</h2><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这里说的VM架构项目泛指应用了诸如React，pReact，Vue，Angular等前端框架的项目。有时候我们的页面比较复杂，比如淘宝的SKU选择页面，选择商品属性后要伴随价格和库存，图片等许多信息变化，state状态频繁发生变化的这种需求页面，就比较适合用框架来处理。这样代码逻辑更健壮，结合单向数据流处理的便利，更容易开发出高质量代码。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">在这里，我们对比了4个流行的框架（库）：react, vue, angular1, angular2 ，在最小化情况下的启动性能。对比条件如下：
</span></div><ol><li><div>使用每个框架写了一个 Hello World 级别的 App。</div></li><li><div>不引入 redux 这种库，忽略不同框架功能上的不同，目标是做到代码最小。</div></li><li><div>angular2 分为 AOT 和 非 AOT 两种 build 方式。</div></li><li><div>vue 使用 runtime only 的版本。</div></li><li><div>由于 Angular2 要正常工作，需要预先引入两个polyfill: “es7-reflect” , “zone.js” ，这两个库被单独打包在另外一个文件里，所以结果中除了 Angular2 本身的性能，还包含这两个被依赖的 js 库的性能。</div></li></ol><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">测试代码在：</span><a href="http://link.zhihu.com/?target=https%3A//github.com/allenm/js-framework-performance-compare" style="-en-paragraph:true;">allenm/js-framework-performance-compare: Compare some popular javascript framework ( library) performance .</a><span style="-en-paragraph:true;">
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">从结果中可以得出结论：
</span></div><ol><li><div>vue 的启动性能最好，明显优于其他的几个框架。</div></li><li><div>Angular2 的 AOT with tree shaking 相对于非 AOT 的版本，性能提升明显，但依然落后于 vue 和 react。</div></li><li><div>Chrome 的启动性能要明显慢于 Safari。</div></li><li><div>低端 Android 机器的启动性能非常差，和 iPhone 的差距 10 倍左右，当然价格也接近 10 倍 :)</div></li></ol><div><span style="-en-paragraph:true;"> 
</span></div></span>
</div></body></html> 