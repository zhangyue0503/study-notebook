<html>
<head>
  <title>Effective JavaScript编写高质量JavaScript代码的68个有效方法</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="2023"/>
<h1>Effective JavaScript编写高质量JavaScript代码的68个有效方法</h1>

<div>
<span><div><b><font style="font-size: 24px;">一、让自己习惯JavaScript</font></b></div><div><br/></div><div><b>A.了解你使用的JavaScript版本</b></div><div>1.严格模式：此特性允许你选择在受限制的JavaScript版本中禁止使用一些JavaScript语言中问题较多或蝗于出错的特性。可以向后兼容（”use strict”）</div><div>2.严格模式指令只有在脚本或函数的顶部才能生效</div><div>3.要想构建代码以获得最大的兼容性，最简单的方法是在严格模式下写代码，并显式地将代码内容包裹在本地启用了严格模式的函数中</div><div><br/></div><div><b>B.理解JavaScript的浮点数</b></div><div>1.js中所有的数字都是双精度浮点数</div><div>2.位运算符会把浮点数隐式地转换为32位整数后进行计算</div><div>8 | 1;//9</div><div>(8).toString(2)==1000</div><div>(1).toString(2)==0001</div><div>parseInt(“1001”,2); //9</div><div>3.当心浮点数运算中的精度</div><div>0.1+0.2;//0.300000000……4</div><div>一个可靠的解决方法是尽可能地采用整数值运算</div><div><br/></div><div><b>C.当心隐式的强制转换</b></div><div>1.结果为null的变量在算术运算中不会导致失败，而是被隐式地转换为0；一个未定义的变量将被转换为特殊的浮点数值NaN，NaN是JS中唯一一个不等于它自身的值</div><div>2.对象同时拥有valueOf和toString时，+运算符会选择valueOf来解决</div><div>3.JS中七个假值：false、0、-0、””、NaN、null和undefined</div><div><br/></div><div><b>D.原始类型优于封装对象</b></div><div>1.JS有5个原始值类型：布尔值、数字、字符串、null和undefined（令人困惑的是，对null类型进行typeof操作得到的结果为”object”，ES标准描述其为一个独特的类型）</div><div>2.当做相等比较时，原始类型的封装对象与其原始值行为不一样</div><div>3.获取和设置原始类型的属性会隐式地创建封装对象</div><div><br/></div><div><b>E.避免对混合类型使用 == 运算符</b></div><div><table style="width: 100%; border-collapse: collapse; table-layout: fixed;"><tbody><tr><td style="width: 33.333333333333336%; border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div><span style="">参数类型1</span></div></td><td style="width: 33.333333333333336%; border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><span style="">参数类型2</span></td><td style="width: 33.333333333333336%; border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div><span style="">强制转换</span></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>null</div></td><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>undefined</div></td><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>不转换，总是返回true</div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>null或undefined</div></td><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>其他任何非 null或undefined的类型</div></td><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>不转换，总是返回false</div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>原始类型：string、number或boolean</div></td><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>Date对象</div></td><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>将原始类型转换为数字；将Date对象转换为原始类型（优先尝试toString方法，再尝试valueOf方法）</div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>原始类型：string、number或boolean</div></td><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>非Date对象</div></td><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>将原始类型转换为数字；将非Date对象转换为原始类型（优先尝试valueOf方法，再尝试toSring方法）</div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>原始类型：string、number或boolean</div></td><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>原始类型：string、number或boolean<br/></div></td><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;">将原始类型转换为数字</td></tr></tbody></table></div><div>1.更好的策略是显式自定义应用程序转换的逻辑，并使用严格相等运算符 ===</div><div><br/></div><div><b>F.了解分号插入的局限</b></div><div>1.分号仅在}标记之前 、一个或多个换行之后和程序输入的结尾被插入</div><div>2.分号仅在随后 的输入标记不能解析时插入</div><div>*还是别省略了</div><div><br/></div><div><b>G.视字符串为16位的代码单元序列</b></div><div>1.一个JavaScript字符串的元素是一个16位的代码单元</div><div>2.使用第三方的库编写可识别代码点的字符串操作</div><div><br/></div><div><i>/effectivejs/ex1.html</i></div><div><br/></div><div><b><font style="font-size: 24px;">二、变量作用域</font></b></div><div><br/></div><div><b>A.尽量少用全局对象</b></div><div>1.定义全局变量会污染共享的公共命名空间，并可能导致意外的命名冲突，不得模块化，会导致程序中独立组件间的不必要耦合</div><div>2.在web浏览器中，全局对象被绑定到全局的window变量，添加或修改全局变量会自动更新全局变量</div><div>3.可以使用全局对象来进行特性检测，如：（ES5之前没有JSON）</div><div>if(!this.JSON){</div><div><span>    this.JSON = {……};</span><br/></div><div>}</div><div><br/></div><div><b>B.始终声明局部变量</b></div><div>1.始终用var声明局部变量，否则会变成全局变量</div><div><br/></div><div><b>C.避免使用with</b></div><div>1.使用with对象可以很方便地避免对对象的重复引用，但是会受全局变量影响</div><div>2.使用简短的变量名代替重复访问的对象</div><div>3.显式地绑定局部变量到对象属性上，而不要使用with语句隐式地绑定</div><div><br/></div><div><b>D.熟练使用闭包</b></div><div>1.第一个事实：<i><b>JavaScript允许你引用在当前函数以外定义的变量</b></i></div><div>2.第二个事实：<i><b>即使外部函数已经返回，当前函数仍然可以引用在外部函数所定义的变量</b></i></div><div>js包含了比调用它们时执行所需要的代码还要多的信息，js函数还在内部存储它们可能会引用 的定义在其封闭作用域的变量</div><div>3.第三个事实：<i><b>闭包可以更新外部变量的值</b></i></div><div>事实上，闭包存储的是外部变量的引用，而不是它们的值的副本</div><div><br/></div><div><b>E.理解变量声明提升</b></div><div><div>1.词法作用域：即除了极少的例外，对变量foo的引用会被绑定到声明foo变量最近的作用域中。但是，js不支持块级作用域，即变量定义的作用域并不是离其最近的封闭说一句或代码块，而是包含它们的函数</div><div>2.理解js变量声明行为的一个好办法是把变量声明看作由两部分组成，即声明和赋值。js隐式地提升声明部分到封闭函数的顶部，而将赋值留在原地。变量的作用域是整个函数 ，但仅在var语句出现的位置进行赋值</div><div>3.try…catch，catch是块级作用域</div><div><br/></div><div><i>/effectivejs/ex2.html</i></div><div><br/></div><div><b>F.使用立即调用的函数表达式创建局部作用域</b></div><div>1.绑定与赋值的区别：在运行时进入一个作用域，js会为每一个绑定到该作用域的变量在内存中分配一个”槽”。闭包通过引用而不是值捕获它们的外部变量</div><div>2.立即调用的表达式，IIFE。解决js缺少块级作用域的方法。</div><div>3.代码块不能包含任何跑出块的break语句和continue语句。如果代码块引用了this或特别的arguments变量，IIFE将会改变它们的含义。</div><div><br/></div><div><b>G.当心命名函数表达式笨拙的作用域</b></div><div>1.js引擎被要求将命名函数表达式的作用域表示为一个对象，这有点像有问题的with结构。该作用域对象只含有单个属性，该属性将函数名和函数自身绑定起来。该作用域对象也继承了Object.prototype的属性。</div></div><div>2.在系统中避免对象污染函数表达式作用域的最好方式是避免任何时候在Object.prototype中添加属性，以及避免使用任何与标准Object.prototype属性同名的局部变量</div><div>3.命名函数表达式由于会导致很多问题，所以并不值得使用。命名函数表达式适合调试期使用，在Error对象和调试器中使用命名函数表达式改进栈跟踪</div><div><br/></div><div><b>H.当心局部块函数声明笨拙的作用域</b></div><div>1.始终将函数声明置于程序或被包含的函数的最外层以避免不可移植的行为</div><div>2.使用var声明和有条件的赋值语句替代有条件的函数声明</div><div><br/></div><div><b>I.避免使用eval创建局部变量</b></div><div>1. 基于作用域决定程序的动态行为通常是个坏主意。导致的结果是，即使想简单地理解变量是如何绑定的都需要了解程序执行的细节。当源代码将未在局部作用域内定义的变量传递给eval函数时，程序将变得特别棘手</div><div>2.避免使用eval函数创建的变量污染调用者的作用域</div><div>3.如果eval函数代码可能创建全局变量，将此调用封装到嵌套的函数中以防止作用域污染</div><div><br/></div><div><b>J.间接调用eval函数优于直接调用</b></div><div>1.eval不仅仅是一函数，eval函数具有访问调用它那里的整个作用域的能力。</div><div>2.将eval函数同一个毫无意义的字面量包裹在序列表达式中以达到强制使用间接调用eval函数的目的</div><div>3.尽可能间接调用eval函数，而不要直接调用</div><div><br/></div><div><b><font style="font-size: 24px;">三、使用函数</font></b></div><div><br/></div><div><b>A.理解函数调用、方法调用及构造函数调用之间的不同</b></div><div>1.在js，函数、方法和类的构造函数只是单个构造对象的三种不同的使用模式</div><div>2.在方法调用中是由调用表达式自身来确定this变量的绑定。绑定到this变量的对象被称为调用接收者。通常，通过某个对象调用方法将查找该方法并将该对象作为该方法的接收者。</div><div>3.一个使用了this变量的函数，比起作为方法被调用，将它作为函数被调用并不是特别有用。直接调用会将全局对象作为this</div><div>4.构造函数调用将一个全新的对象作为this变量的值并隐式返回这个新对象作为调用结果。构造函数的主要职责是初始化该新对象</div><div><br/></div><div><b>B.熟练掌握高阶函数</b></div><div>1.高阶函数无非是那些将函数作为参数或返回值的函数。将函数作为参数（通常称为回调函数，因为高阶函数”随后调用”它）是一种特别强大、富有表现力的惯用法，也在js程序中被大量使用</div><div>2.学会使用高阶函数可以简化代码并消除繁锁的样板代码</div><div>3.使用高阶函数的信号是出现重复或相似的代码</div><div><br/></div><div><b>C.使用call方法自定义接收者来调用方法</b></div><div>1.使用call方法自定义接收者来调用函数</div><div>2.使用call方法可以调用在给定的对象中不存在的方法</div><div>3.使用call方法定义高阶函数允许使用者给回调函数指定接收者</div><div><br/></div><div><b>D.使用apply方法通过不同数量的参数调用函数</b></div><div>1.使用apply方法指定一个可计算的参数数组来调用可变参数的函数</div><div>2.使用apply方法的第一个参数给可变参数的方法提供一个接收者</div><div><br/></div><div><b>E.使用arguments创建可变参数的函数</b></div><div>1.js给每个函数都隐式地提供了一个名为arguments的局部变量，arguments对象给实参提供了一个类似数组的接口</div><div>2.考虑对可变参数的函数提供一个额外的固定元数的版本，从而使使用者无需借助apply方法</div><div><br/></div><div><b>F.永远不要修改arguments对象</b></div><div>1.永远不要修改arguments对象</div><div>2.使用[].slice.call(arguments)将arguments对象复制到一个真正的数组中再进行修改</div><div><br/></div><div><b>G.使用变量保存arguments的引用</b></div><div>1.当引用arguments时当心函数嵌套层级</div><div>2.绑定一个明确作用域的引用到arguments变量，从而可以在嵌套的函数中引用它</div><div><br/></div><div><b>H.使用bind方法提取具有确定接收者的方法</b></div><div>1.由于方法与值为函数的属性没有区别，因此很容易提取对象的方法并将提取出的函数作为回调函数直接传递给高阶函数。但这也很容易忘记将提取出的函数接收者绑定到该函数被提取出的对象上。</div><div>2.调用bind创建了一个新函数而不是修改了原来的函数，意味着bind方法是安全的，当在任何的原型后代中调用共享方法时，该方法仍能工作。</div><div>3.要注意，提取一个方法不会将方法的接收者绑定到该方法的对象上</div><div><br/></div><div><b>I.使用bind方法实现函数柯里化</b></div><div>1.将函数与其参数的一个子集绑定的技术称为函数柯里化，使用bind方法实现函数柯里化，即创建一个固定需求参数子集的委托函数</div><div>2.传入null或undefined作为接收者的参数来实现函数柯里化，从而忽略其接收者</div><div><br/></div><div><b>J.使用闭包而不是字符串来封装代码</b></div><div>1.函数是一种将代码作为数据结构存储的便利方式，这些代码可以随后被执行。</div><div>2.当将字符串传递给eval函数以执行它们的API时，绝不要在字符串中包含局部变量引用 </div><div>3.接受函数调用的API优于使用eval函数执行字符串的API</div><div><br/></div><div><b>K.不要依赖函数对象的toString方法</b></div><div>1. 当调用函数的toString方法时，并没有要求js引擎能够精确地获取到函数的源代码</div><div>2.由于在不同的引擎下调用toString方法的结果可能不同，所以绝不要依赖函数源码的详细细节</div><div>3.toString方法的执行结果并不会暴露存储在闭包中的局部变量值</div><div>4.通常情况下，应该避免使用函数对象的toString方法</div><div><br/></div><div><b>L.避免使用非标准的栈检查属性</b></div><div>1.避免使用非标准的arguments.caller和arguments.callee属性，它们不具备良好的移植性</div><div>2.避免使用非标准的函数对象caller属性，它是不可靠的</div><div><br/></div><div><font style="font-style: italic;">/effectivejs/ex3.html</font><br/></div><div><br/></div><div><b><font style="font-size: 24px;">四、对象和原型</font></b></div><div><br/></div><div><b>A.理解prototype、getPrototypeOf和__proto__之间的不同</b></div><div>.prototype是建立由new XX()创建的对象的原型</div><div>Object.getPrototypeOf(obj)是es5中用来获取obj对象的原型对象的标准方法</div><div>obj.__proto__是获取obj对象的原型对象的非标准方法</div><div>1.js中的类本质上是一个构造函数与一个用于在该类实例间共享方法的原型对象的结合，是由一个构造函数和一个关联的原型组成的一种设计模式</div><div><br/></div><div><b>B.使用Object.getPrototypeOf函数而不要使用__proto__属性</b></div><div>1.并不是所有js环境都支持通过__proto__属性来获取 对象的原型，该原型不是完全兼容的</div><div>2.在支持__proto__属性的非es5环境中实现Object.getPrototypeOf函数</div><div><br/></div><div><b>C.始终不要修改__proto__属性</b></div><div><div>1.__proto__具有修改对象原型链接的能力，会导致更多的优化抢道，为了保持行为的可预测性，一定不要修改</div><div>2.可以使用es5中的Object.create函数来创建一个具有自定义原型链的新对象</div><div><br/></div><div><b>D.使构造函数与new操作符无关</b></div><div>1.如果忘记使用new，会创建全局变量，函数的接收者将是全局对象</div><div>2通过使用new操作符或Object.create方法在构造函数定义中调用自身使得该构造函数与调用语法无关</div><div>3.当一个函数期望使用new操作符调用时，清晰地文档化该函数</div><div><br/></div><div><b>E.在原型中存储方法</b></div><div>1.将方法存储在实例对象中将创建该函数的多个副本，因为每个实例对象都有一份副本</div><div>2.将方法存储于原型中优于存储在实例对象中</div><div><br/></div><div><b>F.使用闭包存储私有数据</b></div><div>1.js的对象系统并没有特别鼓励或强制信息隐藏</div><div>2.闭包是一种简朴的数据结构。它们将数据存储到封闭的变量中而不提供对这些变量的直接访问。获取闭包内部结构 的唯一方式是该函数显式地提供获取它的途径。对象和闭包具有相反的策略：对象的属性会被自动地暴露出去，然而闭包中的变量会被自动地隐藏起来</div><div>3.闭包对象是私有的，只能通过局部的引用获取</div><div>4.将局部变量作为私有数据从而通过方法实现信息隐藏</div><div><br/></div><div><b>G.只将实例状态存储在实例对象中</b></div><div>1.理解原型对象与其实例之间是一对多的关系</div><div>2.共享可变数据可能会出问题，因为原型是被其所有的实例共享的</div><div>3.将可变的实例状态存储在实例对象中</div><div><br/></div><div><b>H.认识到this变量的隐式绑定问题</b></div><div>1.this变量是以不同的方式审美观点绑定的，每个函数都有一个this变量的隐式绑定，this变量的绑定值是在调用该函数时确定的，this变量是隐式地绑定到最近的封闭函数</div><div>2.直接了当的解决方案是使用词法作用域（局部变量self、me或that）来存储这个额外的外部this绑定的引用，在es5中使用bind方法</div><div><br/></div><div><b>I.在子类的构造函数中调用父类的构造函数</b></div><div>1.在子类构造函数中显式地传入this作为显式的接收者调用父类构造函数</div><div>2.使用Object.create函数来构造子类的原型对象以避免调用父类的构造函数</div><div><br/></div><div><b>J.不要重用父类的属性名</b></div><div>1.留意父类使用的所有属性名</div><div>2.不要在子类中我不用父类的属性名</div><div><br/></div><div><b>K.避免继承标准类</b></div><div>1.继承标准类往往会由于一些特殊的内部属性而被破坏</div><div>2.使用属性委托优于继承标准类</div><div><br/></div><div><b>L.将原型视为实现细节</b></div><div>1.hasOwnProperty方法确定一个属性是否为对象”自己的”属性（即一个实例属性），爱内里菜完全忽视原型继承结构</div><div>2.对象是接口，原型是实现</div><div>3.避免检查你无法控制的对象的原型结构</div><div>4.避免检查实现在你无法控制的对象内部的属性</div><div><br/></div><div><b>M.避免使用轻率的猴子补丁</b></div><div>由于对象共享原型，因此每一个对象都可以增加、删除或修改原型的属性，这个有争议的实践通常被称为猴子补丁。</div><div>1.避免使用轻率的猴子补丁</div><div>2.记录程序库所执行的所有猴子补丁</div><div>3.考虑通过将修改置于一个导出函数中，使猴子补丁成为可选的</div><div>4.使用猴子补丁为缺失的标准API提供polyfills</div></div><div></div><div><br/></div><div><font style="font-style: italic;">/effectivejs/ex4.html</font><br/></div><div><br/></div><div><b><font style="font-size: 24px;">五、数组和字典</font></b></div><div><br/></div><div><b>A.使用Object的直接实例构造轻量级的字典</b></div><div>1.js对象的核心是一个字符串属性名称与属性值的映射表</div><div>2.将对象作为轻量级字典的首要原则是：应该仅仅将Object的直接实例作为字典，而不是其子类，当然也不是数组</div><div>3.使用对象字面量构建轻量级字典</div><div>4.轻量级字典应该是Object.prototype的直接子类，以使for...in循环免受原型污染</div><div><br/></div><div><b>B.使用null原型以防止原型污染</b></div><div>1.Object.create能够使用一个用户指定的原型链和一个属性描述符动态地构造对象，通过简单地传递一个null原型参数和一个空的描述符，我们就可以建立一个真正的空对象，原型污染无法影响这样的对象行为，Object.create(null)</div><div>2.在一些老的环境中，考虑使用(__proto__:null)，要注意__proto__既不标准，也不是完全可移植的，绝不要使用__proto__名作为字典中的key，因为一些环境将其作为特殊的属性对待</div><div><br/></div><div><b>C.使用hasOwnProperty方法以避免原型污染</b></div><div>1.js的对象操作总是以继承的方式工作，即使是一个空的对象字面量也继承了Object.prototype的大量属性</div><div>2.使用词法作用域和call方法避免覆盖hasOwnProperty方法</div><div>3.考虑在封装hasOwnProperty测试样板代码的类中实现字典操作</div><div>4.使用字典类避免将”__proto__”作为key来使用</div><div><br/></div><div><b>D.使用数组而不要使用字典来存储有序集合</b></div><div>1.使用for...in循环来枚举对象属性应当与顺序无关</div><div>2.如果聚集运算字典中的数据，确保聚集操作与顺序无关</div><div>3.使用数组而不是字典来存储有序集合</div><div><br/></div><div><b>E.绝不要在Object.prototype中增加可枚举的属性</b></div><div>1.避免在Object.prototype中增加属性</div><div>2.考虑编写一个函数代替Object.prototype方法</div><div>3.如果你确实需要在Object.prototype中增加属性，请使用es5中的Object.defineProperty方法将它们定义为不可枚举的属性</div><div><br/></div><div><b>F.避免在枚举期间修改对象</b></div><div>1.es规定：如果被枚举的对象在枚举期间添加了新的属性，那么在枚举期间并不能保证新添加的属性能够被访问。如果 我们修改了被枚举的对象，则不能保证for...in循环的行为是可预见的。</div><div>2.当迭代一个对象时，如果该对象的内容可能会在循环期间被改变，应该使用while循环或经典的for循环来代替for...in循环</div><div>3.为了在不断变化的数据结构中能够预测枚举，考虑使用一个有序的数据结构，例如数组，而不要使用字典对象</div><div><br/></div><div><b>G.数组迭代要优先使用for循环而不是for...in循环</b></div><div>1.for…in始终枚举所有key，并且是字符串</div><div>2.迭代数组的索引属性应当总是使用for循环而不是for...in循环</div><div>3.考虑在循环之前将数组的长度存储在一个局部变量中以避免重新计算数组长度</div><div><br/></div><div><b>H.迭代方法优于循环</b></div><div>1.使用迭代方法（如Array.prototype.forEach和Array.prototype.map）替换for循环使得代码更可读，并且避免了重复循环控制逻辑</div><div>2.使用自定义的迭代函数来抽象未被标准库支持的常见循环模式</div><div>3.在需要提前终止循环的情况下，仍然推荐使用传统的循环。另外，some和every方法也可用于提前退出</div><div><br/></div><div><b>I.在类数组对象上复用通用的数组方法</b></div><div>1.类”数组”对象：具有一个范围在0到2的32次方-1的整型length属性；length属性大于该对象的最大索引</div><div>2.对于类数组对象，通过提取方法对象并使用其call方法来利用能用的Array方法</div><div>3.任意一个具有索引属性和恰当length属性的对象都可以使用通用的Array方法</div><div><br/></div><div><b>J.数组字面量优于数组构造函数</b></div><div>1.如果数组构造函数的第一个参数是数字则数组的构造函数行为是不同的</div><div>2.使用数组字面量替代数组构造函数</div><div><br/></div><div><font style="font-style: italic;">/effectivejs/ex5.html</font><br/></div><div><br/></div><div><b><font style="font-size: 24px;">六、库和API设计</font></b></div><div><br/></div><div><b>A.保持一致的规定</b></div><div>1.在变量命名和函数签名中使用一致的约定</div><div>2.不要偏离用户在他们的开发平台中很可能遇到的约定</div><div><br/></div><div><b>B.将undefined看做”没有值”</b></div><div>1.每当js无法提供具体的值时，就产生undefined，未赋值的变量的初始值即为undefined</div><div>2.避免使用undefined表示任何非特定值</div><div>3.使用描述性的字符串值或命名布尔属性的对象，而不要使用undefined或null来代表特定应该标志</div><div>4.提供参数默认值应当采用测试undefined的方式，而不是检查arguments.length</div><div>5.在允许0、NaN或空字符串为有效参数的地方，绝不要通过真值测试来实现参数默认值</div><div><br/></div><div><b>C.接收关键字参数的选项对象</b></div><div>1.参数蔓延：一个函数起初很简单，然而一段时间后，随着库功能的扩展，该函数的签名便会获得越来越多的参数</div><div>2.选项对象：</div><div>var alert = new Alert({x:100,y:75,width:300});</div><div>每个参数都是自我描述</div><div>3.使用选项对象使得API更具可读性、更容易记忆</div><div>4.所有通过选项对象提供的参数应当被视为可选的</div><div>5.使用extend函数抽象出从选项对象中提取值的逻辑</div><div><br/></div><div><b>D.避免不必要的状态</b></div><div>1.API有时被归为两类：有状态的和无状态的。无状态的API提供的函数或方法的行为只取决于输入，而与程序的状态你改变无关。</div><div>2.尽可能使用无状态的API</div><div>3.如果API是有状态的，标示出每个操作与哪些状态有关联</div><div><br/></div><div><b>E.使用结构类型设计灵活的接口</b></div><div>1.使用结构类型（也称为鸭子类型）来设计灵活的对象接口</div><div>2.结构接口更灵活、更轻量，所以应该避免使用继承</div><div>3.针对单元测试，使用mock对象即接口的替代实现来提供可得验的行为</div><div><br/></div><div><b>F.区分数组对象和类数组对象</b></div><div>1.绝不重载与其他类型有重叠的结构类型</div><div>2.当重载一个结构类型与其他类型时，先测试其他类型</div><div>3.当重载其他对象类型时，接收真数组而不是类数组对象</div><div>4.文档标注你的API是否接收真数组或类数组值</div><div>5.使用es5提供的Array.isArray方法测试真数组</div><div><br/></div><div><b>G.避免过度的强制转换</b></div><div>1.许多标准的操作符和代码库会自动地将非预期的输入参数强制转换为期望的类型而不是抛出异常</div><div>2.避免强制转换和重载的混用</div><div>3.考虑防御性地监视非预期的输入</div><div><br/></div><div><b>H.支持方法链</b></div><div>1.无状态的API的部分能力是将复杂操作分解为更小的操作的灵活性。一个很好的例子是字符串的replace方法。</div><div>2.有状态的API的方法链有时被称为流畅式。如果更新方法没返回this，那么API的使用者不得不每次重复该对象名称。</div><div>3.使用方法链来连接无状态的操作</div><div>4.通过在无状态的方法中返回新对象来支持方法链</div><div>5.通过在有状态的方法中返回this来支持方法链</div><div><br/></div><div><font style="font-style: italic;">/effectivejs/ex6.html</font><br/></div><div><br/></div><div><b><font style="font-size: 24px;">七、并发</font></b></div><div><br/></div><div><b>A.不要阻塞I/O事件队列</b></div><div>1.运行到完成机制：任何当前正在运行于共享上下文的用户代码，比如浏览器中的单个Web页面或者单个运行的Web服务器实例，只有在执行完成后才能调用下一个事件处理程序。实际上，系统维护了一个按事件发的顺序排列的内部事件队列，一次调用一个已注册的回调函数。</div><div>2.运行至完成机制的好处是当代码运行时，你完全掌握应用程序的状态。不足是，实际上所有你编写的代码支撑着余下应用程序的继续执行。</div><div>3.js并发的一个最重要的规则是绝不要在应用程序事件队列中使用阻塞I/O的API。在浏览器中，甚至几乎没有任何阻塞API是可用的。异步的API在基于事件的环境中是安全的，因为它们迫使应用程序逻辑在一个独立的事件循环“轮询”中继续处理。</div><div>4.异步API使用回调函数来延缓处理代价高昂的操作以避免阻塞主应用程序</div><div>5.js并发地接收事件，但会使用一个事件队列按序地处理事件处理程序</div><div>6.在应用程序事件队列中绝不要使用阻塞的I/O</div><div><br/></div><div><b>B.在异步序列中使用嵌套或命名的回调函数</b></div><div>1.理解操作序列的最简单的方式是异步API是发起操作而不是执行操作</div><div>2.使用嵌套或命名的回调函数按顺序地执行多个异步操作</div><div>3.尝试在过多的嵌套的回调函数和尴尬的命名的非嵌套回调函数之间取得平衡</div><div>4.避免将可被并行执行的操作顺序化</div><div><br/></div><div><b>C.当心丢弃错误</b></div><div>1.异步的API甚至不可能抛出异常，因为，当一个异步的错误发生时，没有一个明显的执行上下文来抛出异常。异步的API倾向于将错误表示为回调函数的特定参数，或使用一个附加的错误处理回调函数。</div><div>2.通过编写共享的错误处理函数来避免复制和粘贴错误处理代码</div><div>3.确保明确地处理所有的错误条件以避免丢弃错误</div><div><br/></div><div><b>D.对异步循环使用递归</b></div><div>1.循环不能是异步的</div><div>2.使用递归函数在事件循环的单独轮次中执行迭代</div><div>3.在事件循环的单独轮次中执行递归，并不会导致调用栈溢出</div><div><br/></div><div><b>E.不要在计算时阻塞事件队列</b></div><div>1.避免在主事件队列中执行代价高昂的算法</div><div>2.在支持worker API的平台，该API可以用来在一个独立的事件队列中运行长计算程序 </div><div>3.在Worker API不可用或代价最贵的环境中，考虑将计算程序 分解 到事件循环的多个轮次中</div><div><br/></div><div><b>F.使用计数器来执行并行操作</b></div><div>1.当一个程序依赖于特定的事件顺序才能正常工作时，这个程序 会遭受数据竞争。数据竞争是指多个并发操作可以修改共享的数据结构，这取决于它们发生的顺序。</div><div>2.使用计数器避免并行操作中的数据竞争</div><div><br/></div><div><b>G.绝不要同步地调用异步的回调函数</b></div><div>1.即使可以立即得到数据，也绝不要同步地调用异步回调函数</div><div>2.同步地调用异步的回调函数扰乱了预期的操作序列，并可能导致意想不到的交错代码</div><div>3.同步地调用异步的回调函数可能导致栈溢出或错误地处理异常</div><div><br/></div><div><b>H.使用promise模式清洁异步逻辑</b></div><div>1.理解promise的一种方法是将它理解为表示最终值的对象。它封装了一个还未完成的并发操作，但最终会产生一个结果值。</div><div>2.使用promise组合不同的并行操作</div><div>3.使用promise模式的API避免数据竞争</div><div>4.在要求有意的竞争条件时使用select(也被称为choose)</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 