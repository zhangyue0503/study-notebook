<html>
<head>
  <title>Node.js全栈开发【QQ课堂】</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="2567"/>
<h1>Node.js全栈开发【QQ课堂】</h1>

<div><span><div><span style="font-size: 36px; font-weight: bold;">P1：</span></div><div>1.node —inspect，调试</div><div><br/></div><div><span style="font-size: 36px; font-weight: bold;">P2    :</span></div><div><span style="font-weight: bold;">1.定位模块：</span></div><ul><li><div>1）取当前目录下的node_modules为查找路径</div></li><li><div>2）首先尝试把模块标识符当作是文件名处理</div></li><li><div>3）把路径当做目录（包）来处理</div></li><li><div>4）去上一级node_modules重复上面2，3步骤，直到到了根目录</div></li></ul><div><span style="font-weight: bold;">2.模块缓存</span></div><ul><li><div>模块首次加载后就缓存在require.cache</div></li><li><div>清理缓存：</div></li></ul><div><span style="color: rgb(78, 201, 176);">Object</span><span style="color: rgb(212, 212, 212);">.</span><span style="color: rgb(220, 220, 170);">keys</span><span style="color: rgb(212, 212, 212);">(</span><span style="color: rgb(156, 220, 254);">require</span><span style="color: rgb(212, 212, 212);">.</span><span style="color: rgb(156, 220, 254);">cache</span><span style="color: rgb(212, 212, 212);">).</span><span style="color: rgb(220, 220, 170);">forEach</span><span style="color: rgb(212, 212, 212);">(</span><span style="color: rgb(86, 156, 214);">function</span><span style="color: rgb(212, 212, 212);">(</span><span style="color: rgb(156, 220, 254);">key</span><span style="color: rgb(212, 212, 212);">){</span></div><div><span style="color: rgb(86, 156, 214);">    delete</span> <span style="color: rgb(156, 220, 254);">require</span><span style="color: rgb(212, 212, 212);">.</span><span style="color: rgb(156, 220, 254);">cache</span><span style="color: rgb(212, 212, 212);">[</span><span style="color: rgb(156, 220, 254);">key</span><span style="color: rgb(212, 212, 212);">];</span>
</div><div><span style="color: rgb(212, 212, 212);">});</span></div><div><span style="font-weight: bold;">3.npm包</span></div><div><img src="Node.js全栈开发【QQ课堂】_files/Image.png" type="image/png" data-filename="Image.png"/><br/></div><div><span style="font-weight: bold;">4.package.json包含的内容</span></div><ul><li><div>name，包名</div></li><li><div>descriptions，包描述</div></li><li><div>version，版本号</div></li><li><div>main，入口文件</div></li><li><div>scripts，配置脚本命令</div></li><li><div>dependencies，包依赖</div></li><li><div>devDependencies，开发时期需要的包依赖</div></li></ul><div><br/></div><div><span style="font-size: 36px; font-weight: bold;">P3：</span></div><div><span style="font-weight: bold;">1.事件：</span>键盘、请求、文件读取完成</div><div><span style="font-weight: bold;">2.事件循环：</span>事件队列，先进先出处理</div><div><img src="Node.js全栈开发【QQ课堂】_files/Image [1].png" type="image/png" data-filename="Image.png"/><br/></div><div><span style="font-weight: bold;">3.循环模型</span></div><div><img src="Node.js全栈开发【QQ课堂】_files/Image [2].png" type="image/png" data-filename="Image.png"/><br/></div><div><span style="font-weight: bold;">4.每次循环称为一个tick</span></div><div><span style="font-weight: bold;">5.Node.js：</span>基于事件驱动模型的WEB服务器</div><div><span style="font-weight: bold;">6.事件驱动模型服务器：</span>对CPU和I/O的利用率更高</div><div><img src="Node.js全栈开发【QQ课堂】_files/Image [3].png" type="image/png" data-filename="Image.png"/><br/></div><div><span style="font-weight: bold;">7.Node.js服务器特点</span></div><ul><li><div>高并发连接</div></li><li><div>适合I/O密集型任务</div></li><li><div>不适合CPU密集型计算服务</div></li></ul><div><span style="font-weight: bold;">8.发布订阅模式</span></div><div><span style="color: rgb(86, 156, 214);">const</span> <span style="color: rgb(156, 220, 254);">EventEmitter</span> <span style="color: rgb(212, 212, 212);">=</span> <span style="color: rgb(220, 220, 170);">require</span><span style="color: rgb(212, 212, 212);">(</span><span style="color: rgb(206, 145, 120);">'events'</span><span style="color: rgb(212, 212, 212);">)</span>
</div><div><br/></div><div><span style="color: rgb(86, 156, 214);">class</span> <span style="color: rgb(78, 201, 176);">MyEmitter</span> <span style="color: rgb(86, 156, 214);">extends</span> <span style="color: rgb(78, 201, 176);">EventEmitter</span><span style="color: rgb(212, 212, 212);">{}</span>
</div><div><br/></div><div><span style="color: rgb(86, 156, 214);">const</span> <span style="color: rgb(156, 220, 254);">myEmitter</span> <span style="color: rgb(212, 212, 212);">=</span> <span style="color: rgb(86, 156, 214);">new</span> <span style="color: rgb(78, 201, 176);">MyEmitter</span><span style="color: rgb(212, 212, 212);">();</span>
</div><div><span style="color: rgb(96, 139, 78);">//发布者</span></div><div><span style="color: rgb(156, 220, 254);">myEmitter</span><span style="color: rgb(212, 212, 212);">.</span><span style="color: rgb(220, 220, 170);">on</span><span style="color: rgb(212, 212, 212);">(</span><span style="color: rgb(206, 145, 120);">'event'</span><span style="color: rgb(212, 212, 212);">,()</span><span style="color: rgb(86, 156, 214);">=&gt;</span><span style="color: rgb(212, 212, 212);">{</span></div><div><span style="color: rgb(78, 201, 176);">console</span><span style="color: rgb(212, 212, 212);">.</span><span style="color: rgb(220, 220, 170);">log</span><span style="color: rgb(212, 212, 212);">(</span><span style="color: rgb(206, 145, 120);">'触发了一个事件'</span><span style="color: rgb(212, 212, 212);">);</span></div><div><span style="color: rgb(212, 212, 212);">});</span></div><div><span style="color: rgb(96, 139, 78);">//订阅者</span></div><div><span style="color: rgb(156, 220, 254);">myEmitter</span><span style="color: rgb(212, 212, 212);">.</span><span style="color: rgb(220, 220, 170);">emit</span><span style="color: rgb(212, 212, 212);">(</span><span style="color: rgb(206, 145, 120);">'event'</span><span style="color: rgb(212, 212, 212);">);</span></div><div><span style="font-weight: bold;">9.发布者负责触发（发布）事件</span>，订阅者在监听（订阅）事件之后，当事件触发，则执行响应的回调方法</div><div><span style="font-weight: bold;">10.回调地狱：</span>回调多层嵌套</div><div><span style="font-weight: bold;">11：async/await</span>：Promise语法糖</div><ul><li><div>ES7</div></li><li><div>await后面必须跟Promise对象，否则相当于没写</div></li><li><div>async封装成一个Promise对象，声明方法是一个异步方法</div></li></ul><div><br/></div><div><span style="font-size: 36px; font-weight: bold;">P4：</span></div><div>1.npm install mysql —save</div><div>2.Sequelize库，ORM库</div><div>3.频繁的创建和释放连接会有性能问题</div><div>4.资源池的优点</div><ul><li><div>资源重用</div></li><li><div>更快的响应速度</div></li><li><div>统一的连接管理，避免数据库连接泄漏</div></li><li><div>更好的资源分配</div></li></ul><div><br/></div><div><span style="font-size: 36px; font-weight: bold;">P5：</span></div><div><span style="font-weight: bold;">1.创建子进程</span></div><ul><li><div>child_process.spawn</div></li><li><div>child_process.exec</div></li><li><div>child_process.execFile</div></li><li><div>child_process.fork</div></li></ul><div><span style="font-weight: bold;">2.spawn</span>：默认是以管道流形式创建</div><div><span style="font-weight: bold;">3.exec：</span>不是以管道流的形式，先缓存在内存，当回调执行的时候父进程才获取到，适合数据输出比较少</div><div><span style="font-weight: bold;">4.进程间通信：</span></div><ul><li><div>通过IPC传递消息</div></li><li><div>仅能传递字符串，对象会被序列化</div></li></ul><div><span style="font-weight: bold;">5.多进程集群：</span>采用master/worker模式</div><div><span style="font-weight: bold;">6.轮叫调度：</span>nodejs默认采用抢占策略，轮叫调度主进程分配</div><div>7.Cluster模块</div><div><br/></div><div><span style="font-size: 36px; font-weight: bold;">P6：</span></div><div>1.killall node</div><div>2.mocha单元测试框架</div><div><br/></div><div><br/></div><div><span style="font-weight: bold; font-size: 36px;">P7：</span></div><div>1.pm2:</div><ul><li><div>pm2 start bin/www -i max —watch</div></li><li><div>                           多进程 最大cpu 监控修改（测试环境用）</div></li><li><div>pm2 ecosystem：远程部署配置文件</div></li><li><div>Pm2 deploy production update 更新代码</div></li></ul><div>2.请求页面及解析html</div><div><ul><li><div><span style="color: rgb(206, 145, 120);">request-promise</span></div></li></ul></div><div><ul><li><div><span style="color: rgb(206, 145, 120);">cheerio</span></div></li></ul></div><div>3.桌面应用：electron</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 