<html>
<head>
  <title>你不知道的JavaScript（中卷）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="2076"/>
<h1>你不知道的JavaScript（中卷）</h1>

<div>
<span><div><b><font style="font-size: 24px;">一、类型</font></b></div><div><br/></div><div>1.对语言引擎和开发人员来说，类型是值的内部特征，它定义了值的行为，以使其区别于其他值</div><div><br/></div><div><b>A.内置类型</b></div><div>1.七种：null、undefined、boolean、number、string、object、symbol</div><div>2.null类型：typeof null === “object”</div><div>3.typeof function a(){} === “function”，function是object的一个“子类型”，函数是可调用对象，它有一个内部属性[[call]]，该属性可以被调用</div><div><br/></div><div><b>C.值和类型</b></div><div>1.JS中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。JS不要求变量总是持有与其初始值同类型的值。对变量执行typeof时，结果并不是该变量的类型，而是该变量持有的值的类型</div><div>2.已在作用域中声明但还没有赋值的变量，是undefined的。相反，还没有在作用域中声明过的变量，是undeclared的。typeof都会返回undefined。直接打印”undeclared”会产生ReferenceError错误</div><div>3.通过typeof的安全防范机制（阻止报错）来检查undeclared变量，if(typeof atob===“undefined”)、if(!window.atob)等</div><div><br/></div><div><b><font style="font-size: 24px;">二、值</font></b></div><div><b>A.数组</b></div><div>1.在JS中，数组可以容纳任何类型的值，可以是字符串、数字、对象（object），甚至是其他数组</div><div>2.使用delete运算符可以将单元从数组中删除，但是请注意，单元删除后，数组的length属性并不会发生变化</div><div>3.类数组，一些DOM元素，arguments对象（ES6已经废止），使用Array.prototype.slice.call(arguments)可以转化为真正的数组，ES6中的Array.from(arguments)也可以实现</div><div><br/></div><div><b>B.字符串</b></div><div>1.字符串和数组很相似</div><div>2.JS中字符串是不可变的，而数组是可变的。应该使用a.charAt(1)取下标位置的字符</div><div>3.字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始值上进行操作</div><div>4.简单粗暴的反转字符串方法，a.split(“”).reverse().join(“”)，转为数组，反转后再转回字符串</div><div><br/></div><div><b>C.数字</b></div><div>1.JS中只有一种数值类型：number，包括“整数”和带小数的十进制数。JS没有真正意义上的整数，“整数”就是没有小数的十进制数</div><div>2.数字的语法</div><div><ul><li>toExponential()输出指数格式，数字值可以使用Number.prototype中的方法<br/></li><li>toFixed():指定小数部分的显示位数<br/></li><li>toPrecision()：指定有效数位的显示位数<br/></li><li>对于.运算符需要注意，因为它是一个有效的数字字符，会被优先识别为数字常量的一部分，然后才是对象属性访问运算符，可以使用..或 .，如42..toFixed()或42 .toFixed()<br/></li></ul></div><div>3.较小的数值：二进制浮点数不精确，如0.1+0.2===0.3(false)，尽量使用整数</div><div>4.整数的安全范围：Number.MAX_VALUE是2^52-1，在ES6中被定义为Number.MAX_SAFE_INTEGER，最小整数为Number.MIN_SAFE_INTEGER</div><div>5.整数检测：ES6中使用Number.isInteger()方法，可以polyfill，typeof num == “number” &amp;&amp; num %1==0;</div><div><br/></div><div><b>D.特殊数值</b></div><div>1.不是值的值</div><div><ul><li>undefined：没有值(missing value)，从未赋值是一个标识符，可以被当作变量来使用和赋值（永远不要重新定义undefined）<br/></li><li>null：空值(empty value)，曾赋过值，但是目前没有值，不是标识符，不能当作变量来使用和赋值<br/></li><li>void：表达式void __没有返回值，并不改变表达式的结果，只是让表达式不返回值，在某些情况下很有用<br/></li></ul></div><div>2.特殊的数字</div><div><ul><li>NaN：意指“不是一个数字”，理解为“无效数值”“失败数值”或者“坏数值”更准确，NaN是一个警戒值(sentinel value，有特殊用途的常规值)，用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”，它和自身不相等，是唯一一个非自反（reflexive，即x===x不成立）的值，ES6中使用Number.isNaN()<br/></li><li>无穷数：JS使用有限数字表示法（finite numeric representation），所以和纯粹的数学运算不同，JS的运算结果有可能溢出，此时结果为Infinity或者-Infinity，计算结果一旦溢出为无穷数（infinity）就无法再得到有穷数，infinity/infinity==NaN，1/infinity==0<br/></li><li>零值：JS中有0和-0<br/></li></ul></div><div>3.特殊等式：ES6中加入了Object.is()方法判断两个值是否绝对相等，可以用来处理NaN或者-0，便能使用==和===时就尽量不要使用Object.is()</div><div><br/></div><div><b>E.值和引用</b></div><div>1.引用就像一种特殊的指针，是来指向变量的指针（别名），如果参数不声明为引用的话，参数值总是通过值复制的方式传递，即使对复杂的对象值也是如此。</div><div>2.JS中没有指针，引用的工作机制也不尽相同。</div><div>3.JS中引用指向的是值。如果一个值有10个引用，这些引用指向的都是同一个值，它们相互之间没有引用/指向关系。</div><div>4.JS对值和引用的赋值/传递在语法上没有区别，完全根据值的类型来决定。</div><div>5.简单值（即标题基本类型值，scalar primitive）总是通过值复制的方式来赋值/传递，包括null、undefined、字符串、数字、布尔和ES6中的symbol</div><div>6.复合值（compound value）—对象（包括数组和封装对象）和函数，总是通过引用复制的方式来赋值/传递</div><div>7.由于引用指向的是值本身而非变量，所以一个引用无法更改另一个引用的指向</div><div>8.请记住：我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定</div><div>9.如果通过值复制的方式来传递复合值（如数组），就需要为其创建一个香醇，这样传递的就不再是原始值；如果要将标量基本类型值传递到函数内并进行更改，就需要将该值封装到一个复合值（对象、数组等）中，然后通过引用复制的方式传递；</div><div><br/></div><div><b><font style="font-size: 24px;">三、原生函数</font></b></div><div><br/></div><div>1.通过构造函数创建出来的是封装了基本类型值的封装对象</div><div><br/></div><div><b>A.内部属性[[Class]]</b></div><div>1.所有typeof返回值为”object”的对象都包含一个内部属性[[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过Object.prototype.toString(..)来查看。如：Object.prototype.toString.call([1,2,3]);</div><div><br/></div><div><b>B.封装对象包装</b></div><div>1.封装对象（object wrapper）由于基本类型值没有.length和toString()这样的属性方法，需要通过封装对象才能访问，此时JS会自动为基本类型值包装（box或wrap）一个封装对象</div><div>2.一般情况下，我们不需要直接使用封装对象。最是让JS引擎自己决定什么时候应该使用封装对象。应该优先考虑使用42和”abc”这样的基本类型值，而非new String(“abc”)和new Number(42)</div><div>3.如果想要得到封装对象中的基本类型值，可以使用valueOf()函数，在需要用到封装对象中的基本类型值的地方会发生隐式拆封</div><div><br/></div><div><b>C.原生函数作为构造函数</b></div><div>1.尽量避免合适构造函数，除非十分必要，因为它们经常会产生意想不到的结果</div><div>2.Array(..)：使用new和不使用是一样的，如果只有一个参数会指定为数组长度，不同的浏览器开发控制台显示的结果也不尽相同。永远不要创建和使用空单元数组。</div><div>3.Object()、Function()和RegExp()：除非万不得己，否则尽量不要使用这三种方式来创建对象</div><div>4.Date()和Error()：比较有用</div><div><ul><li>Date()创建时必须带new，getTime()方法获得当前时间，ES5后可以使用Date.now()方法<br/></li><li>Error()带不带new都可以，可以获得当前运行栈的上下文，通常与throw一起使用，一般包含一个message属性<br/></li></ul></div><div>5.Symbol()：ES6中引入，具有唯一性的特殊值（并非绝对），用它来命名对象属性不容易导致重名，不能带new，主要用于私有或者特殊属性。是一种简单标量基本类型。</div><div>6.原生原型：如String.prototype.indexOf()等等。将原型作为默认值，Function.prototype是一个空函数，RegExp.prototype是一个“空”的正则表达式（任何匹配），Array.prototype是一个空数组。</div><div><br/></div><div><b><font style="font-size: 24px;">四、强制类型转换</font></b></div><div><b>A.值类型转换</b></div><div>1.将值从一种类型转换为另一种类型通常称为类型转换（type casting），这是显式的情况；隐式的情况称为强制类型转换（coercion）</div><div>2.JS中的强制类型转换总是返回标量基本类型值，如字符串、数字和布尔值，不会返回对象和函数；“封装”，就是为标量基本类型值封装一个相应类型的对象，但这并非严格意义上的强制类型转换</div><div>3.类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时（runtime）</div><div>4.在JS中通常将它们统称为强制类型转换。显式强制类型转换可以从代码中看出，而隐式强制类型转换则不那么明显</div><div>5.例子：</div><div>var a = 42;</div><div>var b = 42+””;//隐式</div><div>var c = String(a);//显式</div><div><br/></div><div><b>B.抽象值操作</b></div><div>1.ToString：负责处理非字符串到字符串的强制类型转换</div><div><ul><li>基本类型值的字符串化规则为：null转换为”null”，undefined转换为”undefined”，true转换为”true”。数字遵循能用规则，极小和极大的娄子使用指数形式；对普通对象来说，除非自定义了toString方法，否则返回内部属性[[Class]]的值；数组经过了重新定义，将所有单元字符串化以后再用”,”连接起来；<br/></li><li>JSON字符串化：JSON.stringify()对于不安全的JSON值，undefined、function、symbol会自动忽略，在数组中则返回null；对于包含循环引用的对象则会出错；对于含有非法JSON值的对象做字符串化，需要定义toJSON方法来返回一个安全的JSON值；toJSON()应该“返回一个能够被字符串化的安全的JSON值”，而不是“返回一个JSON字符串”；<br/></li><li>JSON.stringify()有一个可选参数replacer，可以是数组或函数，用来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除，和toJSON很像；如果是数组必须是一个字符串数组，如果是函数，会传递键和值两个参数；<br/></li><li>JSON.stringify()还有一个可选参数space，用来指定输出的缩进格式<br/></li><li>JSON.stringify()并不是强制类型转换，但它涉及ToString强制类型转换：字符串、数字、布尔值和null的JSON.stringify()规则与ToString基本相同；如果传递给JSON.stringify()的对象中定义了toJSON()方法，那么该方法会在字符串化前调用<br/></li></ul></div><div>2.ToNumber：将非数字值转化为数字</div><div><ul><li>true转换为1，false为0，undefined为NaN，null为0；对字符串基本遵循数字常量的相关规则，失败时返回NaN，对以0开头的十六进制数并不按十六进制而是十进制处理；<br/></li><li>对象（包括数组）会首先被转换为相应的基本类型值（调用ToPrimitive检查是否有valueOf()，如果没有就使用toString()，如果都不返回产生TypeError错误），再遵循上述元则强制转换为数字<br/></li></ul></div><div>4.ToBoolean</div><div><ul><li>JS中1和0与true和false并不是一回事<br/></li><li>假值：undefined、null、false、+0-0和NaN、””<br/></li><li>真值：可以理解为除假值以外的都是真值，对象默认全部为真值<br/></li><li>假值对象：一些浏览器不使用或者淘汰的对象，例如document.all，常用来判断是否是老的IE<br/></li></ul></div><div><br/></div><div><b>C.显式强制类型转换</b></div><div>1.字符串和数字之间的显式转换：通过String()和Number()来实现，不使用new，并不是创建封装对象；</div><div><ul><li>一元运算符+-被普遍认为是显式强制类型转换，也可以将日期转换成Unix时间戳<br/></li><li>~运算符：首先将值强制类型转换为32位数字，然后执行字位操作“非”（对每一个字位进行反转），~x大致等同于-(x+1)，~42=-(42+1)=-43，可以配合indexOf转换为真假值，如~a.indexOf()当返回-1时为假值，其他情况下都会是真值<br/></li></ul></div><div>2.显式解析数字字符串</div><div><ul><li>转换字符串：Number(…)不允许出现非数字字符，否则返回NaN<br/></li><li>解析字符串：parseInt(...)可以出现非数字，从左到右，如果遇到非数字就停止，仅针对字符串值。<br/></li><li>ES5之前需要指定parseInt()的第二个参数，用于指定进制类型否则首字为x则转换为16进制，首字为0则转换为8进制<br/></li><li>parseInt(…)会先将参数强制类型转换为字符串再进行解析<br/></li></ul></div><div>3.显式转换为布尔值：使用Boolean()不用new，但最常用的是一元运算符!!</div><div><br/></div><div><b>D.隐式强制类型转换</b></div><div>1.字符串和数字之间的隐式强制类型转换</div><div><ul><li>根据ES5规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用ToPrimitive抽象操作，该抽象操作再调用[[DefaultValue]]，以数字作为上下文<br/></li><li>在定制valueOf()和toString()时需要非常小心，a+””这种会先调用valueOf()再调用toString()，而String()则直接调用toString()结果可能会不同<br/></li></ul></div><div>2.隐式强制类型转换为布尔</div><div><ul><li>if(..)语句中的条件表达式<br/></li><li>for(..;..;..)语句中的条件判断表达式（第二个）<br/></li><li>while(..)和do..while(..)循环中的条件判断表达式<br/></li><li>?:中的条件判断表达式<br/></li><li>逻辑关系运算符||（逻辑或）和&amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）<br/></li></ul></div><div>3.||和&amp;&amp;</div><div><ul><li>ES5规范：&amp;&amp;和||运算符的返回值并不一定是布尔类型，而是两个操作数其中一个的值。<br/></li><li>||和&amp;&amp;首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行ToBoolean强制类型转换，然后再执行条件判断<br/></li></ul></div><div>4.符号的强制类型转换</div><div><ul><li>ES6中引入的符号类型Symbol，允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。<br/></li><li>符号不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式都是true）<br/></li></ul></div><div><br/></div><div><b>E.宽松相等和严格相等</b></div><div>1.==允许在相等比较中进行强制类型转换，而===不允许</div><div>2.抽象相等</div><div><ul><li>ES5规范“抽象相等比较算法”定义了==运算符的行为。如果两个值的类型相同，就仅比较它们是否相等。对象（包括函数和数组）两个对象指向同一个值时即视为相等，不发生强制类型转换。==和===在比较对象上时是相同的。==在比较两个不同类型的值时会发生隐式强制类型转换，会将其中一或两者转换为相同的类型后再进行比较。注意：NaN!=NaN、+0==-0<br/></li><li>字符串和数字之间的相等比较：字符串被强制转换为数字<br/></li><li>其他类型和布尔类型之间的相等比较：boolean类型会执行ToNumber，所以”42”==true（”42”==1），尽量避免==ture和===ture，使用if(a)、if(!!a)、if(Boolean(a))<br/></li><li>null和undefined之间的相等比较：在==中，null和undefined是一样的，它们之间的强制类型转换是安全可靠的，if(a==null)，null和undefined是成立的，但不包括0，false和””<br/></li><li>对象和非对象之间的相等比较：会调用对象的ToPromitive抽象操作进行强制类型转换<br/></li></ul></div><div>3.比较少见的情况</div><div><ul><li>返回其他数字：Number.prototype.valueOf = function(){return 3;};new Number(2)==3<br/></li><li>假值的相等比较：”0”==false、false==0、false==“”、false==[]、”” == 0、””==[]、==[]<br/></li><li>极端情况：[] == ![]([]==false)，0==“\n”(ToNumber会强制转换为0)<br/></li></ul></div><div>4.安全运用隐式强制类型转换</div><div><ul><li>如果两边的值中有true或false，千万不要使用==<br/></li><li>如果两边的值中有[]、””或者0，尽量不要使用==<br/></li><li>解决：上述情况使用===或者显式转换<br/></li><li>typeof操作总是返回七个类型字符串，比较安全<br/></li></ul></div><div><br/></div><div><b>F.抽象关系比较</b></div><div>1.a&lt;b比较双方首先调用ToPrimitive，如果结果出现非字符串，就根据ToNumber规则强制转换为数字，如果都是字符串，则按照字母顺序来比较</div><div>2.JS中的&gt;=和&lt;=实际上是“不大于”和“不小于的意思”，即a&gt;=b === !（b&gt;a），关系比较没有严格模式，因此要避免发生隐式强制类型转换</div><div><br/></div><div><b><font style="font-size: 24px;">五、语法</font></b></div><div><b>A.语句和表达式</b></div><div>1.语句相当于句子，表达式相当于短语，运算符相当于标点符号和连接词</div><div>2.语句的结果值：获得结果值最直接的方法是在浏览器开发控制台中输入语句，默认情况下控制台会显示所执行的最后一条语句的结果值。var的结果值就是undefined，所以var a =42的结果值是undefined。</div><div><ul><li>代码块{}的结果值是其最后一个语句/表达式的结果，如同一个隐式的返回，即返回最后一个语句的结果值，语法不允许我们获得语句的结果值并将其赋值给另一个变量，可以使用eval()来获取 ，ES7规范可以使用do{}表达式执行一个代码块<br/></li></ul></div><div>3.表达式的副作用：函数调用，++、—运算符等</div><div><ul><li>可以使用,语句系统逗号运算符（statement-series comma operator）将多个独立的表达式串联成一个语句b = (a++,a)<br/></li><li>链式赋值，如var a=b=42，如果b没有在作用域中象var这样声明过，则不会对变量b进行声明<br/></li></ul></div><div>4.上下文规则</div><div><ul><li>标签跳转：foo:for(){for(){if(){continue foo;//直接跳最外层}}}，可以替代其他语言的goto语句，break可以用于非循环代码块<br/></li><li>JSON是JS语言的一个真子集，但是JSON本身并不是合法的JS语法。JSON-P（将JSON数据封装为函数调用，比如foo({“a”:42})）通过将JSON数据传递给函数来实现对其的访问，能将JSON转换为合法的JS语法<br/></li><li>代码块：[]+{}=“[object Object]”;{}+[]=0；因为{}被当作一个独立的代码块（不执行任何操作），然后再+[]（显式转换为0）<br/></li><li>对象解构：在ES6中可以对象解构，如var {a,b} = getData();<br/></li><li>JS中没有else if，实际上是if(){}else{if(){}else{}}这样<br/></li></ul></div><div><br/></div><div><b>B.运算符优先级</b></div><div>1.短路：对&amp;&amp;和||来说，如果从左边的操作数能够得出结果，就可以忽略右边的操作数。这种现象称为短路（即执行最短路径）</div><div>2.&amp;&amp;&gt;||&gt;?:</div><div>3.关联：一般来说运算符的关联（associativity）是从左到右（JS的默认执行顺序），?:是右关联顺序</div><div>4.在编写程序时结合起来，即要依赖运算符优先级/关联规则，也要适当使用()自行控制方式</div><div><br/></div><div><b>C.自动分号</b></div><div>1.自动分号插入（Automatic Semicolon Insertion,ASI）：如果解析器发现代码可能因为缺失分号而导致错误，那么它就会自动补上分号。并且，只有在代码行末尾与换行符之间除了空格和注释之外没有别的内容时，它才会这样做。<br/>2.建议在所有需要的地方加上分号，将对ASI的依赖降到最低<br/></div><div><br/></div><div><b>D.错误</b></div><div>1.运行时错误：TypeError、ReferenceError、SyntaxError等</div><div>2.编译阶段发现的代码错误叫作“早期错误”（early error）。另外，语法正确但不符合语法规则的情况也存在。</div><div>3.TDZ：ES6定义的（Temporal Dead Zone，暂时性死区），指的是由于代码中的变量还没有初始化而不能被引用的情况</div><div><br/></div><div><b>E.函数参数</b></div><div><div>1.在ES6中，如果参数被省略或者值为undefined，则取该参数的默认值，函数不带参数时、传递undefined时，arguments数组的内容会不同</div><div>2.在严格模式中没有建立关联这一说，因此，在开发中不要依赖这种关联机制，实际上，它是JS语言引擎底层实现的一个抽象泄漏（leaky abstraction），并不是语言本身的特性。</div><div>3.arguments数组已经被废止，但并非一无是片，注意不要同时访问命名参数和其对应的arguments数组单元</div><div><br/></div><div><b>F.try..finally</b></div><div>1.函数try中出现return也是先返回finally的内容，先执行try中的return并将函数的返回值设置为return的值，接着执行finally然后函数执行完毕</div><div>2.finally中的return会覆盖try和catch中return 的返回值</div><div><br/></div><div><b><font style="font-size: 24px;">附录A.混合环境JavaScript</font></b></div><div><b>A.Annex B(ECMAScript)</b></div><div>1.Annex B，介绍了由于浏览器兼容性问题导致的与官方规范的差异。这些差异只存在于浏览器中，如果代码只在浏览器中运行，就不会发现任何差异。否则（如果代码也在Node.js、Rhino等环境中运行），或者你也不确定的时候，就需要小心对待</div><div><ul><li>在非严格模式中允许八进制数值常量存在，如0123<br/></li><li>window.escape()和window.unescape()让你能够转义和回转带有%分隔符的十六进制字符串<br/></li><li>String.prototype.substr和String.prototype.substring十分相似，除了前者的第二个参数是结束位置索引，后者的第二个参数是长度<br/></li></ul></div><div>2.Web ECMAScript</div><div><ul><li>&lt;!—和—&gt;是合法的单行注释分隔符<br/></li><li>String.prototype中返回HTML格式字符串的附加方法：anchor()、big()、blink()、bold()、fixed()、fontcolor()、fontsize()、italics()、link()、small()、strike()和sub()<br/></li><li>RegExp扩展：RegExp.$1 .. RegExp.$9（匹配级）和RegExp.lastMatch/RegExp[“$&amp;”]（最近匹配）<br/></li><li>Function.prototype附加方法：Function.prototype.arguments（别名为arguments对象）和Function.caller（别名为arguments.caller）（均已废止，尽量不要使用）<br/></li></ul></div><div><br/></div><div><b>B.宿主对象</b></div><div><ul><li>注意的宿主对象的行为差异：<br/></li><li>无法访问正常的object内建方法，如toString()<br/></li><li>无法写覆盖<br/></li><li>包含一些预定义的只读属性<br/></li><li>包含无法将this重载为其他对象的方法<br/></li><li>其他....<br/></li></ul></div><div><br/></div><div><b>C.全局DOM变量</b></div><div>1.声明一个全局变量的结果不仅仅是创建一个全局变量，而且还会在global对象（在浏览器中为window）付了款一个同名属性</div><div>2.由于浏览器演进的历史遗留问题，在创建带有id属性的DOM元素时也会创建同名的全局变量</div><div><br/></div><div><b>D.原生原型</b></div><div>1.不要扩展原生方法，除非你确信代码在运行环境中不会有冲突</div><div>2.在扩展原生方法时需要加入判断条件（因为你可能无意中覆盖了原来的方法）</div><div>3.shim/polyfill：如果规范中已经定义了prototype，并且功能和你的实现类似，那就没有什么问题，这种情况一般称为polyfill（或者shim），对于将来可能成为标准的功能，按照大部分人赞同的方式来预先实现能和将来的标准兼容的polyfill，称为prollyfill（probably fill）</div><div><br/></div><div><b>E.&lt;script&gt;</b></div><div>1.多个&lt;script&gt;是独立的，但他们共享global（在浏览器是window），这些文件中的代码在共享的命名空间中运行，并相互交互</div><div>2.如果script中的代码发生错误，它会像独立的JS程序那样停止，但是后续的script中的代码（仍然共享global）依然会接着运行，不会受影响</div><div>3.可以使用代码来动态创建script，将其加入到页面的DOM中，效果是一样的，内联代码中不可以出现&lt;/script&gt;字符串，应该使用”&lt;/sc”+”ript&gt;”</div><div>4.需要注意外联script标签的charset，内联代码中的HTML或XHTML注释已废止</div><div><br/></div><div><b>F.保留字</b></div><div>1.不要用作变量名、对象常量中的属性名称或者键值（目前已没有这个限制）</div><div>2.四类：“关键字”、“预留关键字”、null常量和true/false布尔常量</div><div><br/></div><div><b>G.实现中的限制</b></div><div><ul><li>字符串常量中允许的最大字符数（并非只是针对字符串值）<br/></li><li>可以作为参数传递到函数中的数据大小（也称为栈大小，以字节为单位）<br/></li><li>函数声明中的参数个数<br/></li><li>未经优化的调用栈（例如递归）的最大层数，即函数调用链的最大长度<br/></li><li>JS程序以阻塞方式在浏览器中运行的最长时间（秒）<br/></li><li>变量名的最大长度<br/></li></ul></div><div><br/></div></div><div><b><font style="font-size: 24px;">六、异步：现在与将来</font></b></div><div><br/></div><div>程序现在运行的部分和将来运行的部分之间的关系就是异步编程的核心</div><div><br/></div><div><b>A.分块的程序</b></div><div>1.最常见的块单位是函数。从现在到将来的“等待”，最简单的方法（但绝不是唯一的，甚至也不是最好的）是使用一个通常称为回调函数的函数</div><div>2.任何时候，只要把一段代码包装成一个函数，并指定它在响应某个事件（定时器、鼠标点击、Ajax响应等）时执行，你就是在代码中创建了一个将来执行的块，也由此在这个程序中引入了异步机制</div><div>3.在某些条件下，某些浏览器的console.log()并不会把传入的内容立即输出。原因是，在许多程序（不只是JS）中，I/O是非常低带的阻塞部分。所以（从页面和UI角度来说）浏览器在后台异步处理控制台I/O能够提高性能。</div><div><br/></div><div><b>B.事件循环</b></div><div>1.所有环境都有一个共同“点”（thread，也指线程），即它们都提供了一种机制来处理程序 中多个块的执行，且执行每块时调用JS引擎，这种机制被称为事件循环。换句话说，JS引擎本身并没有时间的概念，只是一个按需执行JS做生意代码片段的环境。“事件”（JS代码执行）调度总是由包含它的环境进行。</div><div>2.程序通常被分成了很多小块，在事件循环队列中一个接一个地执行。严格地说，和你的程序不直接相关的其他事件也可能会插入到队列中</div><div>3.setTimeout()并没有把回调函数拍在事件循环队列中，但是设置了一个定时器，当到时后，环境会把你的回调函数放到事件循环中去，所以setTimeout()的精度可能不高</div><div><br/></div><div><b>C.并行线程</b></div><div>1.异步是关于现在和将来的时间间隙，而并行是关于能够同时发生的事情。</div><div>2.并行计算最觉的工具就是进程和线程。进程和线程独立运行，并可能同时运行：在不同的处理器，甚至不同的计算机上，但多个线程能够共享单个进程的内存</div><div>3.事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存</div><div>4.JS从不跨线程共享数据</div><div>5.由于JS的单线程特性，函数中的代码具有原子性，一个函数开始运行，它的所有代码都会在另一个函数的做生意代码运行前完成，或者相反，这称为完事运行（run-to-completion）特性</div><div>6.同一段代码有两个可能输出意味着存在不确定性，这种不确定性是在函数（事件）顺序级别上，而不是多线程情况下的语句顺序级别，这种称为竞态条件（race condition）</div><div><br/></div><div><b>D.并发</b></div><div>1.两个“进程”同时执行就出现了并发，不管组成它们的单个运算是否并行执行（在独立的处理器或处理器核心上同时运行）。可以把并发看作“进程”级（或者任务级）的并行，与运算级的并行（不同处理器上的线程）相对</div><div>2.单线程事件循环是并发的一种形式</div><div>3.非交互：两个或多个“进程”在同一个程序内并发地交替运行它们的步骤/事件时，如果这些任务彼此不相关，就不一定需要交线。如果进程间没有相互影响的话，不确定性是完全可以接受的</div><div>4.交互</div><div><ul><li>针对修改调用相同变量可以协调交互顺序来处理竞态条件<br/></li><li>针对调用相同方法可以设置门(gate)，当所变量或条件都准备好后再打开门调用方法<br/></li><li>当修改同一个变量时还可以使用门闩，“只有第一个取胜”，判断变量是否已被赋值这种<br/></li></ul></div><div>5.协作：目标是取到一个长期运行的“进程”，并将其分割成多个步骤或多批任务，使得其他并发“进程”有机会将自己的运算插入到事件循环队列中交替运行，例如使用setTimeout()分割耗时操作</div><div><br/></div><div><b>E.任务</b></div><div>1.任务队列（job queue）：ES6新增，它是挂在事件特殊队列每个tick之后的一个队列。在事件循环的每个tick中，可能出现 的异步动作不会导致一个完事的新带伤添加到事件循环队列中，而会在当前 tick的任务队列末尾添加一个项目（任务）</div><div>2.与setTimeout(..0)hack的思路类似，但是其实现方式的定义更加良好，对顺序的保证性更强：尽可能早的将来</div><div><br/></div><div><b>F.语句顺序</b></div><div>1.代码中语句的顺序和JS引擎执行语句的顺序并不一定要一致</div><div><br/></div><div><b><font style="font-size: 24px;">七、回调</font></b></div><div><b>A. continuation</b></div><div>1.回调函数包裹或者说封装了程序的延续（continuation）</div><div><br/></div><div><b>B.顺序的大脑</b></div><div>1.代码（通过回调）表达异步的方式并不能很好地映射到同步的大脑计划行为</div><div>2.三个函数嵌套在一起构成的链，其中每个函数代表异步序列（任务，“进程”）中的一个步骤。这种代码被称为回调地狱（callback hell）或毁灭多字塔（pyramid of domm）</div><div><br/></div><div><b>C.信任问题</b></div><div>1.控制反转（inversion of control），也就是把自己程序一部分的执行控制交给某个第三方。在你的代码和第三方工具（一组你希望有人维护的东西）之间有一份并没有明确表达的契约</div><div><br/></div><div><b><font style="font-size: 24px;">八、Promise</font></b></div><div><b>A.什么是Promise</b></div><div>1.从外部看，Promise封装了依赖于时间的状态——等待底层值的完成或拒绝，所以Promise本身是与时间无关的。因此，Promise可以按照可预测的方式组成（组合），而不用关心时序或底层结构</div><div>2.一旦Promise决议，它就永远保持在这个状态。此时它就成为了不变值（immutable value），可以根据需求多次查看</div><div>3.Promise决议后就是外部不可变的值，我们可以安全地把这个值传递给第三方，并砍它不会被有意无意地修改。特别是对于多方查看同一个Promise决议的情况，尤其如此。一方不可能影响到另一方对Promise决议的观察结果。</div><div>4.对回调模式的反转实际上是对反转的反转，或者称为反控制反转</div><div>5.new Promise(function(){});模式通常称为revealing constructor。传入的函数会立即执行（不会像then()中的回调一样异步延迟），它有两个参数，一个标识完成，一个标识拒绝</div><div><br/></div><div><b>B.具有then方法的鸭子类型</b></div><div>1.识别Promise（或者行为类似于Promise的东西）就是定义某种称为thenable的东西，将其定义为任何具有then()方法的对象和函数。</div><div>2.根据一个值的形态（具有哪些属性）对这个值的类型做出一些假定。这种类型检查（type check）一般用术语鸭子类型（duck typing）来表示——“如果它看起来像只鸭子，叫起来像只鸭子，那它一定就是只鸭子”</div><div>3.对thenable的鸭子类型检测：if(p!=null&amp;&amp;(typeof p ===“object” || typeof p === “function”)&amp;&amp;typeof p.then ===“function”)</div><div>4.注意这种检测可能会产生误判</div><div><br/></div><div><b>C.Promise信任问题</b></div><div>1.调用过早：Promise即使是立即完成的Promise也无法被同步观察到，也就是说，对一个Promise调用then()的时候，即使这个Promise已经决议，提供给then()的回调也总会被异步调用</div><div>2.调用过晚：一个promise决议后，这个Promise上所有的通过then()注册的回调都会在下一个异步时机点依次被立即调用。这些回调中的做任意一个都无法影响或延误对其他回调的调用</div><div><ul><li>Promise调度技巧：永远都不应该依赖于不同Promise间回调的顺序和调度。实际上，好的编码实践方案根本不会让多个回调的顺序有丝毫影响，可能的话就要避免<br/></li></ul></div><div>3.回调未调用：没有任何东西（甚至JS错误）能阻止Promise向你通知它的决议（如果它决议了的话）。如果你对一个Promise注册了一个完成回调和一个拒绝回调，那么Promise在决议时总是会调用其中的一个</div><div><ul><li>如果Promise本身永远不被决议，Promise使用了一种称为竞态的高级抽象机制<br/></li></ul></div><div>4.调用次数过少或过多：Promise定义的方式使得它只能被决议一次。如果出于某种原因，Promise创建代码试图调用resolve()或reject()多次，或者试图两者都调用，那么这个Promise将只会接受第一次决议，并默默地忽略任何后续调用。</div><div><ul><li>任何通过then()注册的（每个）回调只会被调用一次，如果把同一个回调注册了不止一次，那它被调用的次数就会和注册次数相同。<br/></li></ul></div><div>5.未能传递参数/环境值：如果你没有用任何值显式决议，那么这个值就是undefined，这是JS常见的处理方式。但不管这个值是什么，无论当前或未来，它都会传给所有注册的（且适当的完成或拒绝）回调</div><div><ul><li>如果使用多个参数调用resovle()或者reject()，第一个参数之后的所有参数都会被默默忽略。<br/></li></ul></div><div>6.吞掉错误或异常：如果拒绝一个Promise并给出一个理由（也就是一个出错消息），这个值就会被传给拒绝回调</div><div><ul><li>如果在Promise的创建过程中或在查看其决议结果过程中的任何时间点上出现了一个JS异常错误，比如一个TypeError或ReferenceError，那这个异常就会被捕捉，并且会使这个Promise被拒绝<br/></li><li>Promise甚至把JS异常也变成了异步行为，进而极大降低了竞态条件出现的可能<br/></li></ul></div><div>7.是可以信任的Promise吗：</div><div><ul><li>Promise并没有完全摆脱回调，它们只是改变了传递回调的位置<br/></li><li>如果向Promise.resolve()传递一个非Promise，非thenable的立即值，就会得到一个用这个值填充的promise<br/></li><li>Promise.resolve()可以接受任何tenable，将其解封为它的非thenable值。从Promise.resolve()得到的是一个真正的Promise，是一个可以信任的值。<br/></li></ul></div><div>8.建立信任：Promise这种模式通过可信任的语义把回调作为参数传递，使得这种行为更可选更合理。通过把回调的控制反转反转回来，我们把控制权放在了一个可信任的系统（Promise）中，这种系统的设计目的就是为了使异步编码更清晰</div><div><br/></div><div><b>D.链式流</b></div><div>1.Promise并不只是一个单步执行this-then-that操作的机制。当然，那是构成部件，但是我们可以把多个Promise连接到一起以表示一系列异步步骤，关键在于以下两个Promise固有行为特性：</div><div><ul><li>每次你对Promise调用then()，它都会创建并返回一个新的Promise，我们可以将其链接起来<br/></li><li>不管从then()调用的完成回调（第一个参数）返回的值是什么，它都会被自动设置为被链接Promise（第一点中的）的完成<br/></li><li>如果你调用promise的then()，并且只传入一个完成处理函数，一个默认拒绝处理函数就会顶替上来<br/></li></ul></div><div>2.链式流程控制可行的Promise固有特性：</div><div><ul><li>调用Promise的then()会自动创建一个新的Promise从调用返回<br/></li><li>在完成或拒绝处理函数内部，如果返回一个值或抛出一个异常，新返回的（可链接的）Promise就相应地决议<br/></li><li>如果完成或拒绝处理函数返回一个Promise，它将会被展开，这样一来，不管它的决议值是什么，都会成为当前then()返回的链接 Promise的决议值<br/></li></ul></div><div>3.对链式流程控制最精确的看法是把它看作Promise组合到一起的一个附加益处，而不是主要目的。</div><div>4.术语：决议、完成以及拒绝</div><div>var p = new Promise( function(X,Y){</div><div><span>    //X()用于完成</span><br/></div><div><span><span>    //Y()用于拒绝</span><br/></span></div><div>} );</div><div><ul><li>构造器建议选用：resolve()和rejected()<br/></li><li>.then()建议选用：fulfilled()和rejected()<br/></li></ul></div><div><br/></div><div><b>E.错误处理</b></div><div>1.try……catch只能是同步的，无法用于异步代码模式</div><div>2.Promise没有采用流行的error-first回调设计风格，而是使用了分离回调（split-callback）风格。一个回调用于完成情况，一个回调用于拒绝情况</div><div>3.处理未捕获的情况：</div><div><ul><li>一种常见的看法是：Promise应该添加一个done()函数，从本质上标识Promise链的结束。done()不会创建和返回Promise，所以传递给done()的回调显然不会报告一个并不存在的链接Promise的问题<br/></li><li>浏览器有一个特有的功能：它们 可以跟踪并了解所有对象被丢弃以及被垃圾回收的时机。<br/></li></ul></div><div>4.成功的坑：</div><div><ul><li>默认情况下，Promise在下一个任务或时间循环tick上（向开发者终端）报告所有拒绝，如果在这个时间点上该Promise上还没有注册错误处理函数<br/></li><li>如果想要一个被拒绝的Promise在查看之前的某个家附近姐段内保持被拒绝状态，可以调用defer()，这个函数优先级高于该Promise的自动错误报告<br/></li></ul></div><div><br/></div><div><b>F.Promise模式</b></div><div>1.Promise.all([..])</div><div><ul><li>在异步序列中（Promise链），任意时刻都只能有一个异步任务正在执行——步骤2只能在步骤1之后，步骤3只能在步骤2之后<br/></li><li>在经典的编程术语中，门（gate）是这样一种机制要等待两个或更多并行/并发的任务都完成才能继续。在Promise API中，这种模式为all([])<br/></li></ul></div><div>2.Promise.race([..])</div><div><ul><li>“只有第一个到达终点的才算胜利”，一旦任何一个Promise决议为完成，Promise.race([..])就会完成，一旦有任何一个Promise决议为拒绝，它就会拒绝<br/></li></ul></div><div>3.all()和race()的变体：none()，any()，first()，last()</div><div><br/></div><div><b>G.Promise API概述</b></div><div>1.new Promise()构造器</div><div>2.Promise.resolve()和Promise.reject()</div><div>3.then()和catch()：决议后立即全调用，then()两个参数，第一个用于完成回调，第二个用于拒绝回调；catch()只接受一个拒绝回调作为参数，并自动替换默认完成回调，等价于then(null,……);</div><div>4.Promise.all([])和Promise.race([])</div><div><br/></div><div><b>H.Promise局限性</b></div><div>1.顺序错误处理</div><div><ul><li>如果构建了一个没有错误处理函数的Promise链，链中任何地方的任何错误都会在链中一直传播下去，直到被查看。<br/></li><li>可以注册一个catch，对于链中任何位置出现的任何错误，这个处理函数都会得到通知<br/></li></ul></div><div>2.单一值</div><div><ul><li>一般的建议是构造一个值封装<br/></li><li>可以使用Promise.all<br/></li><li>利用ES6的解构<br/></li></ul></div><div>3.无法取消的Promise：一旦创建了一个Promise并为其注册了完成和/或拒绝处理函数，如果出现某种情况使得这个任务悬而未决的话，也没有办法从外部停止它的进程</div><div><br/></div><div><i>/你不知道的JS中/7.html</i></div><div><br/></div><div><b><font style="font-size: 24px;">九、生成器</font></b></div><div><b>A.打破完整运行</b></div><div>1.生成器是一类特殊的函数，可以一次或多次启动和停止，并不一定非得要完成。</div><div>2.迭代消息传递：消息是双向传递的——yield..作为一个表达式可以发出消息响应next(..)调用，next(..)也可以向暂停的yield表达式发送值</div><div><br/></div><div><b>B.异步迭代生成器</b></div><div>1.可以在生成器内部有了看似完全同步的代码（调用Ajax时）</div><div>2.可以同步错误处理</div><div><br/></div><div><font style="font-style: italic;">/你不知道的JS中/9.js</font><br/></div><div><br/></div><div><b><font style="font-size: 24px;">十、程序性能</font></b></div><div><b>A.Web Worker</b></div><div>1.通常应用于：处理密集型数学计算、大数据集排序、数据处理（压缩、音频分析、图像处理等）、高流量网络通信</div><div><br/></div><div><b>B.SIMD</b></div><div>1.单指令多数据（SIMD）是一种数据并行（data parallelism）方式，与Web Worker的任务并行（task parallelism）相对。</div><div><br/></div><div><b><font style="font-size: 24px;">十一、性能测试与调优</font></b></div><div><b>A.性能测试</b></div><div>1.Benchmark.js</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 