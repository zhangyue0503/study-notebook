<html>
<head>
  <title>前端页面性能指标数据计算方法</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="2140"/>
<h1>前端页面性能指标数据计算方法</h1>

<div><span><div><span style="-en-paragraph:true;">上面我们梳理了页面性能和体验相关的数据指标，聪明的你可能会想到怎么获取这些指标对应的数据呢？别着急，事实上</span><a href="https://www.w3.org/webperf/" style="-en-paragraph:true;">Web Performance Working Group</a><span style="-en-paragraph:true;"> 制定了很多相关的接口标准，部分已经实现，部分还在草案阶段。我们主要用到Performance这个接口，它提供的数据基本包含了我们需要的各个指标。
</span></div><h1>指标数据采集API
</h1><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">Performance接口允许访问当前页面性能相关的信息。它是</span><a href="https://www.w3.org/TR/hr-time-2/" style="-en-paragraph:true;">High Resolution Time API</a><span style="-en-paragraph:true;">的一部分。但是它被</span><a href="https://www.w3.org/TR/performance-timeline-2/" style="-en-paragraph:true;">Performance Timeline API</a><span style="-en-paragraph:true;">, the </span><a href="https://www.w3.org/TR/navigation-timing/#introduction" style="-en-paragraph:true;">Navigation Timing API</a><span style="-en-paragraph:true;">, the </span><a href="https://www.w3.org/TR/user-timing/#introduction" style="-en-paragraph:true;">User Timing API</a><span style="-en-paragraph:true;">, and the </span><a href="https://www.w3.org/TR/resource-timing/" style="-en-paragraph:true;">Resource Timing API</a><span style="-en-paragraph:true;"> 扩展增强了，实际上Performance的主要功能都是由这几个API提供的。我们分别介绍下：
</span></div><h2><a href="https://www.w3.org/TR/hr-time-2/">High Resolution Time API</a></h2><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这里必须要介绍下 </span><a href="https://www.w3.org/TR/hr-time-2/" style="-en-paragraph:true;">High Resolution Time API</a><span style="-en-paragraph:true;">，主要定义了 </span><a href="https://www.w3.org/TR/hr-time-2/#sec-domhighrestimestamp" style="-en-paragraph:true;">DOMHighResTimeStamp</a><span style="-en-paragraph:true;"> 数据类型，这是一个高精度时间戳类型，相对于 </span><a href="https://www.w3.org/TR/hr-time-2/#dfn-time-origin" style="-en-paragraph:true;">time origin</a><span style="-en-paragraph:true;">, </span><a href="https://www.w3.org/TR/hr-time-2/#dfn-global-monotonic-clock" style="-en-paragraph:true;">global monotonic clock</a><span style="-en-paragraph:true;">的时间。或者是两个高精度时间戳的时间差值。它返回的一个浮点数的毫秒值，由于是浮点数，所以小数部分就能得到千分之一毫秒的精度。
</span></div><ul><li><div>performance.now()</div></li><li><div>973141.500000027</div></li></ul><h2><a href="https://www.w3.org/TR/navigation-timing/#introduction">Navigation Timing API</a></h2><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">在</span><a href="https://www.w3.org/TR/navigation-timing/#sec-window.performance-attribute" style="-en-paragraph:true;">Navigation Timing</a><span style="-en-paragraph:true;">标准中介绍到这个API主要包含两个接口：</span><a href="https://www.w3.org/TR/navigation-timing/#sec-navigation-timing-interface" style="-en-paragraph:true;">PerformanceTiming</a><span style="-en-paragraph:true;">和</span><a href="https://www.w3.org/TR/navigation-timing/#sec-navigation-info-interface" style="-en-paragraph:true;">PerformanceNavigation</a><span style="-en-paragraph:true;">，这两个接口由浏览器进行实现和维护，当浏览器创建页面的时候就会把接口定义的相关数据挂载到window.performance.timing和window.performance.navigation这两个属性上。可以参考下一节 </span><span style="font-weight: bold;-en-paragraph:true;">加载链路优化</span><span style="-en-paragraph:true;"> 这部分内容。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">其中</span><a href="https://www.w3.org/TR/navigation-timing/#sec-navigation-timing-interface" style="-en-paragraph:true;">PerformanceTiming</a><span style="-en-paragraph:true;">的时间点属性有这些：
</span></div><ul><li><div>interface PerformanceTiming {</div></li><li><div>readonly attribute unsigned long long navigationStart;</div></li><li><div>readonly attribute unsigned long long unloadEventStart;</div></li><li><div>readonly attribute unsigned long long unloadEventEnd;</div></li><li><div>readonly attribute unsigned long long redirectStart;</div></li><li><div>readonly attribute unsigned long long redirectEnd;</div></li><li><div>readonly attribute unsigned long long fetchStart;</div></li><li><div>readonly attribute unsigned long long domainLookupStart;</div></li><li><div>readonly attribute unsigned long long domainLookupEnd;</div></li><li><div>readonly attribute unsigned long long connectStart;</div></li><li><div>readonly attribute unsigned long long connectEnd;</div></li><li><div>readonly attribute unsigned long long secureConnectionStart;</div></li><li><div>readonly attribute unsigned long long requestStart;</div></li><li><div>readonly attribute unsigned long long responseStart;</div></li><li><div>readonly attribute unsigned long long responseEnd;</div></li><li><div>readonly attribute unsigned long long domLoading;</div></li><li><div>readonly attribute unsigned long long domInteractive;</div></li><li><div>readonly attribute unsigned long long domContentLoadedEventStart;</div></li><li><div>readonly attribute unsigned long long domContentLoadedEventEnd;</div></li><li><div>readonly attribute unsigned long long domComplete;</div></li><li><div>readonly attribute unsigned long long loadEventStart;</div></li><li><div>readonly attribute unsigned long long loadEventEnd;</div></li><li><div>};</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">简单介绍几个有用的时间点：
</span></div><ul><li><div>startTime：有些浏览器实现为<a href="https://link.juejin.im/?target=https%3A%2F%2Fmsdn.microsoft.com%2Fen-us%2Flibrary%2Fff974724(v%3Dvs.85).aspx">navigationStart</a>，代表浏览器开始unload前一个页面文档的开始时间节点。比如我们当前正在浏览<a href="http://baidu.com">baidu.com</a>，在地址栏输入<a href="http://google.com">google.com</a>并回车，浏览器的执行动作依次为：<span style="font-weight: bold;">unload当前文档（即<a href="http://baidu.com">baidu.com</a>）-&gt;请求下一文档（即<a href="http://google.com">google.com</a>）</span>。navigationStart的值便是触发unload当前文档的时间节点。</div><blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">如果当前文档为空，则navigationStart的值等于fetchStart。
</span></div></blockquote></li><li><div>redirectStart和redirectEnd：如果页面是由redirect而来，则redirectStart和redirectEnd分别代表redirect开始和结束的时间节点；</div></li><li><div>unloadEventStart和unloadEventEnd：如果前一个文档和请求的文档是同一个域的，则unloadEventStart和unloadEventEnd分别代表浏览器unload前一个文档的开始和结束时间节点。否则两者都等于0；</div></li><li><div>fetchStart是指在浏览器发起任何请求之前的时间值。在fetchStart和domainLookupStart之间，浏览器会检查当前文档的缓存APP Cache。</div></li></ul><blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><span style="color: #ff0000;-en-paragraph:true;">这个App Cache主要用来提供离线浏览网页的功能，不做在新的浏览器标准中已经移除了，不推荐使用，新的标准推荐采用Service Worker方案来处理离线数据缓存</span><span style="-en-paragraph:true;">，参考</span><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Using_the_application_cache" style="-en-paragraph:true;">MDN</a><span style="-en-paragraph:true;">；
</span></div></blockquote><ul><li><div>domainLookupStart和domainLookupEnd分别代表DNS查询的开始和结束时间节点。如果浏览器没有进行DNS查询（比如使用了DNS cache），则两者的值都等于fetchStart；</div></li><li><div>connectStart和connectEnd分别代表TCP建立连接和连接成功的时间节点。如果浏览器没有进行TCP连接（比如使用持久化连接webscoket），则两者都等于domainLookupEnd；</div></li><li><div>secureConnectionStart：可选。如果页面使用HTTPS，它的值是安全连接握手之前的时刻。如果该属性不可用，则返回undefined。如果该属性可用，但没有使用HTTPS，则返回0；</div></li><li><div>requestStart代表浏览器发起请求的时间节点，请求的方式可以是请求服务器、缓存、本地资源等；</div></li><li><div>responseStart和responseEnd分别代表浏览器收到从服务器端（或缓存、本地资源）响应回的第一个字节和最后一个字节数据的时刻；</div></li><li><div>domLoading代表浏览器开始解析html文档的时间节点。我们知道IE浏览器下的document有readyState属性，domLoading的值就等于readyState改变为loading的时间节点；</div></li><li><div>domInteractive代表浏览器解析html文档的状态为interactive时的时间节点。domInteractive并非DOMReady，它早于DOMReady触发，代表html文档解析完毕（即dom tree创建完成）但是内嵌资源（比如外链css、js等）还未加载的时间点；</div></li><li><div>domContentLoadedEventStart：代表DOMContentLoaded事件触发的时间节点：</div><blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">页面文档完全加载并解析完毕之后,会触发DOMContentLoaded事件，HTML文档不会等待样式文件,图片文件,子框架页面的加载(load事件可以用来检测HTML页面是否完全加载完毕(fully-loaded))。
</span></div></blockquote></li><li><div>domContentLoadedEventEnd：代表DOMContentLoaded事件完成的时间节点，此刻用户可以对页面进行操作，也就是jQuery中的domready时间；</div></li><li><div>domComplete：html文档完全解析完毕的时间节点；</div></li><li><div>loadEventStart和loadEventEnd分别代表onload事件触发和结束的时间节点</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">使用该api时需要在页面完全加载完成之后才能使用，最简单的办法是在window.onload事件中读取各种数据，因为很多值必须在页面完全加载之后才能得出。我们需要采集的TTFB和秒开率数据指标 可以从这个API里面拿到，示例如下：
</span></div><ul><li><div>var timing = window.performance &amp;&amp; window.performance.timing;</div></li><li><div>var navigation = window.performance &amp;&amp; window.performance.navigation;</div></li><li><div>// TTFB 数据</div></li><li><div>timing.responseStart - timing.fetchStart</div></li><li><div>// TTFB to DOM Ready, 暂不采集</div></li><li><div>timing.domInteractive - timing.fetchStart</div></li><li><div>// Page Load页面打开时间，作为秒开率指标。</div></li><li><div>timing.loadEventStart - timing.fetchStart</div></li><li><div>重定向次数：</div></li><li><div>var redirectCount = navigation &amp;&amp; navigation.redirectCount;</div></li><li><div>跳转耗时：</div></li><li><div>var redirect = timing.redirectEnd - timing.redirectStart;</div></li><li><div>APP CACHE 耗时：</div></li><li><div>var appcache = Math.max(timing.domainLookupStart - timing.fetchStart, 0);</div></li><li><div>DNS 解析耗时：</div></li><li><div>var dns = timing.domainLookupEnd - timing.domainLookupStart;</div></li><li><div>TCP 链接耗时：</div></li><li><div>var conn = timing.connectEnd - timing.connectStart;</div></li><li><div>等待服务器响应耗时（注意是否存在cache）：</div></li><li><div>var request = timing.responseStart - timing.requestStart;</div></li><li><div>内容加载耗时（注意是否存在cache）:</div></li><li><div>var response = timing.responseEnd - timing.responseStart;</div></li><li><div>总体网络交互耗时，即开始跳转到服务器资源下载完成：</div></li><li><div>var network = timing.responseEnd - timing.navigationStart;</div></li><li><div>渲染处理：</div></li><li><div>var processing = (timing.domComplete || timing.domLoading) - timing.domLoading;</div></li><li><div>抛出 load 事件：</div></li><li><div>var load = timing.loadEventEnd - timing.loadEventStart;</div></li><li><div>总耗时：</div></li><li><div>var total = (timing.loadEventEnd || timing.loadEventStart || timing.domComplete || timing.domLoading) - timing.navigationStart;</div></li><li><div>可交互：</div></li><li><div>var active = timing.domInteractive - timing.navigationStart;</div></li><li><div>请求响应耗时，即 T0，注意cache：</div></li><li><div>var t0 = timing.responseStart - timing.navigationStart;</div></li><li><div>首次出现内容，即 T1：</div></li><li><div>var t1 = timing.domLoading - timing.navigationStart;</div></li><li><div>内容加载完毕，即 T3：</div></li><li><div>var t3 = timing.loadEventEnd - timing.navigationStart;</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">PS：注意这个timing中返回的数据单位精度是毫秒。我们尝试统计下当前页面的时间：
</span></div><ul><li><div>;</div></li><li><div>(function() {</div></li><li><div>function getTiming(){</div></li><li><div>try {</div></li><li><div>var time = performance.timing;</div></li><li><div>var timingObj = {};</div></li><li><div>var loadTime = (time.loadEventEnd - time.loadEventStart) / 1000;</div></li><li><div>if(loadTime &lt; 0) {</div></li><li><div>setTimeout(function() {</div></li><li><div>getTiming();</div></li><li><div>}, 200);</div></li><li><div>return;</div></li><li><div>}</div></li><li><div>timingObj['重定向时间'] = (time.redirectEnd - time.redirectStart) / 1000;</div></li><li><div>timingObj['DNS解析时间'] = (time.domainLookupEnd - time.domainLookupStart) / 1000;</div></li><li><div>timingObj['APP缓存时间'] = (Math.max(time.domainLookupStart - time.fetchStart, 0)) / 1000;</div></li><li><div>timingObj['TCP完成握手时间'] = (time.connectEnd - time.connectStart) / 1000;</div></li><li><div>timingObj['HTTP请求响应完成时间'] = (time.responseEnd - time.requestStart) / 1000;</div></li><li><div>timingObj['DOM开始加载前所花费时间'] = (time.responseEnd - time.navigationStart) / 1000;</div></li><li><div>timingObj['DOM加载完成时间'] = (time.domComplete - time.domLoading) / 1000;</div></li><li><div>timingObj['DOM结构解析完成时间'] = (time.domInteractive - time.domLoading) / 1000;</div></li><li><div>timingObj['脚本加载时间'] = (time.domContentLoadedEventEnd - time.domContentLoadedEventStart) / 1000;</div></li><li><div>timingObj['onload事件时间'] = (time.loadEventEnd - time.loadEventStart) / 1000;</div></li><li><div>timingObj['页面完全加载时间'] = (timingObj['重定向时间'] + timingObj['DNS解析时间'] + timingObj['TCP完成握手时间'] + timingObj['HTTP请求响应完成时间'] + timingObj['DOM结构解析完成时间'] + timingObj['DOM加载完成时间']);</div></li><li><div>for(item in timingObj) {</div></li><li><div>console.log(item + &quot;:&quot; + timingObj[item] + '秒(s)');</div></li><li><div>}</div></li><li><div>} catch(e) {</div></li><li><div>console.log(timingObj)</div></li><li><div>console.log(performance.timing);</div></li><li><div>}</div></li><li><div>}</div></li><li><div>getTiming()</div></li><li><div>})();</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;"> 
</span></div><h2><a href="https://www.w3.org/TR/user-timing/#introduction">User Timing API</a></h2><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">User Timing 接口提供了很多方法，让我们可以在应用中的不同位置去调用这些方法，计算用户自己需要的时间。常用的有mark、measure和clearMarks方法。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">mark()</span><span style="-en-paragraph:true;"> 方法是时间分析工具中的主要方法，它的功能就是为我们记录时间，其超级有用之处在于我们可以为我们记录的时间命名，它会将这个名字和时间作为一个独立的单元来记住。在应用中不同位置调用 </span><span style="-en-paragraph:true;">mark()</span><span style="-en-paragraph:true;"> 方法可以让你知道应用中被标记的位置所花费的时间。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">measure() 方法不仅可以计算设置标志之间的时间，而且也能计算标志和 </span><a href="https://www.w3.org/TR/navigation-timing/#sec-navigation-timing-interface" style="-en-paragraph:true;">PerformanceTiming</a><span style="-en-paragraph:true;"> 接口中那些已知的事件名之间的时间。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">clearMarks() 方法可以很简单滴来清除标志。clearMeasures方法可以很简单滴来清除measure。
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">给个简单的例子：
</span></div><ul><li><div>window.performance.mark('mark_fully_loaded');</div></li><li><div>var perfEntries = performance.getEntriesByType(&quot;mark&quot;);</div></li><li><div>for (var i = 0; i &lt; perfEntries.length; i++) {</div></li><li><div>console.log(&quot;Name: &quot; + perfEntries[i].name +</div></li><li><div>&quot; Entry Type: &quot; + perfEntries[i].entryType +</div></li><li><div>&quot; Start Time: &quot; + perfEntries[i].startTime +</div></li><li><div>&quot; Duration: &quot; + perfEntries[i].duration + &quot;\n&quot;);</div></li><li><div>}</div></li><li><div>//output Name: mark_fully_loaded Entry Type: mark Start Time: 9910.900000017136 Duration: 0</div></li><li><div>window.performance.measure('measure_load_from_dom', 'domComplete', 'mark_fully_loaded');</div></li><li><div>var perfEntries = performance.getEntriesByType(&quot;measure&quot;);</div></li><li><div>for (var i = 0; i &lt; perfEntries.length; i++) {</div></li><li><div>console.log(&quot;Name: &quot; + perfEntries[i].name +</div></li><li><div>&quot; Entry Type: &quot; + perfEntries[i].entryType +</div></li><li><div>&quot; Start Time: &quot; + perfEntries[i].startTime +</div></li><li><div>&quot; Duration: &quot; + perfEntries[i].duration + &quot;\n&quot;);</div></li><li><div>}</div></li><li><div>//output Name: measure_load_from_dom Entry Type: measure Start Time: 8643 Duration: 1267.9000000171363</div></li><li><div>window.performance.clearMarks();</div></li><li><div>window.peformance.clearMarks('mark_fully_loaded');</div></li><li><div>window.performance.clearMeasures('measure_load_from_dom');</div></li><li><div>// AJAX请求时间</div></li><li><div>var reqCount = 0;</div></li><li><div>var myReq = new XMLHttpRequest();</div></li><li><div>myReq.open('GET', url, true);</div></li><li><div>myReq.onload = function(e) {</div></li><li><div>window.performance.mark('mark_end_xhr');</div></li><li><div>reqCnt++;</div></li><li><div>window.performance.measure('measure_xhr_' + reqCnt, 'mark_start_xhr', 'mark_end_xhr');</div></li><li><div>do_something(e.responseText);</div></li><li><div>}</div></li><li><div>window.performance.mark('mark_start_xhr');</div></li><li><div>myReq.send();</div></li><li><div>// 计算时间</div></li><li><div>var items = window.performance.getEntriesByType('measure');</div></li><li><div>for (var i = 0; i &lt; items.length(); ++i) {</div></li><li><div>var req = items[i];</div></li><li><div>console.log('XHR ' + req.name + ' took ' + req.duration + 'ms');</div></li><li><div>}</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这个很有用的API经常拿来计算FMP指标。前面也说了，很难统一定义FMP计算规则，不同业务不一样。本课程第一节的时候，我就要求大家一定要先了解业务，了解用户。其中提到了要了解自己做的业务的核心是什么，页面展示的核心是什么。FMP主要是衡量页面核心元素的展示时间。举个例子，如果你做的是视频播放页面，那么加载完播放器到可播放状态就是FMP。给出一个例子：
</span></div><ul><li><div>// 测量 css 加载完成时间：</div></li><li><div>&lt;link rel=&quot;stylesheet&quot; href=&quot;/sheet1.css&quot;&gt;</div></li><li><div>&lt;link rel=&quot;stylesheet&quot; href=&quot;/sheet4.css&quot;&gt;</div></li><li><div>&lt;script&gt; performance.mark(&quot;stylesheets done blocking&quot;); &lt;/script&gt;</div></li><li><div>// 测量关键图片加载完成时间：</div></li><li><div>&lt;img src=&quot;hero.jpg&quot; onload=&quot;performance.clearMarks('img displayed'); performance.mark('img displayed');&quot;&gt;</div></li><li><div>&lt;script&gt;</div></li><li><div>performance.clearMarks(&quot;img displayed&quot;);</div></li><li><div>performance.mark(&quot;img displayed&quot;);</div></li><li><div>&lt;/script&gt;</div></li><li><div>// 测量文字类元素加载完成时间：</div></li><li><div>&lt;p&gt;This is the call to action text element.&lt;/p&gt;</div></li><li><div>&lt;script&gt; performance.mark(&quot;text displayed&quot;); &lt;/script&gt;</div></li><li><div>// 计算加载时间：</div></li><li><div>function measurePerf() {</div></li><li><div>var perfEntries = performance.getEntriesByType(&quot;mark&quot;);</div></li><li><div>for (var i = 0; i &lt; perfEntries.length; i++) {</div></li><li><div>console.log(&quot;Name: &quot; + perfEntries[i].name +</div></li><li><div>&quot; Entry Type: &quot; + perfEntries[i].entryType +</div></li><li><div>&quot; Start Time: &quot; + perfEntries[i].startTime +</div></li><li><div>&quot; Duration: &quot; + perfEntries[i].duration + &quot;\n&quot;);</div></li><li><div>}</div></li><li><div>}</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">主要用mark标记所有需要统计的时间点，然后拿到这些数据上报。
</span></div><h2><a href="https://www.w3.org/TR/resource-timing/">Resource Timing API</a></h2><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">主要是当前浏览器获取所有资源的API，主要是这个PerformanceResourceTiming 接口，entryType是”resource”。
</span></div><ul><li><div>interface PerformanceResourceTiming : PerformanceEntry {</div></li><li><div>readonly attribute DOMString initiatorType;</div></li><li><div>readonly attribute DOMHighResTimeStamp redirectStart;</div></li><li><div>readonly attribute DOMHighResTimeStamp redirectEnd;</div></li><li><div>readonly attribute DOMHighResTimeStamp fetchStart;</div></li><li><div>readonly attribute DOMHighResTimeStamp domainLookupStart;</div></li><li><div>readonly attribute DOMHighResTimeStamp domainLookupEnd;</div></li><li><div>readonly attribute DOMHighResTimeStamp connectStart;</div></li><li><div>readonly attribute DOMHighResTimeStamp connectEnd;</div></li><li><div>readonly attribute DOMHighResTimeStamp secureConnectionStart;</div></li><li><div>readonly attribute DOMHighResTimeStamp requestStart;</div></li><li><div>readonly attribute DOMHighResTimeStamp responseStart;</div></li><li><div>readonly attribute DOMHighResTimeStamp responseEnd;</div></li><li><div>serializer = {inherit, attribute};</div></li><li><div>};</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">获取performance所有记录时，会看到返回的有PerformanceResourceTiming的数据（entryType为 “resource”）。其中 initiatorType 是请求发起的类型，这里有外链CSS中的link标签，img标签，script标签，CSS（@import 导入的）等等。
</span></div><h2><a href="https://www.w3.org/TR/performance-timeline-2/">Performance Timeline API</a></h2><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">顾名思义，这个 Timeline API 用于列出页面的时间线，包含用户自定义的时间点和</span><a href="https://www.w3.org/TR/navigation-timing/#sec-navigation-timing-interface" style="-en-paragraph:true;">PerformanceTiming</a><span style="-en-paragraph:true;">默认的时间点。主要是扩展了performance接口，增加了 getEntries、getEntriesByType、getEntriesByName这三个方法，返回 PerformanceEntry 对象，定义如下：
</span></div><ul><li><div>[Exposed=(Window,Worker)]</div></li><li><div>interface PerformanceEntry {</div></li><li><div>readonly attribute DOMString name;</div></li><li><div>readonly attribute DOMString entryType;</div></li><li><div>readonly attribute DOMHighResTimeStamp startTime;</div></li><li><div>readonly attribute DOMHighResTimeStamp duration;</div></li><li><div>[Default] object toJSON();</div></li><li><div>};</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">为了优化timeline数据的获取和处理，增加了PerformanceObserver接口。用法对比如下：
</span></div><ul><li><div>// 旧的写法</div></li><li><div>function init() {</div></li><li><div>// see [[USER-TIMING-2]]</div></li><li><div>performance.mark(&quot;startWork&quot;);</div></li><li><div>doWork(); // Some developer code</div></li><li><div>performance.mark(&quot;endWork&quot;);</div></li><li><div>measurePerf();</div></li><li><div>}</div></li><li><div>function measurePerf() {</div></li><li><div>performance</div></li><li><div>.getEntries()</div></li><li><div>.map(entry =&gt; JSON.stringify(entry, null, 2))</div></li><li><div>.forEach(json =&gt; console.log(json));</div></li><li><div>}</div></li><li><div>// 基于PerformanceObserver新用法</div></li><li><div>const observer = new PerformanceObserver(list =&gt; {</div></li><li><div>list</div></li><li><div>.getEntries()</div></li><li><div>// Get the values we are interested in</div></li><li><div>.map(({ name, entryType, startTime, duration }) =&gt; {</div></li><li><div>const obj = {</div></li><li><div>&quot;Duration&quot;: duration,</div></li><li><div>&quot;Entry Type&quot;: entryType,</div></li><li><div>&quot;Name&quot;: name,</div></li><li><div>&quot;Start Time&quot;: startTime,</div></li><li><div>};</div></li><li><div>return JSON.stringify(obj, null, 2);</div></li><li><div>})</div></li><li><div>// Display them to the console</div></li><li><div>.forEach(console.log);</div></li><li><div>// maybe disconnect after processing the events.</div></li><li><div>observer.disconnect();</div></li><li><div>});</div></li><li><div>// retrieve buffered events and subscribe to new events</div></li><li><div>// for Resource-Timing and User-Timing</div></li><li><div>observer.observe({</div></li><li><div>entryTypes: [&quot;resource&quot;, &quot;mark&quot;, &quot;measure&quot;],</div></li><li><div>buffered: true</div></li><li><div>});</div></li></ul><h1>FP/FCP、卡顿（longtask）指标
</h1><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">可以通过获取paint类型的条目来计算FP/FCP指标，如下：
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">可以通过PerformanceObserver获取long task数据，进而得到卡顿指标。
</span></div><ul><li><div>const observer = new PerformanceObserver((list) =&gt; {</div></li><li><div>for (const entry of list.getEntries()) {</div></li><li><div>console.log( {</div></li><li><div>eventCategory: 'Performance Metrics',</div></li><li><div>eventAction: 'longtask',</div></li><li><div>eventValue: Math.round(entry.startTime + entry.duration),</div></li><li><div>eventLabel: JSON.stringify(entry.attribution),</div></li><li><div>});</div></li><li><div>}</div></li><li><div>});</div></li><li><div>observer.observe({entryTypes: ['longtask']});</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;"> 
</span></div><h2>内存堆栈数据
</h2><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">直接通过performance这个对象可以拿到，挂载在memory这个属性下，如下：
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;"> 
</span></div><h2>TTI指标
</h2><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">TTI指标采集可以采用谷歌提供的 </span><a href="https://github.com/GoogleChromeLabs/tti-polyfill" style="-en-paragraph:true;">tti-polyfill</a><span style="-en-paragraph:true;">。使用方法：
</span></div><ul><li><div>npm install tti-polyfill</div></li><li><div>import ttiPolyfill from './path/to/tti-polyfill.js';</div></li><li><div>ttiPolyfill.getFirstConsistentlyInteractive(opts).then((tti) =&gt; {</div></li><li><div>// Use `tti` value in some way.</div></li><li><div>});</div></li></ul><h1>交互延迟指标
</h1><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">通用的处理方法，可以用</span><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" style="-en-paragraph:true;">MutationObserver</a><span style="-en-paragraph:true;">来监听DOM变化，用performance.mark来统计用户交互操作后到响应的时间。以统计无效点击为例：
</span></div><ul><li><div>let targetNode = document.body;</div></li><li><div>// Options for the observer (which mutations to observe)</div></li><li><div>let config = {</div></li><li><div>attributes: true,</div></li><li><div>childList: true,</div></li><li><div>subtree: true</div></li><li><div>};</div></li><li><div>// Callback function to execute when mutations are observed</div></li><li><div>const mutationCallback = (callback) =&gt; {</div></li><li><div>setTimeout(callback, 150)</div></li><li><div>return (mutationsList) =&gt; {</div></li><li><div>for(let mutation of mutationsList) {</div></li><li><div>let type = mutation.type;</div></li><li><div>switch (type) {</div></li><li><div>case &quot;childList&quot;:</div></li><li><div>case &quot;attributes&quot;:</div></li><li><div>case &quot;subtree&quot;:</div></li><li><div>callback &amp;&amp; callback();</div></li><li><div>break;</div></li><li><div>default:</div></li><li><div>break;</div></li><li><div>}</div></li><li><div>}</div></li><li><div>}</div></li><li><div>};</div></li><li><div>// 点击事件</div></li><li><div>targetNode.addEventListener(&quot;click&quot;,function(){</div></li><li><div>performance.clearMarks(&quot;click_start&quot;);</div></li><li><div>performance.mark(&quot;click_start&quot;);</div></li><li><div>// Create an observer instance linked to the callback function</div></li><li><div>let observer = new MutationObserver(mutationCallback(function(){</div></li><li><div>performance.clearMarks(&quot;click_end&quot;);</div></li><li><div>performance.mark(&quot;click_end&quot;);</div></li><li><div>window.performance.measure('click_res_time', 'click_start', 'click_end');</div></li><li><div>// 在统一监听PerformanceObserver的地方可以拿到这个点击后响应的时间，进行上报</div></li><li><div>// Later, you can stop observing</div></li><li><div>observer.disconnect();</div></li><li><div>}));</div></li><li><div>// Start observing the target node for configured mutations</div></li><li><div>observer.observe(targetNode, config);</div></li><li><div>}, true)</div></li><li><div>// 获取，这里只是示例，可以用上面的performanceObserver</div></li><li><div>var perfEntries = performance.getEntriesByType(&quot;measure&quot;);</div></li><li><div>for (var i = 0; i &lt; perfEntries.length; i++) {</div></li><li><div>console.log(&quot;Name: &quot; + perfEntries[i].name +</div></li><li><div>&quot; Entry Type: &quot; + perfEntries[i].entryType +</div></li><li><div>&quot; Start Time: &quot; + perfEntries[i].startTime +</div></li><li><div>&quot; Duration: &quot; + perfEntries[i].duration + &quot;\n&quot;);</div></li><li><div>}</div></li></ul><h2>EventTiming API
</h2><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这里必须介绍下</span><a href="https://wicg.github.io/event-timing/" style="-en-paragraph:true;">Event Timing API</a><span style="-en-paragraph:true;">，有了这个API，我们统计交互延迟数据方便很多，主要用来监听响应超过100ms的示例：
</span></div><ul><li><div>const observer = new PerformanceObserver(function(list) {</div></li><li><div>const perfEntries = list.getEntries();</div></li><li><div>for (let i = 0; i &lt; perfEntries.length; i++) {</div></li><li><div>// Process event and report to analytics and monitoring...</div></li><li><div>const entry = perfEntries[i];</div></li><li><div>const inputDelay = entry.processingStart - entry.startTime;</div></li><li><div>if (inputDelay !== 0) {</div></li><li><div>// Report the input delay when there are event handlers.</div></li><li><div>}</div></li><li><div>}</div></li><li><div>});</div></li><li><div>// Register observer for event.</div></li><li><div>observer.observe({entryTypes: [&quot;event&quot;]});</div></li><li><div>...</div></li><li><div>// Later on, we can also directly query the first input information.</div></li><li><div>const firstArray = performance.getEntriesByType('firstInput');</div></li><li><div>if (firstArray.length !== 0) {</div></li><li><div>const firstInput = firstArray[0];</div></li><li><div>// Process the first input event and report back...</div></li><li><div>}</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">通过</span><a href="https://wicg.github.io/event-timing/" style="-en-paragraph:true;">Event Timing API</a><span style="-en-paragraph:true;">可以很容易拿到FID时间。event timing entry的定义如下：
</span></div><ul><li><div>interface PerformanceEventTiming : PerformanceEntry {</div></li><li><div>readonly attribute DOMHighResTimeStamp processingStart;</div></li><li><div>readonly attribute DOMHighResTimeStamp processingEnd;</div></li><li><div>readonly attribute boolean cancelable;</div></li><li><div>};</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><a href="https://wicg.github.io/event-timing/#performanceeventtiming" style="-en-paragraph:true;">PerformanceEventTiming</a><span style="-en-paragraph:true;"> 继承了 </span><a href="https://w3c.github.io/performance-timeline/#the-performanceentry-interface" style="-en-paragraph:true;">PerformanceEntry</a><span style="-en-paragraph:true;"> 接口，</span><a href="https://w3c.github.io/performance-timeline/#the-performanceentry-interface" style="-en-paragraph:true;">PerformanceEntry</a><span style="-en-paragraph:true;"> 接口包含下面4个属性：
</span></div><dt><a href="https://w3c.github.io/performance-timeline/#dom-performanceentry-name" name="ref-for-dom-performanceentry-name">name</a>：<a href="https://wicg.github.io/event-timing/#performanceeventtiming-associated-event">相关事件的</a><a href="https://wicg.github.io/event-timing/#performanceeventtiming-associated-event" name="ref-for-performanceeventtiming-associated-event">类型</a>
</dt><dt><a href="https://w3c.github.io/performance-timeline/#dom-performanceentry-entrytype" name="ref-for-dom-performanceentry-entrytype">entryType</a>：对于比较长的耗时时间，返回 <code>&quot;event&quot;</code>，首次用户交互返回 <code>&quot;firstInput&quot;</code>
</dt><dt><a href="https://w3c.github.io/performance-timeline/#dom-performanceentry-starttime" name="ref-for-dom-performanceentry-starttime">startTime</a>：事件开始的<a href="https://dom.spec.whatwg.org/#dom-event-timestamp" name="ref-for-dom-event-timestamp①">timeStamp</a>.
</dt><dt><a href="https://w3c.github.io/performance-timeline/#dom-performanceentry-duration" name="ref-for-dom-performanceentry-duration">duration</a>：The <a href="https://w3c.github.io/performance-timeline/#dom-performanceentry-duration" name="ref-for-dom-performanceentry-duration①">duration</a> attribute’s getter must return the difference between the time of the first <a href="https://html.spec.whatwg.org/multipage/webappapis.html#update-the-rendering" name="ref-for-update-the-rendering">update the rendering</a> occurring after <a href="https://wicg.github.io/event-timing/#performanceeventtiming-associated-event" name="ref-for-performanceeventtiming-associated-event②">associated event</a> has been dispatched and the <a href="https://w3c.github.io/performance-timeline/#dom-performanceentry-starttime" name="ref-for-dom-performanceentry-starttime②">startTime</a>, rounded up to the nearest 8 ms.
</dt><div style="margin-top: 1em; margin-bottom: 1em;"><a href="https://wicg.github.io/event-timing/#performanceeventtiming" style="-en-paragraph:true;">PerformanceEventTiming</a><span style="-en-paragraph:true;"> 有下面额外的3个属性:
</span></div><dt><a href="https://wicg.github.io/event-timing/#dom-performanceeventtiming-processingstart" name="ref-for-dom-performanceeventtiming-processingstart①">processingStart</a>：The <dfn><code>processingStart</code></dfn> attribute’s getter returns the time when event handlers start to execute, or <a href="https://w3c.github.io/performance-timeline/#dom-performanceentry-starttime" name="ref-for-dom-performanceentry-starttime③">startTime</a> if there are no event handlers.
</dt><dt><a href="https://wicg.github.io/event-timing/#dom-performanceeventtiming-processingend" name="ref-for-dom-performanceeventtiming-processingend①">processingEnd</a>：The <dfn><code>processingEnd</code></dfn> attribute’s getter returns the time when event handlers have finished executing, or <a href="https://w3c.github.io/performance-timeline/#dom-performanceentry-starttime" name="ref-for-dom-performanceentry-starttime④">startTime</a> if there are no event handlers.
</dt><dt><a href="https://wicg.github.io/event-timing/#dom-performanceeventtiming-cancelable" name="ref-for-dom-performanceeventtiming-cancelable①">cancelable</a>：The <dfn><code>cancelable</code></dfn> attribute’s getter must return the <a href="https://wicg.github.io/event-timing/#performanceeventtiming-associated-event" name="ref-for-performanceeventtiming-associated-event③">associated event</a>’s <a href="https://dom.spec.whatwg.org/#dom-event-cancelable" name="ref-for-dom-event-cancelable">cancelable</a>.
</dt><h2>FID时间
</h2><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">关于FID官方给了一个实现库，其实我们用上面的代码已经计算了FID。官方库：</span><a href="https://github.com/GoogleChromeLabs/first-input-delay" style="-en-paragraph:true;">first-input-delay </a><span style="-en-paragraph:true;">使用方法：
</span></div><ul><li><div>npm install --save-dev first-input-delay</div></li><li><div>// The perfMetrics object is created by the code that goes in &lt;head&gt;.</div></li><li><div>perfMetrics.onFirstInputDelay(function(delay, evt) {</div></li><li><div>ga('send', 'event', {</div></li><li><div>eventCategory: 'Perf Metrics',</div></li><li><div>eventAction: 'first-input-delay',</div></li><li><div>eventLabel: evt.type,</div></li><li><div>// Event values must be an integer.</div></li><li><div>eventValue: Math.round(delay),</div></li><li><div>// Exclude this event from bounce rate calculations.</div></li><li><div>nonInteraction: true,</div></li><li><div>});</div></li><li><div>});</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;"> 
</span></div><h1><a href="https://github.com/GoogleChrome/OriginTrials" style="font-weight: bold;">OriginTrials</a></h1><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">我们一般在about:flags里打开了“Experimental Web Platform features”，这个开关使得我的Chrome开启了该实验特性，而我们的用户并不会打开。针对这个问题，实际上Chrome有一个“Origin Trials”的特性，通过该特性Web开发者可以主动申明在自己的站点上启用该特性，而不需要用户手动开启，对于Web开发者来说我们可以更早地使用新特性，而对于浏览器及Web标准组织来说也可以收到更多的使用反馈。官方使用手册：</span><a href="https://github.com/GoogleChrome/OriginTrials/blob/gh-pages/developer-guide.md" style="-en-paragraph:true;">guide</a><span style="-en-paragraph:true;">
</span></div><h2>注册token
</h2><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">首先你要</span><a href="https://developers.chrome.com/origintrials/" style="-en-paragraph:true;">注册一个token</a><span style="-en-paragraph:true;">，设置你想要开启的域名，然后会生成一个token。
</span></div><h2>配置页面
</h2><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">有两种方式
</span></div><ol><li><div>页面添加meta标签</div></li></ol><ul><li><div>&lt;meta http-equiv=&quot;origin-trial&quot; content=&quot;**insert your token as provided in the developer console**&quot;&gt;</div></li></ul><ol><li><div>页面的http 响应header返回下面的头部</div></li></ol><ul><li><div>Origin-Trial: **token as provided in the developer console**</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">更多信息，看下</span><a href="https://github.com/GoogleChrome/OriginTrials" style="-en-paragraph:true;">官方说明</a><span style="-en-paragraph:true;">
</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;"> 
</span></div><h1>采样
</h1><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">说一个采样的概念，我们不能把所有客户端的数据都采集回来，当你的业务每天有几百万的pv的时候，数据量是可怕的。而且我们也不需要这么多的数据，所以我们只需要采集部分客户端的数据就可以了。这就是采样的概念。要先确定一些指标：
</span></div><ul><li><div>采集多少量</div></li><li><div>采样规则</div></li></ul><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;"> 
</span></div><h1>总结与思考
</h1><div><span style="-en-paragraph:true;">本章我们从高性能、极致用户体验的目的出发，总结了加载性能指标、稳定性指标、用户体验指标 三个大的指标集，作为后面我们分析页面性能的依据，验证我们开发的页面是否达到了要求。然后我们研究了浏览器提供的Performance API，利用浏览器提供的统计信息来计算我们的性能和体验指标。
</span></div></span>
</div></body></html> 