<html>
<head>
  <title>高性能JavaScript</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="2018"/>
<h1>高性能JavaScript</h1>

<div>
<span><div><b><font style="font-size: 24px;">一、加载和执行</font></b></div><div><br/></div><div>&lt;script&gt;标签每次出现都霸道地让页面等待脚本的解析和执行。无论当前的JS代码是内嵌的还是包含在外链文件中，页面的下载和渲染都必须 停下来等待脚本执行完成。</div><div><br/></div><div><b>A.脚本位置</b></div><div>由于脚本会阻塞页面其他资源的下载，因此推荐将所有的&lt;script&gt;标签尽可能放到&lt;body&gt;标签的底部，以尽量养活对整个页面下载的影响。</div><div><br/></div><div><b>B.组织脚本</b></div><div>由于每个&lt;script&gt;标签初始下载时都会阻塞页面渲染，所以养活页面包含的&lt;script&gt;标签数量有助于改善这一情况。考虑到HTTP请求带来额外的性能开销，下载单个100K的文件比下载4个25K的文件更快。可以把多个JS文件合并成一个。</div><div><br/></div><div><b>C.无阻塞的脚本</b></div><div>在页面加载完成后才加载JS代码，也就是在window.load之后才开始下载脚本</div><div><br/></div><div><b>D.延迟的脚本</b></div><div>HTML4为&lt;script&gt;标签定义了一个扩展属性：defer。指明本元素所含的脚本不会修改DOM，因此代码能安全地延迟执行。任何带有defer属性的&lt;script&gt;元素在DOM完成加载之前都不会被执行，无论内嵌或外链脚本都是如此。</div><div><br/></div><div><b>E.动态脚本元素</b></div><div>1.使用document.createElement创建script元素，文件在该元素被添加到页面时开始下载，无论何时启动下载，文件的下载和执行过程不会阻塞页面其他进程。</div><div>2.Firefox、Opera、Chrome和Safari会在&lt;script&gt;元素接收完成时触发一个load事件。IE会触发一个readystatechange事件，&lt;script&gt;元素提供一个readyState属性，需要同时检查是否是loaded或complete状态。</div><div><br/></div><div><b>F.XMLHttpRequest脚本注入</b></div><div>可以下载JS代码而不立即执行。同样的代码在所有主流浏览器都能正常工作。局限性是不能跨域。</div><div><br/></div><div><b>G.YUI3的方式</b></div><div>YUI3的一个核心理念是：由页面中的少量代码来加载丰富的功能组件 。</div><div><br/></div><div><b>H.LazyLoad类库</b></div><div><a href="http://github.com/rgrove/lazyload/">https://github.com/rgrove/lazyload/</a></div><div><br/></div><div><b>I.LABjs</b></div><div><a href="http://labjs.com">http://labjs.com</a></div><div><br/></div><div>/gaoxingnengjs/1.html</div><div>/gaoxingnengjs/1.js</div><div><br/></div><div><b><font style="font-size: 24px;">二、数据存取</font></b></div><div><br/></div><div>四种基本的数据存取位置：字面量、本地变量、数组元素、对象成员；</div><div><br/></div><div><b>A.管理作用域</b></div><div>1.作用域链和标识符解析</div><div><ul><li>每个js函数都表示为一个对象，确切地说，是Function对象的一个实例。<br/></li><li>内部属性[[Scope]]包含了一个函数被创建的作用域中对象的集合。这个集合被称为函数的作用域链，它决定哪些数据能被函数访问。函数作用域中每个对象被称为一个可变对象，每个可变对象都以“键值对”的形式存在。当一个函数创建后，它的作用域会被创建此函数的作用域中可访问的数据对象所填充。<br/></li><li>每个执行环境都有自己的作用域链，用于解析标识符。当执行环境被创建时，它的作用域链初始化为当前运行函数的[[Scope]]属性中的对象。这些值按照它们出现在函数中的顺序被复制到执行环境的作用域链接中。这个过程一旦完成，一个被称为“活动对象（activation object）”的新对象就为执行环境创建好了。些对象被推入作用域链的最前端。<br/></li><li>在函数执行过程中，遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取或存储数据。从作用域链头部开始，也就是当前运行函数的活动对象。如果无法找到，就是被视为是未定义的。<br/></li></ul></div><div>2.标识符解析的性能</div><div><ul><li>一个标识符所在的位置越深，它的读写速度也就越慢。因此，函数中读写局部变量总是最快的，而读写全局变量通常是最慢的，全局变量总是存在于执行环境作用域的最末端，因此它也是最远的。<br/></li><li>如果某个跨作用域的值在函数中被引用一次以上，那么就把它存储到局部变量里。<br/></li></ul></div><div>3.改变作用域链</div><div><ul><li>避免使用with，把全局变量存储在一个局部变量中更简单可以提升性能<br/></li><li>try-catch语句中的catch子句也可以改变，当try中发生错误，执行过程会自动跳转到catch子句，然后把异常对象推入一个变量对象并置于作用域的首付。在catch代码块内部，函数所有局部变量将会放在第二个作用域链对象中。<br/></li><li>一旦catch子句执行完毕，作用域链就会返回到之前的状态。尽量简化代码来使得catch子句对性能的影响最小化。一种推荐的做法是将错误委托给一个函数来处理。<br/></li></ul></div><div>4.动态作用域</div><div>无论是with语句还是try-catch语句的catch子句，或是包含eval()的函数，都被认为是动态作用域。只有在确实有必要时才推荐使用动态作用域。</div><div>5.闭包、作用域和内存</div><div><ul><li>闭包允许函数访问局部作用域之外的数据，使用闭包可能会导致性能问题。<br/></li><li>由于闭包的[[Scope]]属性包含了与执行环境作用域链相同的对象的引用，因此会产生副作用。通常来说，函数的活动对象会随着执行环境一同销毁。但引入闭包时，由于引用仍然存在于闭包的[[Scope]]中，因此激活对象无法被销毁。这意味着脚本中的闭包与非闭包函数相比，需要更多的内存开销。<br/></li><li>当闭包代码执行时，会创建一个执行环境，它的作用域链与属性[[Scope]]中所引用的两个相同的作用域链对象一起被初始化，然后一个活动对象为闭包自身所创建。<br/></li><li>在频繁访问跨作用域的标识符时，每次访问都会带来性能损失。在脚本编程中，最好小心地使用闭包，它同时关系到内存和执行速度。可以将常用的跨作用域变量存储在局部变量中，然后直接访问局部变量。<br/></li></ul></div><div><br/></div><div><b>B.对象成员</b></div><div>对象成员包含属性和方法，在js中，二者有些许差异。一个被命名的对象成员能包含任何数据类型。既然函数也是一种对象，那么对象成员除传统数据类型外，还可以包含函数。当一个被命名的成员引用了一个函数，该成员就被称为一个“方法”，相反，引用了非函数类型的成员就被称为“属性”。</div><div>1.原型</div><div><ul><li>原型是其他对象的基础，它定义并实现了一个新创建的对象所必须包含的成员列表。传统语言中，“类”定义了创建新对象的过程，而原型对象为所有对象实例所共享，这些实例也共享了原型对象的成员。<br/></li><li>可以使用hasOwnProperty方法来判断对象是否包含特定的实例成员。要确定对象是否包含特定的属性，可以使用in操作符。<br/></li></ul></div><div>2.原型链</div><div><ul><li>对象的原型决定了实例的类型。默认情况下，所有对象都是对象（Object）的实例，并继承了所有基本方法，比如toString()。可以定义并使用构造函数来创建另一种类型的原型。<br/></li><li>对象原型链的位置越深，速度也越慢。与作用域类似。<br/></li></ul></div><div>3.嵌套成员</div><div>例如window.location.href，对象成员嵌套越深，读取速度就会越慢。</div><div>4.缓存对象成员值</div><div>在函数中如果要多次读取同一个对象属性，最佳做法是将属性值保存到局部变量中。局部变量能用来替代属性以避免多次查找带来的性能开销。特别是在处理嵌套对象成员时，这样做会明显提升执行速度。</div><div><br/></div><div>/gaoxingnengjs/2.html<br/></div><div><br/></div><div><b><font style="font-size: 24px;">三、DOM编程</font></b></div><div><b>A.浏览器中的DOM</b></div><div>1.天生就慢，js和DOM两个独立的功能通过接口连接，就会产生消耗。</div><div><br/></div><div><b>B.DOM访问与修改</b></div><div>1.减少访问DOM的次数，把运算尽量留在ECMAScript这一端处理</div><div>2.使用innerHTML方式相比DOM方法大部分浏览器下略快一点点，DOM方式为document.createElement和document.createTextNode这种（并不是非常明显）</div><div>3.使用使用element.cloneNode比直接document.createElement方式略快（也不明显）</div><div>4.DOM标准中的定义，HTML集以一种“假定实时态”实时存在，这意味着当底层文档对象更新时，它也会自动更新。HTML集合一直与文档保持着连接，每次你需要最新的信息时，都会重复执行查询的过程，哪怕只是获取集合里的元素个数（即访问集合的length属性）也是如此。</div><div>5.很多情况下如果只需要遍历一个相对较小的集合，那么缓存length就够了。但由于遍历数组比遍历集合快，因此如果先将集合元素拷贝到数组中，那么访问它的属性会更快。</div><div>6.可以使用childNodes得到元素集合，或者用nextSibling来获取每个相邻元素。在不同浏览器中运行时间几乎相等，IE6、7中使用nextSibling更快。</div><div><div>7.使用children比childNodes更快，因为集合项更少。</div><div>8.使用querySelectorAll()返回一个NodeList包含匹配节点的类数组对象。不会返回HTML集合，因此返回的节点不会对应实时的文档结构 。还有querySelector()</div><div><br/></div><div><b>C.重绘与重排</b></div><div>1.浏览器下载完页面中所有组件之后会解析并生成两个内部数据结构：DOM树、渲染树。一旦DOM和渲染树构建完成，浏览器就开始显示（绘制“paint”）页面元素。</div><div>2.当DOM的变化影响了元素的几何属性（宽和高），浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程称为“重排（reflow）”。完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为“重绘（repaint）”。</div><div>3.重排何时发生：添加或删除可见的DOM元素；元素位置改变；元素尺寸改变；内容改变；页面渲染器初始化；浏览器容器尺寸改变；</div><div>4.操作DOM时，减少重绘和重排的次数：使元素脱离文档流、对其应用多重改变、把元素带回文档中</div><div>5.三种基本方法使DOM脱离文档：隐藏元素，应用修改，重新显示；使得文档片断（document fragment）在当前DOM之外构建一个子树，再把它拷贝回文档；将原始元素拷贝到一个脱离文档的节点中，修改副本，完成后再替换原始元素。</div><div>6.浏览器尝试通过队列化修改和指执行的方式最小化重排次数。当你查询布局信息时，比如获取偏移量（offsets）、滚动位置（scroll values）或计算出的样式值（computedsytle values）时，浏览器为了返回最新值，会刷新队列并应用所有变更。最好的做法是尽量减少布局信息的获取次数，获取后把它赋值给局部变量，然后再操作局部变量。</div><div>7.脱离动画流：使用绝对位置定位页面上的动画元素，将其脱离文档流；让元素动起来。当它扩大时，会临时覆盖部分页面。但这只是页面一个小区域的重绘过程，不会产生重排并重绘页面的大部分内容；当动画结束时恢复定位，从而只会下移一次文档的其他元素。</div><div><br/></div><div><b>D.事件委托</b></div><div>1.事件还层冒泡并能被父级元素捕获。使用事件代理，只需给外层元素绑定一个处理器，就可以处理在其子元素上触发的所有事件。每个事件都要经历三个阶段：捕获、到达目标、冒泡。</div><div>2.你只需检查事件是否来自你所预期的元素。跨浏览器的兼容的部分包括：访问事件对象，并判断事件源；取消文档树中的冒泡（可选）；阻止默认动作（可选）；</div><div><br/></div><div>/gaoxingnengjs/3.html<br/></div><div><br/></div><div><b><font style="font-size: 24px;">四、算法和流程控制</font></b></div><div><b>A.循环</b></div><div>1.在for长生不死初始化中的var语句会创建一个函数级变量，而不是循环级。由于JS只有函数级作用域，因此，在for循环中定义一个新变量相当于在循环体外定义一个新变量。</div><div>2.for-in循环比其他几种要慢。</div><div>3.减少迭代的工作量：items.length放在局部变量上；通过颠倒数组的顺序倒序循环来提高循环性能；</div><div>4.养活迭代次数：达夫设备（Duff’s Device）</div><div>5.ECMA4引入的forEach()方法，要运行的函数作为参数传给forEach()，并在调用时接收三个参数，分别是：当前数组基的值、索引以及数组本身。比基于循环的慢。</div><div><br/></div><div><b>B.条件语句</b></div><div>1.条件数量越大，越倾向于使用switch而不是if-else。通常来说，if-else适用于判断两个离散值或几个不同的值域。当判断多于两个离散值时，switch语句是更佳选择。</div><div>2.优化if-else的目标是：最小化到达正确分支所需判断的条件数量。</div><div>3.当大量离散值需要测试时，使用数组项，将返回值集合存入数组，直接用result[value]。</div><div><br/></div><div><b>C.递归</b></div><div>1.任何递归能实现的算法同样可以用迭代来实现。它不会像递归版本那样受调用栈限制的影响，使用迭代实现是避免栈举出错误的方法之一。</div><div>2.Memoization缓存前一个计算结果供后续计算使用，避免了重复工作。</div><div><br/></div><div>/gaoxingnengjs/4.js<br/></div><div><br/></div><div><b><font style="font-size: 24px;">五、字符串和正则表达式</font></b></div><div><b>A.字符串优化</b></div><div>1.加和加等操作符：使用str = str + “one”+”two”（在ie7及以前的版本中会更慢）</div><div>2.Array.prototype.join会比其他字符串连接方法更慢（但在IE7及更早版本合并大量字符串更高效）</div><div>3.String.prototype.concat，比+和+=稍慢，比数组项连接更慢一些</div><div><br/></div><div><b>B.正则表达式优化</b></div><div>1.正则表达式工作步骤：编译；设置起始位置；匹配每个正则表达式字元；匹配成功或失败；</div><div>2.回溯：当正则匹配字符串时，从左到右逐个测试表达式的组成部分。当遇到题记和分支时，需要决策下一步如何 处理。如果遇到量词，正则需决定何时尝试匹配更多字符；如果遇到分支，那么必须 从可选项中选择一个尝试匹配。每当正则做类似的决定时，如果有必要的话，都会记录其他选择，以备返回时使用。如果当前选项匹配成功，正则继续扫描表达式，如果其他部分也匹配成功，那么匹配结束。如果当前选项找不到匹配值，或后面的部分匹配失败，那么正则会回溯到最后一个决策点，然后在剩余的选项中选择一个。直到成功或失败。</div><div>3.JS不支持原子组，但预查是原子组。嵌套量词有可能导致回溯失控，如(x+)*</div><div>4.提高正则表达式效率的方法：关注如何让匹配更快失败；正则表达式以简单，必需的字元开始；使用量词模式，使它们后面的字元互斥；养活分支数量，缩小分支范围；使用非捕获组；只捕获感兴趣的文本以减少后处理；暴露必需的字元；使用合适的量词；把正则表达式赋值给变量并重用它们；将按复杂的正则表达式拆分为简单的片段；</div><div>5.所有的字符串方法速度都很快，当你搜索那些并不依赖正则表达式复杂特性的字面字符串时，它们有助于避免正则表达式带来的性能开销。</div><div><br/></div><div>/gaoxingnengjs/5.js<br/></div><div><br/></div><div><b><font style="font-size: 24px;">六、快速响应的用户界面</font></b></div><div><b>A.浏览器UI线程</b></div><div>1.用于执行JS和更新用户界面的进程通常被称为“浏览器UI线程”。</div><div>2.如果用户试图在任务运行期间与页面交互，不仅没有即时的UI更新，甚至可能新的UI更新任务都不会被创建并加入队列。事实上，大多数浏览器在JS运行时会停止把新任务加入UI线程的队列中，也就是说JS任务必须尽快结束，以避免对用户体验造成不良影响。</div><div>3.浏览器限制：一是调用栈大小限制 ；二是长时间运行脚本限制；</div><div>4.限制所有JS任务在100毫秒或更短的时间内完成，以获得更好的用户体验。</div><div><br/></div><div><b>B.使用定时器让出时间片段</b></div><div>1.setTimeout创建了一个只执行一次的定时器，而setInterval创建了一个周期性重复运行的定时器</div><div>2.定时器与UI线程的交互方式有助于把运行耗时较长的脚本拆分为较短的片段。第二个参数表示任务何时被添加到UI队列，而不是一定会在这段时间后执行；这个任务会等待队列中其他所有任务执行完毕才会执行。</div><div>3.无论发生何种情况，创建一个定时器会造成UI线程暂停，如同它从一个任务切换到下一个任务。因此，定时器代码会重置所有相关的浏览器限制 ，包括长时间运行脚本定时器。此外，调用栈也在定时器的代码中重置为0。</div><div>4.定时器不可用于测量实际时间，不太精准。</div><div>5.是否可以用定时器取代循环的两个决定性因素：处理过程是否必同步？数据是否必须按顺序处理？都是“否”那么代码将适用于定时器分解任务。</div><div>6.当多个重复的定时器同时创建往往会出现性能问题。因为只有一个UI线程，而所有的定时器都在争夺运行时间。创建一个独立的重复定时器，每次执行多个操作。</div><div><br/></div><div><b>C.Web Workers</b></div><div>1.Web Wrokers从外部线程中修改DOM会导致用户界面出现错误，但是每个Web Workers都有自己的全局运行环境，其功能只是js特性的一个子集。由如下部分组成：一个navigator对象，包含四个属性：appName、appVersion、userAgent、platform；一个location对象，仅只读；一个self对象，指向全局worker对象；一个importScripts()方法，加载 Worker所用到的外部JS文件；所有ECMAScript对象，如：Object、Array、Date等；XMLHttpRequest构造器；setTimeout()和setInterval()方法；一个close()方法，立刻停止Worker运行；</div><div>2.Worker与网页代码通过事件接口进行通信。网页代码通过postMessage()方法给Worker传递数据。Worker还有一个用来接收信息的onmessage事件处理器。postMessage()可以传递原始值（字符串、数字、布尔值、null和undefined），也可以传递Object和Array的实例。</div><div>3.Worker通过importScripts()方法加载 外部JS文件，可接收一个或多个JS文件URL，调用过程是阻塞式的，但Worker独立于UI线程之外，因此不会影响UI响应。</div><div>4.Web Workers适用于那些处理纯数据，或者与浏览器UI无关的长时间运行脚本。如：编码/解码大字符串，复杂数学 运算（包括图像或视频处理），大数组排序，任何超过100毫秒的处理过程。</div><div><br/></div><div>/gaoxingnengjs/6.js<br/></div><div>/gaoxingnengjs/6.html<br/></div><div>/gaoxingnengjs/code.js<br/></div><div><br/></div><div><b><font style="font-size: 24px;">七、Ajax</font></b></div><div><b>A.数据传输</b></div><div>1.五种常用技术向服务器请求数据：XMLHttpRequest（XHR）、Dynamic script tag insertion动态脚本注入、iframes、Comet、Multipart XHR</div><div>2.XHR会缓存GET请求</div><div>3.动态脚本注入：能跨域请求数据。利用js创建一个新的脚本标签，并设置它的src为不同域的URL。只能用GET，不能设置请求的超时处理或重试，必须等待所有的数据都已返回，不能访问请求的头信息也不能把整个响应消息作为字符串来处理，响应消息作为脚本标签的源码必须是可执行的JS代码不能使用纯XML、纯JSON等其他格式的数据。</div><div>4.multipart XHR：比较复杂，获得的资源不能被浏览器缓存；适用于：页面包含了大量其他地方用不到的资源，尤其是图片，网站已经在每个页面中使用一个独立打包的JS或CSS文件。</div><div><br/></div><div><b>B.发送数据</b></div><div>1.两种方式：XHR和信标（beacons）</div><div>2.信标：(new Image()).src=url+”?”+params.join(‘&amp;’);无法发送POST，可以接收数据，但只局限于非常少的几种方式：监听Image对象的load事件，或者检查服务器返回的图片的宽度或高度（如果返回的是图片）</div><div>3.如果信标不需要在响应中返回数据，就应该发送一个不带消息正文的204 No Content状态码</div><div><br/></div><div><b>C.数据格式</b></div><div>1.XML：很慢，效果不好，已经逐步淘汰</div><div>2.JSON：属性名缩短或去掉属性名可以更优化；使用eval很危险，应该使用JSON.parse()</div><div>3.在使用动态脚本注入时，JSON数据被当成另一个JS文件并作为原生代码执行。因此这些数据必须封装在一个回调函数里，这就是所谓的JSON填充（JSON with padding）或JSON-P</div><div>4.JSON-P必须是可很执行的JS，它可能被任何人调用并使用动态脚本注入技术插入到任何网站。JSON在eval前是无效的JS，使用XHR时它只是被当作字符串获取。敏感数据不要编码在JSON-P中</div><div>5.使用JSON和自定义字符分隔符的方式进行数据传递最好，数据格式越轻量速度越快越好</div><div><br/></div><div><b>D.Ajax性能指南</b></div><div>1.在服务端，设置HTTP头信息以确保你的响应会被浏览器缓存</div><div>2.在客户端，把获取到的信息存储到本地，从而避免再次请求</div><div><br/></div><div><b><font style="font-size: 24px;">八、编程实践</font></b></div><div><b>A.避免双重求值（Double Evaluation）</b></div><div>当你在JS代码中执行另一段JS代码时，都会导致双重求值的性能消耗。如eval()、Function()、setTimeout()、setInterval()</div><div><br/></div><div><b>B.使用Object/Array直接量</b></div><div>如var myObject = {……}或var myArray = [……]</div><div><br/></div><div><b>C.避免重复工作</b></div><div>1.延迟加载：方法在第一次调用时，会先检查并决定使用哪种方法去绑定或取消绑定事件处理器，然后原始函数被包含正确操作的新函数覆盖。</div><div>2.条件预加载：它会在脚本加载期间提前检测，而不会等到函数被调用。</div><div><br/></div><div><b>D.使用速度快的部分</b></div><div>1.位操作</div><div>2.原生方法：比如Math、querySelector()、querySelectorAll()等</div><div><br/></div><div>/gaoxingnengjs/8.js<br/></div><div><br/></div><div><b><font style="font-size: 24px;">九、构建并部署高性能JavaScript应用</font></b></div><div><b>A.预处理JavaScript文件</b></div><div>1.在计算机科学中，预处理器是在程序中处理输入数据，产生能用来输入到其他程序的数据的程序。输出被称为输入数据预处理过的形式，常用在后来的程序 中，比如编译器。</div><div><br/></div><div><b>B.JavaScript压缩</b></div><div>JsMin、YUI Compressor、Closure Compiler</div><div><br/></div><div><font style="font-size: 24px;"><b>十、工具</b></font></div><div>通过工具查看优化减少调用HTTP的次数和耗费的时间</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 