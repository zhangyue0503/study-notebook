<html>
<head>
  <title>JavaScript编程精解</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="2019"/>
<h1>JavaScript编程精解</h1>

<div>
<span><div><b><font style="font-size: 24px;">一、值、类型和运算符</font></b></div><div><br/></div><div><b>A.值</b></div><div>1.为了能够顺利操作非常多的位数据而又不引起数据丢失，我们可以将这些位划分成表示不同信息的块，在JS中，我们将这些数据块称为值。</div><div>2.6种基本的值类型：数字（number）、字符串（string）、布尔值（boolean）、对象（object）、函数（function）和未定义类型（undefined）</div><div><br/></div><div><b>B.数字</b></div><div>1.在JS中实际 可存储的数字范围是1900万亿，可以使用带e（指数）的科学技术法，2.998e8=2.99800000</div><div>2.使用小数时精度不高</div><div>3.JS中三个特殊的值：Infinity、-Infinity和NaN，前两个表示无穷大和负无穷大，NaN表示“非数值”</div><div><br/></div><div><b>C.一元运算符</b></div><div>1.使用两个值的运算符称为二元运算符，而使用一个值的则称为一元运算符。减号运算符即可用作一元运算符，也可用作二元运算符</div><div><br/></div><div><b>D.未定义值</b></div><div>1.null和undefined，用于表示无意义的值。它们各自表示其自身含义，除些之外不包含任何信息。</div><div><br/></div><div><b>E.自动类型转换</b></div><div>1.当有些值无法显式地转换成数字（比如“five”或undefined），就会产生NaN。请检查一下是否发生了错误的类型转换。</div><div>2.||当左侧值可以被转换成true时，会直接返回左侧的值，否则会返回右侧的值。所以这个符号的这种功能可用于返回默认值。</div><div>3.&amp;&amp;当左侧的值可以被转换成false时，&amp;&amp;运算符会返回左侧值，不由返回右侧值</div><div>4.短路计算：||和&amp;&amp;只有必要时才会计算右侧的表达式。</div><div><br/></div><div>/eloquentjs/1.html</div><div><br/></div><div><b><font style="font-size: 24px;">二、程序结构</font></b></div><div><br/></div><div><b>A.变量</b></div><div>1.变量并不包含值，而是会引用这些值：两个不同的变量可以引用相同的值。</div><div><br/></div><div><b>B.环境</b></div><div>我们将给定时间内的变量和变量值的集合称为环境。</div><div><br/></div><div>/eloquentjs/2.html</div><div><br/></div><div><b>三、函数</b></div><div><br/></div><div><b>A.词法作用域</b></div><div>任何外部作用域都可以访问到包含它的臂部作用域的变量。函数内部变量的可见性取决于函数在代码当中的位置。在包含了一个函数定义的代码块中，这个函数可以访问到代码块中的所有变量，即函数上层的代码块中的变量和函数内部的变量。这种控制变量可见性的方法称为词法作用域（lexical scoping）</div><div><br/></div><div><b>B.调用栈</b></div><div>每当函数调用时，当前 的上下文信息就会被存储在栈顶。而当函数返回时，系统会删除存储在栈顶的上下文信息，并使用该信息继续执行程序</div><div><br/></div><div><b>C.闭包</b></div><div>一个包装了一些局部变量的函数是一个闭包。</div><div><br/></div><div><b>D.递归</b></div><div>在标准的JS实现当中，递归写法的函数执行效率比循环写法的函数慢了大约10倍。执行简单的循环操作比多次函数调用效率要高很多。若程序处理的概念非常复杂，为了确保程序简单易懂，牺牲一定效率也的确是一种明智的选择。除非程序执行速度确实太慢，否则先不要关注效率问题。</div><div><br/></div><div><b>E.函数及其副作用</b></div><div>相比于直接产生副作用的函数，产生返回值的函数则更容易集成到新的环境当中使用</div><div><br/></div><div>/eloquentjs/3.html<br/></div><div><br/></div><div><b>四、数据结构：对象和数组</b></div><div><br/></div><div><b>A.JS中两种最为常用的访问属性的方法：</b>使用点（.）和方括号[]。如果使用点，则点之后的部分必须 是一个合法变量名，即直接写属性名称。如果使用方括号，则JS会将方括号中表达式的返回值作为属性名称。</div><div><br/></div><div><b>B.可以使用in操作符来确定对象中是否包含特定名称的属性</b></div><div><br/></div><div>/eloquentjs/4.html<br/></div><div><br/></div><div><b><font style="font-size: 24px;">五、高阶函数</font></b></div><div><br/></div><div><b>A.高阶函数</b></div><div>1.如果一个函数操作其他函数，即将其他函数作为参数或将函数作为返回值，那么我们可以将其称为高阶函数。</div><div><br/></div><div><b>B.map函数</b></div><div>Map方法可以对数组中的每个元素调用函数，然后利用返回值来构建一个新的数组，实现转换数组的操作。</div><div><br/></div><div>/eloquentjs/5.html<br/></div><div><br/></div><div><b><font style="font-size: 24px;">六、深入理解对象</font></b></div><div><br/></div><div><b>A.方法</b></div><div>在调用object.method()时，对象中的一个特殊变量this会指向当前方法所属的对象</div><div><br/></div><div><b>B.原型</b></div><div>1.当开发人员访问一个对象不包含的属性时，就会从对象原型中搜索属性，接着是原型的原型，依此类推。空对象的原型是Object.prototype。</div><div>2.许多对象会提供自己通过特殊原型来提供对象自己的默认属性。函数继承自Function.prototype，数组继承自Array.prototype等。</div><div>3.Object.getPrototypeOf函数返回的结果是对象原型。可以利用一个特定的原型来使用Object.create方法创建对象</div><div><br/></div><div><b>C.构造函数</b></div><div>1.在JS中，调用函数之前使用new则表示调用其构造函数</div><div>2.构造函数中包含了指向新对象的变量this，除非构造函数显式地返回了另一个对象的值，否则构造函数会返回这个新创建的对象</div><div>3.通过关键字new创建的对象称之为构造函数的实例</div><div>4.构造函数其实就是函数，因此其实际原型是Function.prototype，而构造函数的prototype属性则是其所创建的实例的原型，而非构造函数自身的原型</div><div><br/></div><div><b>D.覆盖继承的属性</b></div><div>如果原型中存在同名属性，那么在调用该属性时，就不会再调用原型中的那个属性了，转而调用我们添加到对象中的属性。但原型本身不会被修改。</div><div><br/></div><div><b>E.原型污染</b></div><div>1.可以使用Object.defineProperty函数定义自己的不可枚举属性，该函数允许我们在创建属性时控制属性类型</div><div>2.使用对象的hasOwnProperty方法确定自身是否包含某个属性而不会搜索原型。</div><div><br/></div><div><b>F.无原型对象</b></div><div>可以使用Object.create(null)来创建</div><div><br/></div><div><b>G.多态</b></div><div><br/></div><div><b>H.Getter与Setter</b></div><div><br/></div><div><b>I.继承</b></div><div>instanceof运算符会遍历所有继承类型</div><div><br/></div><div>/eloquentjs/6.html<br/></div><div><br/></div><div><b><font style="font-size: 24px;">项目实战：构建电子生态系统</font></b><br/></div><div><br/></div><div>/eloquentjs/7.html<br/></div><div><br/></div><div><b><font style="font-size: 24px;">八、处理缺陷与错误</font></b></div><div><br/></div><div><b>A.严格模式</b></div><div>当启用了严格模式（strict mode）后，JS就会在执行代码时变得更为严格。只需在文件或函数顶部放置字符串“use strict”就可以启用严格模式了。</div><div><br/></div><div><b>B.异常</b></div><div>1.异常是一种当代码执行中遇到问题时，可以触发（或抛出）异常的机制，异常只是一个普通的值。触发异常类似于从函数中强制返回：异常不只跑出到当前函数中，还会跳出函数调用方，走到当前执行流初次调用函数的位置。这种方式被称为“堆栈展开(Unwinding the Stack)”。</div><div>2.异常真正强大的地方在于你可以在堆栈上设置一个“障碍物”，当异常缩减堆栈到达这个位置时会被捕获。接着你就可以对异常进行一些处理，并使得程序从异常捕获点开始继续执行。</div><div><br/></div><div>/eloquentjs/8.html<br/></div><div><br/></div><div><b><font style="font-size: 24px;">九、正则表达式</font></b></div><div><br/></div><div>1.exec方法，如果无法匹配模式则返回null，否则返回一个表示匹配字符串信息的对象。字符串也有个match方法</div><div>2.字符串replace，第二个参数可以用函数</div><div>3.//gi，g表示全局，i表示不分大小写</div><div><br/></div><div>/eloquentjs/9.html<br/></div><div><br/></div><div><b><font style="font-size: 24px;">十、模块</font></b></div><div><br/></div><div><b>A.模块的好处</b></div><div>1.模块根据一些标准将程序划分为不同的代码块，每份代码都自成一个整体。</div><div>2.设计良好的模块可以提供外部代码访问所需的接口。定义良好的模块接口可以确保旧接口在模块更新后保持不变。对外提供的接口应该具有统一和内聚的特性。</div><div><br/></div><div><b>B.使用函数作为命名空间</b></div><div>1.为了防止模块内部使用的变量会污染全局命名空间，我们将该模块包裹在函数中。</div><div>2.将命名空间函数放在一对圆括号中：如果表达式使用关键字function开头，表明这是一个函数表达式。但如果一个语句使用function开头，则将该语句看成一个需要函数名的函数声明，而非一个表达式，也就是说，我们无法在语句后面添加括号来调用该函数。</div><div><br/></div><div><b>C.使用对象作为接口</b></div><div>对于代码量比较大的模块来说，定义一个对象，并在定义完需要导出的某些元素时，将这些元素添加到该对象的属性中。</div><div><br/></div><div><b>D.与全局作用域分离</b></div><div>构造一个require函数，调用该函数时指定一个模块名称，该函数会装载模块文件（依赖于我们运行的平台）并返回合适的接口对象</div><div><br/></div><div><b>E.将数据作为代码执行</b></div><div>不推荐eval，使用new Function(“参数名列表”,“函数体”)</div><div><br/></div><div><b>F.接口设计</b></div><div>1.可预测性</div><div>2.可组合性</div><div>3.层次化接口</div><div><br/></div><div>/eloquentjs/10.html<br/></div><div><br/></div><div><b><font style="font-size: 24px;">项目实战：开发编程语言</font></b></div><div><br/></div><div>/eloquentjs/11.html<br/></div><div><br/></div><div><b><font style="font-size: 24px;">十二、文档对象模型</font></b></div><div><br/></div><div>/eloquentjs/12.html<br/></div><div><br/></div><div><b><font style="font-size: 24px;">十三、处理事件</font></b></div><div><br/></div><div><b>A.事件与DOM节点</b></div><div>addEventListener；removeEventListener；</div><div><br/></div><div><b>B.传播</b></div><div>1.若段落和按扭都有事件处理器，则先执行最特殊的事件处理器（按扭的事件处理器）。也就是说事件向外传播，从触发事件的节点到其父节点，最后直到文档根节点。最后，当某个特定节点上注册的所有事件处理器按其顺序全部执行完毕后，窗口对象的事件处理器才有机会响应事件。</div><div>2.事件处理器任何时候都可以调用事件对象的stopPropagation方法，阻止事件进一步传播。</div><div>3.可以使用target属性来创建出特定类型事件的处理网络。event.target.textContent</div><div><br/></div><div><b>C.默认动作</b></div><div>调用event.preventDefault，不执行默认的动作</div><div><br/></div><div><b>D.焦点事件</b></div><div>focus和blur事件，不会传播！</div><div><br/></div><div><b>E.脚本执行时间线</b></div><div>1.即使任何时候都可以触发事件，但同一文档中无法同时执行两个脚本。若一个脚本已经在运行，事件处理器和使用其他方法调度的代码会使该脚本等待执行。</div><div>2.若想放到后台进行，同时防止页面无响应，可以使用浏览器提供的Web Worker。</div><div><br/></div><div><b>F.定时器</b></div><div>setTimeout，一定时间后执行，clearTimeout</div><div>setInterval，每隔一定时间循环执行，clearInterval</div><div>利用setTimeout可以进行事件降频</div><div><br/></div><div>/eloquentjs/13.html<br/></div><div><br/></div><div><b><font style="font-size: 24px;">项目实战：平台游戏</font></b></div><div><br/></div><div>/eloquentjs/14.html<br/></div><div><br/></div><div><b><font style="font-size: 24px;">十四、使用canvas绘图</font></b></div><div><br/></div><div><b>A.SVG</b></div><div>1.可缩放矢量图形，专用于描述图形文档而非描述文字文档，保存了对于聊天挖墙脚的基本信息的描述，可以随时移动或修改图像。</div><div><br/></div><div><b>B.canvas元素</b></div><div>1.用于绘制二维图形的“2d”与通完openGL接口绘制三维图形的“webgl”</div><div>2.filleStyle决定了图形的填充方式</div><div>3.strokeStyle和lineWidth用来控制线条的绘制方式</div><div>4.fillRect和strokeRect来绘制矩形</div><div>5.fillText和strokeText绘制文字</div><div>6.beginPath创建一个新的路径，lineTo方法画一条直线，路径画完时可以使用fill填充或stroke勾勒轮廓</div><div>7.drawImage从一张图片或另一个画面上移动像素到我们的画布上</div><div>8.translate、scale与rotate进行图形变换，一个变换的状态可以通过save来保存，通过restore来恢复</div><div>9.clearRect可以在绘制动画时，清除画布的某一部分</div><div><br/></div><div><b>C.选择图像接口</b></div><div>1.SVG可以被用来制造可以做任意缩放而仍然清晰的图像。比单纯的HTML更加难以使用，但是更加强大。</div><div>2.画布的基于像素的方法在需要绘制大量的微小元素时会有优势，不会构建新的数据结构 而是仅仅重复的在同一个像素上绘制，使得画布在每个图形上拥有更低的消耗。</div><div><br/></div><div>/eloquentjs/14.html<br/></div><div>/eloquentjs/15.html<br/></div><div><br/></div><div><b><font style="font-size: 24px;">十五、HTTP协议概述</font></b></div><div><br/></div><div><b>A.XMLHttpRequest对象</b></div><div><b><br/></b></div><div><b>B.HTTP沙箱</b></div><div>请求头中包含Access-Control-Allow-Origin:*告诉其他域名发送请求是没问题的</div><div><br/></div><div><b>C.Promise断言</b></div><div><br/></div><div>/eloquentjs/16.html<br/></div><div><br/></div><div><b><font style="font-size: 24px;">十六、表单和表单域</font></b></div><div><br/></div><div><b>A.聚焦</b></div><div>在document.activeElement中的值会关联到当前聚焦的元素。通过focus和blur方法来控制聚焦</div><div><br/></div><div><b>B.作为整体的表单</b></div><div>1.当一个域被包含在&lt;form&gt;元素中时，其DOM元素会有一个form属性指向form的DOM元素，&lt;form&gt;元素则会有一个叫作elements属性包含一个类似于数据的集合，其中包含全部的域</div><div>2.submit方法可以调用事件对象的preventDefault来禁用默认行为</div><div><br/></div><div><b>C.文本域</b></div><div>selectionStart和selectionEnd属性包含光标和所选文字的信息。当没有选中文字时，这两个属性的值相同，表明当前光标的信息。当一部分域被选中时，这两个你属性值会不同，表明文字开始位置和结束位置</div><div><br/></div><div><b>D.选择域</b></div><div>multiple可以多选，size用来设置同时可展示的选项，设置3显示3行，与multiple无关。&lt;select&gt;域有类似于数组的options属性</div><div><br/></div><div><b>E.客户端保存数据</b></div><div>localStorage和sessionStorage，sessionStorage会在浏览器关闭时结束</div><div><br/></div><div>/eloquentjs/17.html<br/></div><div><br/></div><div><b><font style="font-size: 24px;">项目实战：绘图程序</font></b></div><div><br/></div><div>/eloquentjs/18.html<br/></div><div><br/></div><div><b><font style="font-size: 24px;">十七、Node.js</font></b></div><div><b>A.node命令</b></div><div>1.变量process是Node中的全局变量，提供了process.exit方法（结束进程），process.argv（获取传递给脚本的命令行参数）</div><div>2.与浏览器相关的功能，如document与alert不存在在node中</div><div>3.全局作用域对象在浏览器中名为window，而在Node中则名为global</div><div><br/></div><div><b>B.文件系统模块</b></div><div>1.fs：readFIle()、writeFile()、readdir()将目录中的文件以字符串数组的方式返回、stat函数用于获取文件信息、rename用于重命名、unlink用于删除</div><div>2.fs模块中的许多函数都有异步与同步的两种变体，如readFile的同步函数为readFileSync</div><div><br/></div><div><b>C.流</b></div><div>1.可写流：所有的可写流都有一个write方法，可以传递字符串或Buffer对象。可写流的end方法用于关闭流，如果 线定一个参数，该方法会在关闭流前输出指定的一段数据。这两个方法都可以使用一个回调函数作为额外参数，当写入数据或关闭流完成后，会调用用户指定的回调函数。</div><div>2.可读流：data事件在每次数据到来时触发，end事件在流结束时触发。</div><div><br/></div><div>/eloquentjs/19.js<br/></div><div>/eloquentjs/19-1.js<br/></div><div>/eloquentjs/19-2.js<br/></div><div>/eloquentjs/garble.js<br/></div><div><br/></div><div><b><font style="font-size: 24px;">项目实战：技能分享网站</font></b></div><div><br/></div><div>/eloquentjs/router.js<br/></div><div>/eloquentjs/20.js<br/></div><div>/eloquentjs/public/*<br/></div><div><br/></div><div><b><font style="font-size: 24px;">十八、JavaScript和性能</font></b></div><div><br/></div><div>1.性能分析器：Chrome的Profiler</div><div>2.函数内联：函数内联通过许多方法来回忆代码运行速度。在机器级别，函数和方法需要使用一定的协议调用。</div><div>3.交叉编译：当编译热点函数时，该函数已经执行过了许多次。如果在这些执行过程中，每次都调用同一个函数，那么内联该函数就是合理的。</div><div>4.没有任何JS引擎能够内联forEach调用。可以使用传统的for循环来取代forEach</div><div>5.为什么对象如此昂贵呢？一是引擎需要寻找位置来有些话对象，二是引擎需要分别看v化学成分全局再也不需要使用而应该进行垃圾回收。Chrome使用世代型垃圾回收机制（Generational Garbage Collection）</div><div>6.如果你希望一段代码执行得足够快，那么最好保持类型一致。</div><div><br/></div><div>/eloquentjs/21.js<br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 