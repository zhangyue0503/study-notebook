<html>
<head>
  <title>PHP大神班-Laravel框架</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="2260"/>
<h1>PHP大神班-Laravel框架</h1>

<div><span><div><span style="font-size: 24px; font-weight: bold;">一、设计模式（一）</span></div><div><span style="font-weight: bold;">1.面向对象原则</span></div><ul><li><div>1）单一职责</div></li><li><div>2）开放封闭</div></li><li><div>3）LSP里氏替换</div></li><ul><li><div>php有继承链</div></li><li><div>A-&gt;B-&gt;C-&gt;D，A可以使用D的方法，D也可以调用A的方法</div></li></ul><li><div>4）DIP依赖倒转：子类和父类可以互换</div></li><li><div>5）ISP接口隔离：自己干自己的事情</div></li><li><div>6）合成/聚合复用：少用继承，多用接口类去搞定</div></li><li><div>7）PLK迪米特法则最少知识：一个对象对其他对象尽可能少的了解，降低依赖性</div></li></ul><div><span style="font-weight: bold;">2.设计模式的目的</span></div><ul><li><div>1）代码复用</div></li><li><div>2）增加可维护性</div></li></ul><div><span style="font-weight: bold;">3.PHP的设计模式</span></div><ul><li><div>1）设计模式为了弥补语言的不足，每个语言不一样，有些设计模式在PHP中不需要实现（不到23种）</div></li><li><div>2）创建型模式</div></li><ul><li><div>single，单例模式</div></li><li><div>Abstract factory，抽象工厂</div></li><li><div>建造者模式</div></li><li><div>factory，工厂</div></li><li><div>原型模式</div></li></ul><li><div>3）结构型模式</div></li><ul><li><div>适配器模式</div></li><li><div>桥接模式</div></li><li><div>装饰模式</div></li><li><div>组合模式</div></li><li><div>外观模式</div></li><li><div>享元模式</div></li><li><div>代理模式</div></li></ul><li><div>4）行为型模式</div></li><ul><li><div>模板方法模式</div></li><li><div>命令模式</div></li><li><div>迭代器模式</div></li><li><div>观察者模式</div></li><li><div>中介者模式</div></li><li><div>策略模式</div></li></ul></ul><div><span style="font-weight: bold;">4.Laravel中的设计模式</span></div><ul><li><div>1）Facade门面模式</div></li><li><div>2）IoC和DI，服务容器和依赖注入</div></li><li><div>3）Pipeline，管道</div></li></ul><div><span style="font-weight: bold;">5.Facade门面模式</span></div><ul><li><div>1）基础知识：魔术方法、静态延迟绑定</div></li></ul><div><img src="PHP大神班-Laravel框架_files/门面模式-facade.png" type="image/png" data-filename="门面模式-facade.png"/><br/></div><ul><li><div>2）目的：为了实现代码的解耦</div></li><li><div>3）解决：每使用一个类都要use命名空间，然后实例化类</div></li></ul><div><img src="PHP大神班-Laravel框架_files/Image.png" type="image/png" data-filename="Image.png"/><br/></div><ul><li><div>4）Support/Facades中各类中的getFacadeAccessor方法，返回的是config/app.php中的aliases里面的别名，所以也可以使用完整路径</div></li><ul><li><div>Support/Facades/redis.php</div></li></ul></ul><div><img src="PHP大神班-Laravel框架_files/Image [1].png" type="image/png" data-filename="Image.png"/><br/></div><ul><ul><li><div>config/app.php中的aliases</div></li></ul></ul><div><img src="PHP大神班-Laravel框架_files/Image [2].png" type="image/png" data-filename="Image.png"/><br/></div><ul><li><div>5）<span style="color: rgb(255, 38, 0); font-weight: bold;">*</span>继承的Support/Facades/Facade类中，核心的__callStatic方法</div></li></ul><div><img src="PHP大神班-Laravel框架_files/Image [3].png" type="image/png" data-filename="Image.png"/><br/></div><div>6）使用门面：更加优雅，其实与使用app(‘redis’)一样的，Redis::get()==app(‘redis’)-&gt;get()</div><div>7）官方话术：外部与一个子系统的通信，必须通过一个统一的外观对象进行，为子系统的一组接口，提供一个一致的界面</div><div><img src="PHP大神班-Laravel框架_files/Image [4].png" type="image/png" data-filename="Image.png"/><br/></div><div>8）就是将实例化代码集中在一个类中，如果不使用 __callStatic魔术方法，将导致这个文件非常臃肿，参考：Laravel/1facade/</div><div><span style="font-weight: bold;">6.控制反转、依赖注入</span></div><ul><li><div>1）基础知识：AOP</div></li><li><div>2）IoC容器</div></li></ul><div><img src="PHP大神班-Laravel框架_files/Image [5].png" type="image/png" data-filename="Image.png"/><br/></div><ul><li><div>3）依赖倒置</div></li></ul><div><img src="PHP大神班-Laravel框架_files/Image [6].png" type="image/png" data-filename="Image.png"/><br/></div><ul><li><div>4）角色构成：IoC/DI容器，某个对象，对象的外部资源</div></li></ul><div><img src="PHP大神班-Laravel框架_files/Image [7].png" type="image/png" data-filename="Image.png"/><br/></div><ul><li><div>5）AOP简单理解：抽取公共部分</div></li></ul><div><img src="PHP大神班-Laravel框架_files/Image [8].png" type="image/png" data-filename="Image.png"/><br/></div><ul><li><div>6）laravel控制器$request核心注入：call_user_func_array()</div></li></ul><div><img src="PHP大神班-Laravel框架_files/Image [9].png" type="image/png" data-filename="Image.png"/><br/></div><ul><li><div>7）<span style="color: rgb(255, 38, 0); font-weight: bold;">*</span>laravel容器核心，反射，Container.php/build方法</div></li></ul><div><img src="PHP大神班-Laravel框架_files/Image [10].png" type="image/png" data-filename="Image.png"/><br/></div><ul><li><div>8）Laravel/2ioc</div></li></ul><div><br/></div><div><span style="font-size: 24px; font-weight: bold;">二、设计模式（二）</span></div><div><span style="font-weight: bold;">1.简单工厂模式、工厂模式</span></div><ul><li><div>1）简单工厂模式：由一个工厂对象来决定创建哪一种产品类的实例</div></li><ul><li><div>优点：明确了业务代码和工厂类的职责和权限</div></li><li><div>缺点：大量的实例的创建逻辑，违反了高内聚责任分配原则，每次新增加一个类型，需要修改工厂类</div></li></ul></ul><div><img src="PHP大神班-Laravel框架_files/Image [11].png" type="image/png" data-filename="Image.png"/><br/></div><ul><li><div>2）Laravel/3easyfactory</div></li></ul><div><span style="font-weight: bold;">2.装饰器模式</span></div><ul><li><div>1）装饰器：不改变原类文件和使用继承的情况下，动态的扩展一个对象的功能</div></li></ul><div><img src="PHP大神班-Laravel框架_files/Image [12].png" type="image/png" data-filename="Image.png"/><br/></div><div><img src="PHP大神班-Laravel框架_files/Image [13].png" type="image/png" data-filename="Image.png"/><br/></div><div><img src="PHP大神班-Laravel框架_files/Image [14].png" type="image/png" data-filename="Image.png"/><br/></div><div><span style="font-weight: bold;">3.观察者模式</span></div><ul><li><div>1）观察者：当主体对象状态发生变化的时候，通知所有的观察者对象，让观察者自动更新自己</div></li></ul><div><img src="PHP大神班-Laravel框架_files/观察者模式.png" type="image/png" data-filename="观察者模式.png"/><br/></div><div><img src="PHP大神班-Laravel框架_files/Image [15].png" type="image/png" data-filename="Image.png"/><br/></div><ul><li><div>2）目的：基于类的单一性设计原则，观察者模式主要是划定模块之间的界限，提高代码的可维护性和重用性</div></li><li><div>3）使用场景：执行一系列业务动作</div></li><li><div>4）Laravel/5observe</div></li></ul><div><img src="PHP大神班-Laravel框架_files/Image [16].png" type="image/png" data-filename="Image.png"/><br/></div><div><span style="font-weight: bold;">4.适配器模式</span></div><ul><li><div>1）Laravel中路由</div></li></ul><div><img src="PHP大神班-Laravel框架_files/适配器模式.png" type="image/png" data-filename="适配器模式.png"/><br/></div><div><span style="font-weight: bold;">5.迭代器模式</span></div><ul><li><div>1）迭代器（游标）：结合容器（container）使用</div></li><ul><li><div>迭代器角色（Iterator）：负责定义访问和遍历元素的接口</div></li><li><div>具体迭代器角色（ConcreteIterator）：具体实现迭代器，记录遍历的当前位置</div></li><li><div>容器（container）：负责创建具体迭代器角色接口</div></li><li><div>具体容器角色（concrete container）：具体实现</div></li></ul></ul><div><img src="PHP大神班-Laravel框架_files/迭代器模式.png" type="image/png" data-filename="迭代器模式.png"/><br/></div><ul><li><div>2）使用场景：为不同的遍历方式实现统一的接口</div></li></ul><div><br/></div><div><span style="font-size: 24px; font-weight: bold;">三、设计模式（三）</span></div><div><span style="font-weight: bold;">1.原型模式</span></div><ul><li><div>1）类图</div></li></ul><div><img src="PHP大神班-Laravel框架_files/原型模式.png" type="image/png" data-filename="原型模式.png"/><br/></div><ul><li><div>2）js中的原型：在原本的JS对象基础上增加方法</div></li><li><div>3）原型模式：从一个对象创建另外一个可定制的对象，不需要知道创建的细节（请求原型来创建对象）（申明一个自身克隆的接口）</div></li><li><div>4）php中对象是一个引用类型，想要生成新的对象，要用__clone()方法，clone $obj时会执行__clone()</div></li><li><div>5）Laravel中大量使用：</div></li><ul><li><div>vendor/symfony/http-foundation/Request.php</div></li><li><div>vendor/symfony/http-kernel/Kernel.php</div></li><li><div>vendor/laravel/framework/src/Illuminate/Cache/Repository.php</div></li></ul><li><div>6）优点：</div></li><ul><li><div>创建新对象不用去再construct，提高性能</div></li><li><div>逃避构造方法的约束</div></li></ul><li><div>7）缺点：</div></li><ul><li><div>当引用不支持串行化的间接对象（反序列化类的时候必须包含源类）</div></li><li><div>必须实现__clone()</div></li></ul><li><div>8）使用场景</div></li><ul><li><div>类初始化需求消耗大量资源</div></li><li><div>一个对象要被多个地方使用并进行修改</div></li><li><div>结合工厂模式使用</div></li></ul></ul><div><span style="font-weight: bold;">2.命令链模式</span></div><ul><li><div>1）类图</div></li></ul><div><img src="PHP大神班-Laravel框架_files/命令模式.png" type="image/png" data-filename="命令模式.png"/><br/></div><ul><li><div>2）两步</div></li><ul><li><div>关系的绑定</div></li><li><div>命令执行</div></li></ul><li><div>3）命令模式：如何将“行为请求者”和“行为实现者”解耦，将一组行为抽象为对象，实现二者的松耦合</div></li><li><div>4）特点：行为请求者不需要知道行为实现者具体的实现时间、执行的情况</div></li><li><div>5）使用场景</div></li><ul><li><div>进行队列请求的时候</div></li><li><div>需要支持命令的撤销和恢复操作</div></li></ul><li><div>6）四个步骤</div></li><ul><li><div>client创建一个ConcreteCommand对象并指定他的Receiver对象</div></li><li><div>Invoker对象存储该ConcreteCommand对象</div></li><li><div>通过Command对象的Execute来提交请求，该请求是可撤销的</div></li><li><div>ConcreteCommand对象调用注入的Receiver的action方法完成该请求的执行</div></li></ul></ul><div><span style="font-weight: bold;">3.策略模式</span></div><ul><li><div>1）策略模式：对一系列算法的定义，将多个算法单一的封装起来，让它们可以相互替换</div></li><li><div>2）类图</div></li></ul><div><img src="PHP大神班-Laravel框架_files/策略模式.png" type="image/png" data-filename="策略模式.png"/><br/></div><ul><li><div>3）两步</div></li><ul><li><div>实例化上下文对象（哪个算法）</div></li><li><div>实现具体代码的执行</div></li></ul><li><div>4）本质上就是一个判断</div></li><li><div>5）使用场景：结合工厂模式使用</div></li><li><div>6）角色</div></li><ul><li><div>角色1：抽象策略角色：抽象类</div></li><li><div>角色2：具体策略角色：包装了相关的算法与行为</div></li><li><div>角色3：环境角色：策略类的引用</div></li></ul></ul><div><span style="font-weight: bold;">4.责任链（管道）模式</span></div><ul><li><div>1）Linux的管道：最基本的IPC机制</div></li><li><div>2）Fork：父进程创建出一个和父进程相同的子进程，fd[0]读，fd[1]写，父子进程通过pipe通信</div></li><li><div>3）类图</div></li></ul><div><img src="PHP大神班-Laravel框架_files/管道模式.png" type="image/png" data-filename="管道模式.png"/><br/></div><ul><li><div>4）概念：将数据传递给一个任务队列，由任务队列按照次序对数据进行加工处理（HTTP请求的中间件）</div></li><li><div>5）贯穿Laravel路</div></li><ul><li><div>pipeline类：send载入请求数据、through加载中间件、then向管道发起请求</div></li></ul><li><div>6）优点</div></li><ul><li><div>将复杂的处理流程分解为独立的子任务，子任务之间相互不会受到影响</div></li><li><div>针对不同的http请求，采用不同的子任务组合来处理</div></li><li><div>在复杂的进程中CUD子任务非常轻松，对现有的进程没有任何影响</div></li></ul><li><div>7）缺点：增加了代码的复杂性，不利于理解整个流程</div></li></ul><div><br/></div><div><span style="font-size: 24px; font-weight: bold;">四、Laravel基础（一）</span></div><div><span style="font-weight: bold;">1.代码加载原理</span></div><ul><li><div>目录结构基于PSR规范</div></li><li><div>配置composer.json文件的加载规则（PSR-1、PSR-4、别名的加载）</div></li><li><div>composer dump-autoload：刷新composer缓存文件</div></li></ul><div><span style="font-weight: bold;">2.助手文件加载（直接加载文件配置）</span></div><div><img src="PHP大神班-Laravel框架_files/Image [17].png" type="image/png" data-filename="Image.png"/><br/></div><div><span style="font-weight: bold;">3.根目录文件</span></div><ul><li><div>1）.env，环境变量，主配置文件，php从getenv()中获取全局环境变量，.env文件相当于添加到环境变量中，参考phpinfo()</div></li><li><div>2）artisan，命令行工具（辅助开发）</div></li><li><div>3）package.json、webpack.mix.js，前端组件工具</div></li></ul><div><span style="font-weight: bold;">4.目录结构</span></div><div><img src="PHP大神班-Laravel框架_files/app目录结构.png" type="image/png" data-filename="app目录结构.png"/><br/></div><ul><li><div>1）App，应用程序的主要开发目录，默认有的文件夹不要修改名字</div></li><ul><li><div>console、http、provides，Laravel核心的api</div></li><li><div>Kernel，核心文件，重要</div></li><li><div>http，路由请求相关文件，控制器，中间件</div></li><li><div>Provides，服务提供者</div></li></ul><li><div>2）Routes</div></li><ul><li><div>web.php，默认路由（渲染模板）</div></li><li><div>api.php，默认Api路由（限速、token认证、直接返数据）</div></li><li><div>console.php，控制台命令的闭包，和命令行交互</div></li><li><div>channls.php，事件broadcast，用来注册事件广播</div></li></ul><li><div>3）bootstrap：启动程序，引导程序，框架的引导文件</div></li><ul><li><div>app.php，引导程序</div></li><li><div>Cache/，缓存生成</div></li></ul><li><div>4）config，配置文件</div></li><li><div>5）database，数据迁移目录、数据填充</div></li><ul><li><div>php artisan make:migration create_表名_table</div></li><li><div>低版本的mysql要加入</div></li></ul></ul><div><img src="PHP大神班-Laravel框架_files/Image [18].png" type="image/png" data-filename="Image.png"/><br/></div><ul><li><div>6）public，公共入口文件</div></li><ul><li><div>伪静态文件</div></li><li><div>静态资源文件</div></li><li><div>网站信息文件：爬虫、ico等</div></li><li><div>index.php，框架入口</div></li></ul><li><div>7）resources，模块资源文件（blade模板引擎）</div></li><li><div>8）storage，编译以后的文件缓存及日志文件等，缓存编译文件目录</div></li><li><div>9）tests，单元测试</div></li><li><div>10）Vendor，第三方组件，composer</div></li></ul><div><span style="font-weight: bold;">5.路由和控制器的加载 </span></div><ul><li><div>1）定义web.php（route::resourcetype）</div></li><ul><li><div>Resourcetype:get、post、put、patch、delete等</div></li></ul><li><div>2）路由分组RouteGroup(['prefix'=&gt;,’namespace’=&gt;,’middleware’=&gt;,’domain’=&gt;……], function(){</div></li><ul><li><div>})</div></li><li><div>prefix：访问的路径，区分大小写</div></li><li><div>namespace：加载控制器文件的命名空间</div></li></ul><li><div>3）::class，获取当前类文件的“绝对路径”带命名空间的绝对路径</div></li><li><div>4）Laravel中，访问的地址和解析的文件路径没有任何关系</div></li></ul><div><br/></div><div><span style="font-size: 24px; font-weight: bold;">五、Laravel基础（二）</span></div><div><span style="font-weight: bold;">1.路由</span></div><ul><li><div>1）没有路由就没有框架</div></li><li><div>2）路由别名、自定义路由、参数类型限定、多模式匹配</div></li><ul><li><div>Route::get(‘/test’,'IndexController@Index')-&gt;name(‘index.index’)；</div></li><li><div>模板中：route(‘index.index’, [‘id' =&gt; 10]);</div></li><li><div>Route::get(‘/params/{id}’,’IndexController@params')-&gt;where([‘id’=&gt;’[0-9]+’]);</div></li><li><div>Route::match([‘get’, ‘post’], ‘/test’, ‘IndexController@Index’)</div></li><li><div>Route::any(’/test’, ‘IndexController@Index')</div></li></ul></ul><div><span style="font-weight: bold;">2.控制器</span></div><ul><li><div>1）在路由表当中可以指定访问哪一个指定的控制器而不是一个闭包</div></li><ul><li><div>控制器放在&lt;project&gt;/app/Http/Controllers目录下</div></li><li><div>文件名：Xx控制器Controller.php</div></li><li><div>注意：单词首字母大写（大驼峰）</div></li><li><div>可以利用artisan命令创建</div></li></ul><li><div>2）artisan命令</div></li><ul><li><div>php artisan make:controller TestController</div></li><li><div>3）修改控制器目录：Providers中的RouteServiceProvider中，如添加mapAdminRoutes()方法，然后加入到map()方法中去</div></li></ul><li><div>4）资源路由：</div></li><ul><li><div>Route::resource(‘rest’, ‘RestController’);</div></li><li><div>指定模型的Reseource控制器：php artisan make:controller RestController —resource —model=User</div></li></ul></ul><div><span style="font-weight: bold;">3.路由模型绑定</span></div><ul><li><div>1）RouteServiceProvider执行路由模型的绑定</div></li><li><div>2）boot()中，$route-&gt;model(‘python|路由名字’, Conference::class|哪一个模型);</div></li><li><div>3）显式、隐式绑定</div></li><ul><li><div>Route::get(‘’, function($id){Conference::method($id)})</div></li><li><div>Route::get(‘’, function(){return view()-&gt;with(’name’, $conference);})</div></li></ul><li><div>4）无控制器下返回数据用</div></li></ul><div><span style="font-weight: bold;">4.控制器与视图</span></div><ul><li><div>1）要在控制器中指定渲染某个视图，则需要使用到view方法，view方法接收两个参数，第一个参数是视图的路径名称，第二个参数是与视图绑定的数据</div></li><li><div>2）视图（view），将视图作为一个独立的组件实现了控制器的解耦，在代码的任何位置都可以使用（view）方法加载一个视图</div></li><li><div>3）指令说明、定界符</div></li><ul><li><div>自定义标签前缀 @</div></li><li><div>为所有的控件结构、继承和任何想要添加的自宝义功能的使用指令</div></li><li><div>定界符：{{ $a }}==echo htmlentities($a)，转义输出</div></li></ul><li><div>4）控制结构</div></li><li><div>5）<span style="color: rgb(255, 38, 0); font-weight: bold;">*</span><span style="font-weight: bold;"> </span>view中变量从controller中的数组导入到符号表（变成变量），Illuminate\View\Engines\PHPEngine中，evaluatePath方法内：<span style="font-weight: bold;">extract</span></div></li><ul><li><div>extract($__data, EXTR_SKIP);</div></li><li><div>EXTR_SKIP，如果有冲突，不覆盖已有的变量</div></li></ul></ul><div><img src="PHP大神班-Laravel框架_files/laravel访问.png" type="image/png" data-filename="laravel访问.png"/><br/></div><div><br/></div><div><span style="font-size: 24px; font-weight: bold;">六、Laravel基础（三）</span></div><div><span style="font-weight: bold;">1.控制器中系统组件的使用：$request、$response对象</span></div><ul><li><div>1）$request：贯穿整个laravel路由，传递信息，依赖注入进控制器</div></li><ul><li><div>表单输入（facade快速引入）— \Support\facades\下面，Request::input()，Input::get()</div></li><li><div>自动实现表单过滤</div></li><li><div>csrf功能</div></li><li><div>相同字段覆盖</div></li><li><div>Input::get()，获取所有的请求参数，包括get、post、put等</div></li></ul><li><div>2）Facades是为了方便修改，所以控制器中xjty的是\Http\Request，内核代码相对更稳定</div></li></ul><div><span style="font-weight: bold;">2.控制器注入</span></div><ul><li><div>1）index(Request $request)</div></li><li><div>2）csrf使用中间件过滤</div></li></ul><div><span style="font-weight: bold;">3.模板foreach中的循环变量，$loop，包含很多迭代循环需要的属性</span></div><ul><li><div>index，循环索引，key值，0开始</div></li><li><div>iteration，从1开始</div></li><li><div>remaining，还有多少项</div></li><li><div>count，总循环数</div></li><li><div>first，是否第一个</div></li><li><div>last，是否最后一个</div></li><li><div>depth，循环层数</div></li><li><div>parent，上层循环的$loop</div></li></ul><div><img src="PHP大神班-Laravel框架_files/Image [19].png" type="image/png" data-filename="Image.png"/><br/></div><div><span style="font-weight: bold;">4.or，在不确定某个变量是否有值的时候，可以设默认值，{{ $username or ‘没内容哦' }}（一般在语言包处理）</span></div><div><span style="font-weight: bold;">5.forelse，循环数组不存在，走empty里面的内容</span></div><div><img src="PHP大神班-Laravel框架_files/Image [20].png" type="image/png" data-filename="Image.png"/><br/></div><div><span style="font-weight: bold;">6.模板继承</span></div><ul><li><div>1）模板继承和区块实现高度的代码复用和清晰的视图结构</div></li><li><div>2）layout模板</div></li></ul><div><img src="PHP大神班-Laravel框架_files/Image [21].png" type="image/png" data-filename="Image.png"/><br/></div><ul><li><div>3）定义区块：父模板中@yield(‘xxx’)</div></li><ul><li><div>使用区块：子模板中@section(‘xxx’)</div></li><li><div>@section+@show一般用来做js的加载</div></li><li><div>在同一个模板中定义section的位置，使用show，在子模板中定义模板的内容，使用endsection</div></li><li><div>stop是endsection的别名</div></li><li><div>如果不使用@parent，完全覆盖父文件的内容</div></li></ul><li><div>4）@each，可以对视图部分进行循环</div></li><ul><li><div>@each('视图名称’, ‘遍历的数组’, ‘视图的变量名称（遍历数组中的值）’, ‘可选：空视图的名字')</div></li></ul></ul><div><span style="font-weight: bold;">7.视图和服务注入</span></div><ul><li><div>1）用视图composer绑定数据</div></li><li><div>2）全局共享变量（RouteServiceProvider）中，boot()内：view()-&gt;share(’name’, $data);</div></li><li><div>3）所有视图中，都可以拿到$name变量</div></li><li><div>4）Blade服务注入：通过路由定义构造函数，将服务注入视图，在控制器中没有编写的特殊代码需要在页面中使用，比如导航，这样就需要这个导航类在每个控制器中去调用了，直接在页面注入</div></li></ul><div><img src="PHP大神班-Laravel框架_files/Image [22].png" type="image/png" data-filename="Image.png"/><br/></div><ul><li><div>5）视图中直接注入服务：@inject(’XXXX’, ‘App\Service\XXXX’)</div></li></ul><div><span style="font-weight: bold;">8.自定义blade指令</span></div><ul><li><div>1）指令来自于blade模板引擎，文件位置：View\Compilers\BladeCompiler.php</div></li><li><div>2）directive方法，$alias别名，$handler闭包</div></li><li><div>3）全局自定义：App\Providers\AppServiceProvider.php中的boot()方法</div></li><ul><li><div>Blade::directive(’name’, function(){ return 替换完的代码;});，模板中：@name</div></li></ul></ul><div><img src="PHP大神班-Laravel框架_files/Image [23].png" type="image/png" data-filename="Image.png"/><br/></div><ul><li><div>4）带参数的自定义标签，从$expression中拿到</div></li><ul><li><div>@name(‘XXX’)</div></li><li><div>Blade::directive(’name’, function($expression){ return 替换完的代码;});</div></li></ul></ul><div><br/></div><div><span style="font-size: 24px; font-weight: bold;">七、Eloquent使用、模型操作使用</span></div><div><span style="font-weight: bold;">1.数据库快速操作CURD</span></div><div><span style="font-weight: bold;">2.数据库监听DB::listen()</span></div><ul><li><div>1）在AppServiceProvider的boot()中全局监听</div></li></ul><div><img src="PHP大神班-Laravel框架_files/Image [24].png" type="image/png" data-filename="Image.png"/><br/></div><ul><li><div>2）只要在执行SQL代码前，都可以去监听，在控制器或者其他地方</div></li></ul><div><span style="font-weight: bold;">3.DB的Facade是DatabaseManager.php</span>，<span style="color: rgb(255, 38, 0); font-weight: bold;">*</span>默认服务容器列表：\Illuminate\Foundation\Application.php中的registerCoreContainerAliases()方法内</div><div><span style="font-weight: bold;">4.Illuminate\Database\Query重点关注</span></div><div><span style="font-weight: bold;">5.Eloquent ORM</span></div><ul><li><div>1）定义：实现ActiveRecord模式与数据库进行交互</div></li><li><div>2）生成命令：php artisan make:model Model\Users</div></li><li><div>3）继承自Illuminate\Database\Eloquent\Model.php，可以重写父类的内容，实现指定数据表、主键键名、connection属性、主键类型等</div></li><li><div>4）主要用于对象持久化，可直接在代码执行过程中操作对象来进行数据库操作</div></li><li><div>5）软删除：</div></li><ul><li><div>数据库字段添加delete_at（timestamp）</div></li><li><div>模型内添加use Soft·Deletes</div></li><li><div>强制查询软删除数据：Model::withTrashed()-&gt;find(1)</div></li><li><div>恢复数据：$model-&gt;restore()-&gt;find(1)</div></li></ul></ul><div><br/></div><div><span style="font-size: 24px; font-weight: bold;">八、Eloquent-关联模型、多对多模型</span></div><div><span style="font-weight: bold;">1.批量赋值：</span>建立一个模型数组，通过$fillable和$guarded来设置允许和允许批量赋值的字段，防止用户随意的修改模型的属性</div><div><span style="font-weight: bold;">2.关联操作</span></div><ul><li><div>1）关联类型：</div></li><ul><li><div>1对1：主表中定义从表的模型方法中调用hasOne()，方法名与从表类名一致；从表中定义belongsTo()</div></li><li><div>1对多：hasMany()；返回的是一个集合，不是模型的实例，可以进行任何类似Eloquent集合的操作（自定义方法）；</div></li><li><div>多对多：belongsToMany()；attach()、detach()；</div></li><li><div>远程的一对多：一种非常方便的、建立关系的方法；hasManyThrough()；在主表的模型中定义远程对象（通过中间表）</div></li><li><div>预载入：预处理语句；默认采用“惰性加载”，第一次载入模型实例，是不会载入关联模型，只有在单独调用的时候，才会被加载；</div></li><li><div>多态多对多关联</div></li></ul><li><div>2）<span style="color: rgb(255, 38, 0); font-weight: bold;">*</span>集合：Collection，\Illuminate\Support\Collection.php</div></li><ul><li><div>类似数组</div></li><li><div>有更多的操作方法</div></li><li><div>helpers.php中的connect方法</div></li><li><div>reject()、map()、filter()、max()、whereIn()、flatten()、filp()等60个方法</div></li><li><div>方便的包装代替array_map()、array_reduce()等原生方法</div></li></ul></ul><div><br/></div><div><span style="font-size: 24px; font-weight: bold;">九、Eloquent事件，中间件原理</span></div><div><span style="font-weight: bold;">1.Eloquent事件</span></div><ul><li><div>1）在模型操作的生命周期的不同时间点，使用下面的方法绑定事件：creating、created、updating、saving、saved、deleting、deleted、restoring、restored</div></li><li><div>2）绑定监听器：</div></li><ul><li><div>直接在App\Providers\EventServiceProvider</div></li></ul></ul><div><img src="PHP大神班-Laravel框架_files/Image [25].png" type="image/png" data-filename="Image.png"/><br/></div><ul><ul><li><div>事件生成：php artisan event:generate </div></li></ul><li><div>3）监听优点：局部更新缓存、触发日志等功能</div></li></ul><div><span style="font-weight: bold;">2.中间件与服务</span></div><ul><li><div>1）中间件使用</div></li><ul><li><div>HTTP中间件过滤进入APP应用的HTTP请求</div></li><li><div>系统自带的中间件（App\Http\Middleware）</div></li></ul><li><div>2）中间件的创建和使用</div></li><ul><li><div>php artisan make:middleware xxxx</div></li></ul><li><div>3）中间件范围：Kernel.php中</div></li><ul><li><div>$meddleware全局，先走这里的</div></li><li><div>$middlewareGroup路由中间件组，其次走这里的</div></li><li><div>$routeMiddleware路由中间件，指定的路由会走对应的中间件</div></li></ul></ul><div><br/></div><div><span style="font-size: 24px; font-weight: bold;">十.Laravel中间件原理解析</span></div><div><span style="font-weight: bold;">1.终端中间件</span></div><ul><li><div>1）定义中间件为可终止的，先发送到用户，然后再存储数据</div></li></ul><div><span style="font-weight: bold;">2.Laravel的运行流程</span></div><div><img src="PHP大神班-Laravel框架_files/Image [26].png" type="image/png" data-filename="Image.png"/><br/></div><ul><li><div>1）array_reduce把所有要通过的中间件（$this-&gt;pipes），使用回调函数（$this-&gt;pipes不为空）</div></li><li><div>2）核心理解Illuminate\Pipeline\Pipeline.php中的carry()方法</div></li></ul><div><br/></div><div><span style="font-size: 24px; font-weight: bold;">十一、Laravel框架（一）</span></div><div><span style="font-weight: bold;">1.服务源码分析</span></div><ul><li><div>1）服务提供者注册和引导启动（处理HTTP请求阶段才开始）</div></li></ul><div><img src="PHP大神班-Laravel框架_files/Image [27].png" type="image/png" data-filename="Image.png"/><br/></div><div><span style="font-weight: bold;">2.webservice</span></div><div><img src="PHP大神班-Laravel框架_files/Image [28].png" type="image/png" data-filename="Image.png"/><br/></div><ul><li><div>1）原理：Laravel的服务容器及依赖注入容器是整个框架所有功能的核心，DI依赖注入和IoC控制反转</div></li><li><div>2）定义</div></li><ul><li><div>config\app.php中的providers数组中</div></li><li><div>php artisan make:provider xxxxxService</div></li><li><div>boot()调用服务之前自动执行的代码</div></li><li><div>register()让服务和实际的功能代码关联起来（闭包），app()助手函数、bind()方法、singleton()方法</div></li></ul></ul><div><img src="PHP大神班-Laravel框架_files/Image [29].png" type="image/png" data-filename="Image.png"/><br/></div><ul><li><div>3）使用</div></li><ul><li><div>app(‘xxx’);</div></li><li><div>$this-&gt;app[‘xxx’];</div></li></ul></ul><div><br/></div><div><span style="font-size: 24px; font-weight: bold;">十二、Laravel框架（二）Auth</span></div><div>1.登录用户Auth组件</div><ul><li><div>1）php artisan make:auth</div></li><li><div>2）自带控制器：注册、登录、会话、重置密码</div></li><li><div>3）Illuminat\Auth</div></li><li><div>4）路由：Illuminat\Routing/Router.php，auth()方法</div></li></ul><div>2.加密方式</div><ul><li><div>1）注册默认用helper.php中的bcrypt方法，使用的是Illuminate\Hashing\BcryptHasher中的make()方法：password_hash()</div></li><li><div>2）Encrypter类，使用的OpenSSL、AES加密</div></li></ul><div>3.中间件三个Guard：request、session、token</div><ul><li><div>Auth::viaRequest   添加一个自定义的RequestGuard</div></li><li><div>SessionGuard   WEB认证默认的guard Illuminate\Auth\SessionGuard</div></li><li><div>TokenGuard Illuminate\Auth\TokenGuard  无状态的API认证</div></li><li><div>Guard  用来认证用户是否成功</div></li><li><div>UserProvider  用来提供认证模型的来源</div></li></ul><div><br/></div><div><span style="font-weight: bold; font-size: 24px;">十三、Laravel框架（三）队列</span></div><div>1.使用场景</div><ul><li><div>应用解耦</div></li><li><div>流量削峰</div></li><li><div>提高系统稳定性、响应速度</div></li><li><div>耗时久的应用</div></li><li><div>调用外部API的应用需要保障送达率的</div></li></ul><div><br/></div><div><b><font style="font-size: 24px;">十四、Laravel框架（四）</font></b></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 