<html>
<head>
  <title>PHP核心技术与最佳实践</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="2079"/>
<h1>PHP核心技术与最佳实践</h1>

<div>
<span><div><b><font style="font-size: 24px;">一、面向对象思想的核心概念</font></b></div><div><br/></div><div>1.面向对象思想的核心思想是对象、封装、可重用性和可扩展性。面向对象是建立在面向过程之上的更高层次的抽象。</div><div>2.面向对象和具体的语言无关。</div><div><br/></div><div><b>A.面向对象的“形”与“本”</b></div><div>1.类是我们对一组对象的描述</div><div>①类定义了一系列的属性和方法，并提供了实际的操作细节，这些方法可以用来对属性进行加工</div><div>②对象含有类属性的具体值，这就是类的实例化</div><div>②类与对象的关系似一种服务与被服务、加工与被加工的关系</div><div>2.所谓序列化，就是把保存在内存中的各种对象状态（属性）保存起来，并且在需要时可以还原出来</div><div>3.对象和数组的区别在于：对象还有个指针，指向了它所属的类</div><div>4.对象和类：</div><div>①类是定义一系列属性和操作的模板，而对象则把属性进行具体化，然后交给类处理</div><div>②对象就是数据，对象本身不包含方法，但是对象有一个“指针”指向一个类，这个类里面可以有方法</div><div>③方法描述不同属性所导致的不同</div><div>④类和对象不是可分割的，有对象就必定有一个类和其对应，否则这个对象也就成了没有亲人的孩子</div><div><br/></div><div><b>B.魔术方法应用</b></div><div>1.魔术方法是以两个下划线开头、具有特殊作用的一些方法，可以看做PHP的“语法糖”。</div><div>2.php的重载与Java的不同，构造函数不属于重载，而__set、__get属于重载。php的重载指动态地“创建”类属性和方法。</div><div>3.当调用一个不可访问的方法（如未定义或不可见）时，__call()会被调用，实际 上，魔术方法使方法的动态创建变为可能，这在MVC等框架设计中是很有用的语法。</div><div><br/></div><div><b>C.继承与多态</b></div><div>1.用“::”访问一个非静态方法不符合语法，但PHP仍然能够正确地执行代码，这只是PHP的一个“兼容“或者说是”让步”，修改error_reporting打开e_strict报错就会出错</div><div>2.耦合是一个软件结构内不同模块之间互连程序的度量，也就是不同模块之间的依赖关系</div><div>低耦合是指模块与模块之间，尽可能地例模块间独立存在；模块与模块之间的接口尽量少而简单</div><div>更倾向于使用组合，因为：</div><div>①继承破坏封装性</div><div>②继承是紧耦合的</div><div>③继承扩展复杂</div><div>④不恰当地使用继承可能违反现实世界中的逻辑</div><div>3.组合需要一一创建局部对象，增加代码量</div><div>4.如何使用继承：</div><div>①精心设计专门用于被继承的父类，继承树稳定，不超过3层</div><div>②对于不是专门用于被继承的类，禁止其被继承</div><div>③优先考虑用组合关系提高代码的可重用性</div><div>④子类是一种特殊的类型，而不只是父类的一个角色</div><div>⑤子类扩展，而不是覆盖或者使父类的功能失效</div><div>⑥底层代码多用组合，顶层/业务层代码多用继承</div><div>5.多态：同一类的对象收到相同消息时，会得到不同的结果，而这个消息是不可预测的，顾名思义，就是多种状态，多种结果。</div><div>6.多态的真正意义是：在实际开发中，只要关心一个接口或基类的编程，而不必关心一个对象所属于的具体类。</div><div>7.PHP是弱类型的，并且也没有对象转换机制，所以不能像C++或Java那样实现派生类对象赋值给基类对象（calss a = new class b），所以PHP的父类重载不是多态。PHP的接口实现属于多态。</div><div>8.区别是否多态的关键在于看对象是否是同一类型。多态的本质就是if...else，只不过实现的层级不同。</div><div><br/></div><div><b>D.面向接口编程</b></div><div>1.接口定义一套规范，描述一个“物”的功能，要求如果现实中的“物”想成为可用，就必须实现这些基本功能。接口这样描述自己：“对于实现我的所有类，看起来都应该像我现在这个样子”。“接口为抽象而生”。因此，在程序里，接口的方法必须被全部实现，否则将报fetal错误。</div><div>2.接口不仅规范接口的实现者，还规范接口的执行者，不允许调用接口中本不存在的方法。当然这并不是说一个类如果实现了接口，就只能实现接口中才有的方法，而是说，如果针对的是接口，而不是具体的类，则只能按接口的约定办事。</div><div>3.PHP的接口在“面向契约编程”中是不足的，可以淡化为设计文档，起到一个团队基本契约的作用。由于PHP是弱类型，且强调灵活，所以并不推荐大规模使用接口，而是仅在部分“内核”代码中使用接口。</div><div>4.接口本身什么也不做，系统悄悄地在内部实现了接口的行为。Traits可以被视为一种加强型的接口。</div><div><br/></div><div><b>E.反射</b></div><div>1.直观理解就是根据到达地找到出发地和来源。在PHP运行状态中，扩展分析PHP程序，导出或提取出半天类、方法、属性等的详细信息，包括注释。这种动态获取信息以及动态调用对象方法的功能称为反射。</div><div>2.反射不仅可以用于类和对象，还可以用于函数、扩展模块、异常等</div><div>3.用一反射的地方：一个是对对象进行调试，另一个是获取类的信息。反射的消耗很大，在可以找到替代方案的情况下，就不要滥用。</div><div>4.很多时候，善用反射能保持代码的优雅和简洁，但反射也会破坏类的封装性，因为反射可以使本不应该暴露的方法或属性被强制暴露了出来，这既是优点也是缺点。</div><div><br/></div><div><b>F.异常和错误处理</b></div><div>1.PHP里的异常，是程序运动中不符合预期的情况及与正常流程不同的状况。一种不正常的情况，就是按照正常逻辑不该出错，但仍然出错的情况，这属于逻辑和业务流程的一种中断，而不是语言错误。PHP里的错误则属于自身问题，是一种非法语法或者环境问题导致的、让编译器无法通过检查甚至无法运行的情况。</div><div>2.在PHP里，任何自身错误都会触发一个错误，而不是抛出异常（对于一些情况，倒同时抛出错误和异常）。PHP一旦遇到非正常代码，通常都会触发错误，而不是抛出异常。在这个意义上，如果想使用异常处理不可预料的问题，是办不到的。比如，想在文件不存在且数据库链接打不开时触发异常是不可行的，这在PHP中作为错误抛出，而不会作为异常自动捕获。</div><div>3.PHP通常是无法捕获有意义的异常的，它把所有不正常的情况都视为了错误，你要想捕获这个异常，就得使用if...else结构。</div><div>4.什么时候使用异常处理机制：</div><div>①对程序的悲观预测</div><div>②程序的需要和对业务的关注：异常处理机制可以把每一件事当做事务考虑，还可以把异常看成一种内建的恢复系统</div><div>③语言级别的健壮性要求：try..catch的好处就是，可以把异常千万的逻辑中断破坏降到最小范围内，并且经过补救处理后不影响业务逻辑的完整性；乱抛异常和只抛不捕获，或捕获而不补救，会导致数据混乱。</div><div>5.PHP错误就是会使脚本运行不正常的情况，错误级别：</div><div>①deprecated：表示“不推荐，不建议”</div><div>②notice：语法中存在不当的地方</div><div>③warning：在语法中出现很不恰当的情况时，比如函数参数不匹配等，要修改代码</div><div>④fetal error：致命错误，直接导致php流程终结，后面的代码不在执行，必须修改代码</div><div>⑤prase error：语法解析错误，导致PHP代码无法通过语法检查<span>    </span></div><div><span>6.PHP中的错误处理：</span></div><div><span>①set_error_handler()设置用户自定义的错误处理函数，如果使用该函数，会绕过php的错误处理函数，可以使用restore_error_handler()取消接管</span></div><div>②trigger_error函数可以抛出错误</div><div><br/></div><div><i>/phphexinjishuyuzuijiashijian/1.php</i></div><div><br/></div><div><b><font style="font-size: 24px;">二、面向对象的设计原则</font></b></div><div><br/></div><div><b>A.单一职责原则（SRP）：</b>就一个类而言，应该只有一个引起它变化的原因。就是怎么样设计类以及类的方法界定的问题。</div><div>一是避免相同的职责分散到不同的类中，另一个是避免一个类承担太多的职责。</div><div>为什么要遵守SRP呢？</div><div>①可以减少类之间的耦合</div><div>②提高类的复用性</div><div>2.工厂模式：在代码执行时实例化对象，负责生产对象，根据不同的参数生成不同的实例化对象。</div><div>3.命令模式：分离命令请求者和命令实现者。</div><div>4.一直简单的应该遵循的做法：</div><div>①根据业务流程，把业务对象提炼出来</div><div>②职责的分类需要注意</div><div><br/></div><div><b>B.接口隔离原则（ISP）：</b>如果一个模块包含多个子模块，那么我们应该小心对该模块做出抽象；表明客户端不应该被强迫实现他们不会使用的接口，应该把胖接口中的方法分组，然后用多个接口代替它，每个接口服务于一个子模块，简单地说，就是使用多个专门的接口比使用单个接口要好得多。</div><div>1.主要观点：</div><div>①一个类对另外一个类的依赖性应当是建立在最小的接口上的。ISP可以达到不强迫客户依赖于他们不用的方法；ISP还可以降低客户之间的相互影响</div><div>②客户端程序 不应该依赖它不需要的接口方法（功能）</div><div>2.ISP强调的是接口对客户端的承诺越少越好，并且要做到专一。</div><div>3.接口污染：过于臃肿的接口设计是对接口的污染。就是为接口添加不必要的职责，如果 开发人员在接口中增加一个新功能的主要目的只是减少接口实现类的数目，则此设计将导致接口被不断地“污染”并“变胖”。“接口隔离”其实就是定制化服务设计的原则。</div><div>处理方法：</div><div>①利用委托分离接口</div><div>②利用多继承分离接口</div><div><br/></div><div><b>C.开放-封闭原则：</b></div><div>1.定义：</div><div>open:模块的行为必须是开放的、支持扩展的，而不是僵化的</div><div>closed:在对模块的功能进行扩展时，不应该影响或大规模地影响已有的程序模块</div><div>2.也就是要求开发人员在不修改系统中现有功能代码的前提下，实现对应用系统的软件功能的扩展；一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的</div><div>3.如何遵守开放-封闭原则：核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，这样的修改就是封闭的；而通过面向对象的继承和多态机制，可以实现对抽象体的继承，通过覆写其方法来改变固有行为，实现新的扩展方法，所以对于扩展就是开放的。</div><div>①在设计方面充分应用“抽象”和“封装”的思想</div><div>②在系统功能编程实现方面应用面向接口的编程</div><div><br/></div><div><b>D.替换原则（LSP，里氏替换原则）：子类必须能够替换成它们的基类</b></div><div>1.定义：子类型必须能够替换掉它们 的父类型、并出现在父类能够出现的任何地方。一个软件裸体如果使用一个基类的话，那么一定适用于其子类，而这根本不能察觉出基类对象和子类对象的区别。</div><div>2.如何遵守：</div><div>①父类的方法都要在子类中实现或者重写，并且派生类只实现其抽象类中声明的方法，而不应该给出多余的方法定义或实现</div><div>②在客户端程序 中只应该使用父类对象而不应当直接使用子类对象，这样可以实现运行期绑定</div><div>3.PHP对LSP的支持并不友好，缺乏向上转型等概念，只能通过一些曲折的方法实现。</div><div><br/></div><div><b>E.依赖倒置原则：就是将依赖关系倒置为依赖接口</b></div><div>1.定义：</div><div>①上层模块不应该依赖于下层模块，它们共同依赖于一个抽象</div><div>②抽象不能依赖于具体，具体应该要依赖于抽象</div><div>2.抽象一般是相对稳定或者相对变化不频繁的，而具体是易变的。</div><div>3.IOC是依赖倒置原则的同义词，依赖注入（DI）和依赖查找（DS）是IOC的两种实现。</div><div>4.PHP还没有一个完善的IOC容器，或者说PHP不需要</div><div>5.如何满足IOC：</div><div>每个罗高层次类都为它所需要的服务提出一个接口声明，较低层次类实现这个接口</div><div>每个较高层类都通过该抽象接口使用服务</div><div><br/></div><div><b>F.一些优于面向过程的</b></div><div>1.新成员的加入和融合不再困难</div><div>2.代码即文档</div><div>3.我们既要深入了解面向对象的思想，又不能执着于面向对象</div><div><br/></div><div><i>/phphexinjishuyuzuijiashijian/2.php</i><br/></div><div><br/></div><div><b><font style="font-size: 24px;">三、正则表达式基础与应用</font></b></div><div><br/></div><div><b>A.认识正则表达式</b></div><div>1.PHP中有两套正则函数：</div><div>①由PCRE库提供的函数，以“preg_”为前辍名</div><div>②由POSIX扩展提供的函数，以“ereg_”为前辍名，PHP5.3后不推荐使用</div><div>2.在PHP里，一个正则表达式分为三个部分：分隔符、表达式和修饰符<br/></div><div><br/></div><div><b><font style="font-size: 24px;">四、PHP网络技术及应用</font></b></div><div><br/></div><div><b>A.HTTP协议详解</b></div><div>1.HTTP就是一个基于应用层的通信规范：从WWW服务器传输超文本到本地浏览器，由请求和响应构成。是一个无状态的协议，同一个客户端的这次请求和上次请求没有对应关系。属于典型的问答式交互。</div><div>2.SPDY协议，优化了浏览器和服务器之间的通信，支持流复用，具备优先级的请求、主动发起请求、强制SSL安全传输等先进特性。</div><div>3.HTTP工作流程：</div><div>①客户机与服务器建立连接</div><div>②建立连接后，客户机发送一个请求给服务器。格式为：前面是统一资源标识符（URL）、中间是协议版本号，后边是MIME信息（包括请求修饰符、客户机信息和可能的内容）</div><div>③服务器接到请求后，给予相应的响应信息。格式为：首先是一个状态行（包括信息的协议版本号、一个成功或错误的代码），然后是MIME信息（包括服务器信息、实体信息和可能的内容）</div><div>④客户端接收服务器返回的信息并显示 在用户的显示屏上，然后客户机与服务器断开连接</div><div>4.垃圾信息防御措施</div><div>①IP 限制 </div><div>②验证码</div><div>③Token和表单欺骗</div><div>④审核机制</div><div><br/></div><div><b>B.抓包工具</b>：Fiddler</div><div><br/></div><div><b>C.Socket进程通信机制及应用</b></div><div>1.Scoket通常称为“套接字”，用于描述IP地址和端口，是一个通信链的句柄。应用程序通过套接字向网络发出请求或者应答网络请求。Socket既不是一个程序，也不是一种协议，其只是操作系统提供的通信层的一组抽象API。</div><div>2.PHP的语言特性和自身定位决定了它只适合做客户端</div><div>3.注意：</div><div>①fsockopen的第一个参数$hostname不要带“http://”，除非使用SSL等</div><div>②Headers请求不一定都要按照抓包数据全部带上，除非调用不成功或者不熟练或者有特殊需求</div><div>③在Connection和data后有两个换行</div><div>④有些表单请求可能有hidden值</div><div>⑤注意编码问题</div><div><br/></div><div><b>D.cURL工具及应用</b></div><div>1.建立cURL请求的基本步骤</div><div>①初始化</div><div>②设置选项，包括URL</div><div>③执行并获取 HTML文档内容</div><div>④释放cURL句柄</div><div>2.curl_getinfo()对调试很有用</div><div><br/></div><div><b>E.简单邮件传输协议SMTP</b></div><div>1.SMTP是由源地址到目的地址传送邮件的一组规则，用来控制信件的中转方式。</div><div><br/></div><div><b>F.WebService的前世今生</b></div><div>1.WebService</div><div>2.PHPRPC协议</div><div><br/></div><div><b>G.Cookie详解</b></div><div>1.Cookie在远程浏览器存储数据并以此跟踪和识别用户的机制。从实现上说，Cookie是存储在客户端上的一小段数据 ，浏览器（既客户端）通过HTTP协议和服务器端进行Cookie交互。</div><div>2.使用PHP设置Cookie其实就是发出命令让浏览器来设计Cookie而已</div><div>3.注意：</div><div>①cookie函数有一个返回值，如果是false，代表设置失败，但是仅供参考</div><div>②由php在当前页设置的cookie不能立即生效，要下一个页面才能看到</div><div>③cookie没有显式的删除函数</div><div>4.cookie跨域需要P3P设置</div><div>①页面的cookie不能是浏览器进程的cookie</div><div>②利用iframe时，要在相应的动态页的页头添加一下p3p的信息</div><div>③ie对跨域访问cookie限制比较严格</div><div>5.本地localStorage存储</div><div><br/></div><div><b>H.Session详解</b></div><div>1.session_set_save_handler()改变session存储的方式</div><div>2.sessionid默认作为一个cookie存储在客户端</div><div><br/></div><div><font style="font-style: italic;">/phphexinjishuyuzuijiashijian/3.php</font><br/></div><div><br/></div><div><b><font style="font-size: 24px;">五、PHP与数据库基础</font></b></div><div><br/></div><div><b>A.什么是PDO</b></div><div>1.连接mysql的三种方式：</div><div>①MySQL系列函数</div><div>②MySQLi系列函数</div><div>③PDO：为PHP定义了一个访问数据库的轻量、持久的接口，实现PDO接口的每一种数据库驱动都能以正则扩展的形式把各自的特色表现出来。</div><div>2.PDO包含三个重要的类：PDO、PDOStatement、PDOException</div><div>3.事务，使用beginTransaction()、commit()、rollBack()</div><div>4.效率：60多张表2G左右数据库进行CRUD效率比mysql直连慢5%-15%，对效率要求高的应使用直连。负载在开启长连接后高于mysql直连且比较稳定</div><div><br/></div><div><b>B.数据库应用优化</b></div><div>1.基本语句优化10个原则</div><div>①尽量避免在列上进行运算，这样会导致索引失效</div><div>②使用JOIN时，应该用小结果集驱动大结果集。同时把复杂的JOIN查询拆分成多个Query。因为JOIN多个表时，可能导致更多的锁定和堵塞。</div><div>③注意LIKE模糊查询的使用，避免%%</div><div>④仅列出需要查询的字段 ，这对速度不会有明显的影响，主要考虑节省内存</div><div>⑤使用批量插入语句节省交互</div><div>⑥limit的基数比较大时使用between</div><div>⑦不要使用rand函数获取多条随机记录</div><div>⑧避免使用NULL</div><div>⑨不要使用count(id)，而应该是count(*)</div><div>⑩不要做无谓的排序操作，而应尽可能在索引中完成排序</div><div>2.索引与性能分析</div><div>EXPLAIN属性说明：</div><div><ul><li>id：查询的序列号<br/></li><li>select_type：查询的类型，主要包括普通查询、联合查询和子查询<br/></li><li>table：所访问的数据库中表的名称<br/></li><li><b>type</b>：联合查询使用的类型：由好到坏依次为system（系统表）、const（常量）、eq_ref（最多一条匹配结果）、ref（被驱动表索引）、fulltext（全文索引检索）、ref_or_null（带空值的索引查询）、index_merge（合并索引结果集）、unique_subquery（子查询中返回的字段是唯一组合或索引）、index_subquery（子查询返回的是索引，但非主键）、range（索引范围扫描）、index（全索引扫描）、ALL（全表扫描）<br/></li><li>possible_keys：指出MySQL能使用哪个索引在该表中找到该行。如果没使用则为空<br/></li><li>key：显示MySQL实际决定使用的键<br/></li><li>key_len：显示MySQL决定使用的键长度。可以反映出一个多主键里MySQL实际使用了哪部分。<br/></li><li>ref：显示哪个字段或常数与key一起被使用<br/></li><li>rows：表示MySQL要遍历多少数据才能找到所需的结果集，在InnoDB上是不准确的<br/></li><li>Extra：如果是only index，表明信息只能用索引树中的信息检索；where used表明使用了where限制，但是索引不够；impossible where，表明通过收集到的统计信息判断出不可能存在结果；using filesort，表示包含orderby且无法使用索引进行派讯操作，不得不使用相应的派讯算法实现；using temporary，表明使用临时表，常见于orderby和group by；select tables optimized way，使用聚合函数，并且MySQL进行了快速定位，通常是MAX、MIN、COUNT等<br/></li></ul></div><div>3.索引至少达到range级，最好能达到ref级</div><div>4.索引建立和使用的基本原则：</div><div>①合理设计和合理使用索引</div><div>②在关键字段的索引上，建与不建索引，查询速度相差近百倍</div><div>③差的索引和没有索引效果一样</div><div>④索引并非越多越好，因为维护索引需要成本</div><div>⑤每个表的索引应在5个以下，应合理利用部分索引和联合索引</div><div>⑥不在结果集中的结果单一的列上建索引 </div><div>⑦建索引的字段结果集最好分页均匀，或者符合正太分布</div><div>5.选择存储引擎</div><div>①采用MyISAM：R/W&gt;100:1且update相对较少；并发不高，不需要事务；表数据量小；硬件资源有限；</div><div>②采用InnoDB：R/W比较小，频繁更新大字段；表数据量超过1000万，并发高；安全性和可用性要求高；</div><div>③采用Memory：有足够的内存；对数据一致性要求不高；需要定期归档的数据；</div><div>6.MySQL瓶颈及应对措施</div><div>①提高服务器配置</div><div>②使用第三方引擎，Percona、MariaDB等</div><div>③迁移到其他数据库，Oracle等</div><div>④分区、分表</div><div>⑤使用NoSQL</div><div>⑥使用中间件做数据拆分和分布式数据，Cobar等</div><div>⑦使用数据库连接池技术</div><div><br/></div><div><b>C.数据库设计</b></div><div>1.设计数据库时原则：</div><div>①核心业务使用范式</div><div>②弱一致性需求—反ACID</div><div>③空间换时间，冗余换效率</div><div>④避免不必要的冗余</div><div><br/></div><div><b>D.MySQL的高级应用</b></div><div>1.序列表</div><div>2.视图：mysql中视图等价于依据查询语句，进行查询时只是将视图展开成其定义的语句。因此不能提升效率。</div><div>好处：实现了更细致的权限控制；把业务中常用的SQL语句用一个视图来表示更直观；性能优势在别的数据库中可体现。</div><div>3.存储过程和事件调度</div><div>4.SQL注入漏洞与防范</div><div>①如果是整型，使用intval()</div><div>②字符类型使用addslashes()</div><div>③转义及过滤一些特殊字符</div><div>④保护表结构等关键信息</div><div>⑤做好数据库备份</div><div><br/></div><div><font style="font-style: italic;">/phphexinjishuyuzuijiashijian/4.php</font><br/></div><div><br/></div><div><b><font style="font-size: 24px;">六、PHP模板引擎的原理与实践</font></b></div><div><br/></div><div><b>A.模板引擎骨架</b></div><div>开发思路：</div><div>①模板引擎要做的事情就是把逻辑层和表现层的代码分离，这是一个大原则。</div><div>②作为一个工具类，应该满足一些基本要求，其中之一就是可配置</div><div>③确定模板引擎到底需要一些什么功能，需要哪些特性</div><div><br/></div><div><font style="font-style: italic;">/phphexinjishuyuzuijiashijian/5.php</font><br/></div><div><font style="font-style: italic;"><font style="font-style: italic;">/phphexinjishuyuzuijiashijian/Template.php</font><br/></font></div><div><font style="font-style: italic;"><font style="font-style: italic;"><font style="font-style: italic;">/phphexinjishuyuzuijiashijian/template/member.m</font><br/></font></font></div><div><br/></div><div><b><font style="font-size: 24px;">七、PHP扩展开发</font></b></div><div><br/></div><div><b>A.PHP的生命周期</b></div><div>1.一个php实例，无论是从init脚本中调用的，还是从命令行启动的，都会依次经过Module init、Request init、Request shutdown、Module shutdown四个过程</div><div>2.最常见的四种启动php的方式：直接以CLI/CGI模式调用、多进程模块、多线程模块、Embedded（嵌入式，在自己的C程序中调用Zend Engine）</div><div>3.SAPI（Server abstraction API），服务器抽象化程序接口，提供一个接口，使PHP可以和其他应用进行交互，例如与Apache起交互</div><div><br/></div><div><b>B.PHP内核中的变量</b></div><div>1.写时复制</div><div>两个指向同一内存块的变量，当其中一个变量的值发生变化，才会另外创建一个内存块去保存新的值。也是一种引用，不过会受变量值的改变而破坏。</div><div><br/></div><div><b>C.Zend引擎</b></div><div>1.是脚本语言引擎（解析器+虚拟机），主要的工作就是解析、翻译和执行PHP脚本。</div><div>2.编译PHP脚本，输出Opcodes；解析执行Opcodes，输出结果。</div><div><br/></div><div><b>D.PHP扩展包含</b></div><div>①包含头文件：php.h</div><div>②声明导出函数</div><div>③声明Zend函数块</div><div>④声明Zend模块</div><div>⑤实现get_module()函数</div><div>⑥实现导出函数</div><div><br/></div><div><font style="font-style: italic;">/phphexinjishuyuzuijiashijian/6.php</font><br/></div><div><font style="font-style: italic;">/phphexinjishuyuzuijiashijian/php_list/*</font><br/></div><div><br/></div><div><b><font style="font-size: 24px;">八、缓存详解</font></b></div><div><br/></div><div><b>A.认识缓存</b></div><div>1.凡是位于速度相关较大的两种介质之间，用于协调两者数据传输速度差异的结构，均可称为Cache。</div><div>2.命中率指请求缓存次数和缓存返回正确结果次数的比例。</div><div>3.缓存更新策略：FIFO(First In First Out)最先进入缓存的数据在缓存空间不够的情况下会被首先清理出去；LFU(Less Frequently Used)最少使用的元素会被清理掉；LRU(Least Recently Used)最近最少使用的元素被清理。</div><div>4.缓存最大数据量：是在缓存中能处理元素的最大个数或所能使用的最大存储空间，mysql由query_cache_size参数决定</div><div>超过后四种处理方式：</div><div>①停止缓存服务</div><div>②拒绝写入</div><div>③根据缓存更新策略清除旧数据</div><div>④在方式3的基础上，将淘汰的数据备份，腾出新的空间</div><div><br/></div><div><b>B.文件缓存</b></div><div>1.优点：容量大；稳定；固态硬盘提升速度；扩展容易；</div><div><br/></div><div><b>C.Opcode缓存</b></div><div>1.Opcode(Operation Code，操作码)就是虚拟机把PHP代码编译成一种中间码的结果缓存起来（可以缓存到硬盘或者内存中）。下一次运行此页面时，只要直接解释这些代码就行了，这样省去了Flex语法器进行语法编译和大部分语法检查。</div><div>2.eAccelerator</div><div><br/></div><div><b>D.客户端缓存</b></div><div>1.由浏览器实现</div><div>2.相关Header参数：</div><div>①Expires过期时间</div><div>②Cache-Control让网站发布者全面控制内容，并定位过期时间的限制（max-age=[秒]，缓存过期时间；s-maxage=[秒]类似于max-age，应用于共享缓存；public标记认证内容也可以被缓存；no-cache强制每次请求直接发送给源服务器，而不经过本地缓存版本的校验；no-store强制缓存在任何情况下都不要保留副本；must-revalidate每次使用该资源都需要确认新鲜性；proxy-pevalidate和maust-revalidate类似，只对缓存代理服务器起作用；Last-Modified文档最后修改时间）</div><div>③ETag服务器生成唯一标识符ETag，每次请求的标签都会变化 </div><div>3.HTML5中的Application Cache</div><div><br/></div><div><b>E.Web服务器缓存</b></div><div>1.Apache缓存</div><div>2.Nginx缓存</div><div><br/></div><div><font style="font-style: italic;">/phphexinjishuyuzuijiashijian/7.php</font></div><div><br/></div><div><b><font style="font-size: 24px;">九、Memcached使用与实践</font></b></div><div><br/></div><div><b>A.安装及使用</b></div><div>1.特点：协议简单；基于libevent的事件处理；内置内存存储方式；采用不互相通信的分布式；</div><div><br/></div><div><b>B.深入了解Memcached</b></div><div>1.使用多路复用I/O模型（如epoll、select等）</div><div><br/></div><div><b>C.Memcached分布式布置方案</b></div><div>1.普通Hash分布</div><div>2.一致性Hash分布</div><div><br/></div><div><font style="font-style: italic;">/phphexinjishuyuzuijiashijian/8.php</font><br/></div><div><br/></div><div><b><font style="font-size: 24px;">十、Redis使用与实践</font></b></div><div><br/></div><div><b>A.数据类型</b></div><div>1.String：不能有\n</div><div>2.List：可以做消息队列</div><div>3.Set：无序集合，快速查找元素是否存在，用于记录一些不重复的数据</div><div>4.Sorted Set：有序集合，通过一个double类型的整数score进行排序，可以构建具有优先级的队列</div><div>5.Hash：key对应一个HashTable，适合存储对象</div><div><br/></div><div><b>B.事务处理</b></div><div>1.只能保证一个客户端连接发起事务中的命令可以连续执行，而中间不会插入其他客户端连接的命令</div><div><br/></div><div><b>C.持久化</b></div><div>1.内存快照：将内存中的数据以快照方式写入二进制文件中，使用save命令</div><div>2.日志追加：（aof）方式是把增加、修改数据的命令通过write函数追加到文件尾部，重启时读取appendonly.aof文件中的所有命令并且执行，从而把数据写入内存</div><div><br/></div><div><b>D.虚拟内存</b></div><div>1.把很少使用的value保存到磁盘中，把 value对应的key保存在内存中</div><div><br/></div><div><font style="font-style: italic;">/phphexinjishuyuzuijiashijian/9.php</font><br/></div><div><br/></div><div><b><font style="font-size: 24px;">十一、高性能网站架构方案</font></b></div><div><br/></div><div>数据库会降低应用性能：</div><div>①虽然缓存可以降低数据库的访问次数，但缓存过期后仍然需要访问数据库</div><div>②数据库的写操作通常不能引入缓存策略</div><div>③没有搭建缓存环境，而直接对数据库操作</div><div><br/></div><div><b>A.如何优化网站响应时间</b></div><div>1.优化响应时间</div><div>①减少http请求：将多个图片合并成为一个独立的HTTP请求；合并JS脚本和CSS样式文件；利用浏览器的Cache功能</div><div>②动态内容静态化</div><div>③优化数据库</div><div>④使用负载均衡</div><div>⑤使用缓存</div><div>2.吞吐率：单位时间内服务器处理的请求数，使用“reqs/s”（服务器每秒请求的数量）表示</div><div>3.压力测试：LoadRunner、JMeter、ApacheBench等</div><div>4.持久连接：又称长连接（Keep-Alive），指TCP连接中持续发送多份数据而不断开的连接。</div><div>发出的HTTP请求头包含Connection:Keep-Alive，Apache中打开KeepAlive on，Apache过期时间KeepAliveTimeout 20，长链接不是正效应，有可能影响服务器的并发性能</div><div><br/></div><div><b>B.MySQL响应速度提高方案：HandlerSocket</b></div><div><br/></div><div><b>C.MySQL稳定性提高方案：主从复制</b></div><div>1.优点：增加健壮性；优化响应时间；在从库备份过程中，主库持续更新；</div><div>2.工作原理：通过Binlog Dump线程将binlog日志传给从库；从库通过一个I/O线程将binlog日志中的更新操作复制到Relay Log中继日志文件；从库再通过另一个SQL线程将Relay Log中的操作进行执行；</div><div><br/></div><div><b>D.Web应用回事方案：Varnish</b></div><div>1.代理：介于客户端和Web服务器之间的另一台服务器称为代理服务器，浏览器不直接到Web服务器取回网页，而向你代理服务器发出请求，信号先送到代理服务器，由代理服务器取回浏览器所需要信息并传送给浏览器。</div><div>2.反向代理：与代理的对象不同，对象是服务器端程序。通过反向代理服务器间接访问Web服务器，从而把后端代理服务器隐藏。包括Squid、Varnish以及nginx。</div><div><br/></div><div><b>E.异步计算方案：Gearman</b></div><div>1.包括三个部分：Client，创建并发起一个Job请求；Job Server，找到合适的Worker，并把Job交给Worker；Worker，执行Job。</div><div><br/></div><div><font style="font-style: italic;">/phphexinjishuyuzuijiashijian/10.php</font></div><div><font style="font-style: italic;"><font style="font-style: italic;">/phphexinjishuyuzuijiashijian/10worker.php</font><br/></font></div><div><br/></div><div><b><font style="font-size: 24px;">十二、代码调试和测试</font></b></div><div><br/></div><div><b>A.调试PHP代码</b></div><div>echo、print_r()、var_dump()、debug_zval_dump()、debug_print_backtrace()以及使用Xdebug和IDE配合</div><div><br/></div><div><b>B.前端调试</b></div><div>Firebug、Fiddler</div><div><br/></div><div><b>C.日志管理</b></div><div>1.PHP日志：php.ini中，Log_errors = ON;error_log=path</div><div>2.Apache服务器日志：httpd.conf中，ErrorLog “path”;CustomLog “path” common</div><div>3.MySQL日志：错误日志；二进制日志(binLog)，包含所有更新数据或者已经潜在更新数据的所有语句；查询日志，记录所有操作，影响性能；慢查询日志；</div><div><br/></div><div><b>D.代码性能测试技术</b></div><div>1.Xdebug(WinCacheGrind)</div><div>2.性能测试注意事项：如果进行对比测试，首先应保证可比性；排队不相关因素；过多与过少（样本量与次数）；考虑热启动时间；指标的全面性；关于时间精度（Linux精度高）；</div><div><br/></div><div><b>E.单元测试</b></div><div>PHPUnit</div><div>常用方法：setUp()；setUpBeforeClass()；tearDown；tearDownAfterClass；markTestSkipped</div><div>常用注解：@depends，定义一种依赖关系，即一个测试方法的参数内容和是否会运行依赖于另外一个测试方法的结果；@test，只有以test字符开头的方法才会被测试；@assert，断言；</div><div><br/></div><div><b>F.压力测试</b></div><div>1.JMeter</div><div>术语：线程组，测试里每个任务都要线程处理；取样器，可以认为所有测试任务都由取样器承担；断言，对取样器返回的请求结果给出判断；监听器，对取样器的请求结果进行显示；</div><div>2.压力测试MySQL</div><div>mysqlslap命令，JMeter，Badboy</div><div><br/></div><div><font style="font-style: italic;">/phphexinjishuyuzuijiashijian/11.php</font><br/></div><div><br/></div><div><b><font style="font-size: 24px;">十三、Hash算法与数据库实现</font></b></div><div><br/></div><div>Hash表(HashTable)又称散列表，通过把关键字Key映射到数组中的一个位置来访问记录，以加快查找的速度。这个映射函数称为Hash函数，存放记录的数组称为Hash表。</div><div><br/></div><div><b>A.Hash函数</b></div><div>1.作用是把做生意长度的输入，通过Hash算法变成固定长度的输出。这种转换是一种压缩映射，也方法是Hash值的空间通常远小球输入的空间。</div><div><br/></div><div><b>B.Hash算法</b></div><div>1.直接取余法：直接用关键字k除以Hash表的大小m取余数，h(k) = k mod m；</div><div>2.乘积取整法：首先使用关键字k乘以一个常数A(0&lt;A&lt;1)，并制取出kA的小数部分。然后用Hash表大小m乘以这个值，再取整数部分即可。h(k) = floor(m*(kA mod 1))</div><div>3.经典Hash算法Times33：比较有有名的ELFHash、APHash和Time33等。Time33的思路就是不断乘以33，其效率和随机性都非常好，广泛运用于多个开源项目，如Apache、Perl和PHP等。</div><div><br/></div><div><b>C.Hash表</b></div><div>1.实现步骤：创建一个固定大小的数组用于存放数据；设计一个Hash函数；通过Hash函数把关键字映射到数组的某个位置，并在此位置上进行数据存取。</div><div>2.SplFixedArray，更接近C语言的数组，效率更高。必须 开启SPL扩展。</div><div>3.解决冲突常用的方法有：开放定址法和拉链法。</div><div><br/></div><div><b>D.一个小型数据库的实现</b></div><div>1.pack函数，把数据装入一个二进制字符串；umpack，从二进制字符串对数据进行解包；</div><div><br/></div><div><font style="font-style: italic;">/phphexinjishuyuzuijiashijian/12.php</font></div><div><br/></div><div><b><font style="font-size: 24px;">十四、PHP编码规范</font></b></div><div><br/></div><div><b>A.文件格式</b></div><div>1.文件标记：使用完事的PHP标签，不建议使用短标签；只含有PHP的文件在结尾处忽略?&gt;</div><div>2.文件和目录命名：使用有意义的英文命名，使用驼峰法</div><div>3.文件目录结构：合理分配目录</div><div><br/></div><div><b>B.命名规范</b></div><div>1.变量命名：驼峰法；全局变量两边加“_”，中间驼峰；普通变量，建议变量前加类型的前缀；函数名，有意义，尽量缩写；</div><div>2.类及接口命名：类，以大写字母开头，多个单词驼峰，与文件名保持一致，程序中唯一，抽象类以Abstract开头；接口，和类相同的规则，但命名前加i字符，尽量保持和实现它的类命名一致；</div><div>3.数据库命名：数据表，使用小写字母，统一前缀，使用“_”间隔；字段命名，使用小写，驼峰，如有必要给常用字段加上表名首字母作为前缀，避免使用关键字和保留字；存储过程、触发器、event以及视图的命名在表的命名规则的基础上，存储过程以proc_开头，触发器以tri_开头，Event调度以event_开头，视图以view_开头；</div><div>4.习惯与约定：循环体中使用I-N字母作为循环体中的变量命名；</div><div><br/></div><div><b>C.注释规范</b></div><div>1.程序注释：写在被注释代码前面，单行写行尾；大段注释，用/**/，单行用//；注释不宜太多；代码注释应该描述为什么，而不是做什么；</div><div>2.文件注释：包含本程序的描述；包含作者；包含项目名称；包含文件的名称；包含书写日期；包含版本信息；包含重要的使用说明；</div><div>3.类/接口注释：尽量简洁</div><div>4.方法和函数注释：写在前面，标明信息主要是可见性、参数类型和返回值的类型</div><div>5.IDE标注</div><div><br/></div><div><b>D.代码风格</b></div><div>1.缩进和空格：使用4个空格作为缩进，变量赋值时等号左右留出空格；</div><div>2.语句断行：保证程序语句一行就是一句，尽量不要使一行的代码太长保持在80个字符以内，如果太长使用.=断行书写，执行sql不要在函数内写SQL语句</div><div>3.更好的习惯：使用PHP中已经存在的常量，在echo中使用逗号连接字符串，更详尽的注释，不要滥用语法糖；</div><div><br/></div></span>
</div></body></html> 