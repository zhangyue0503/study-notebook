<html>
<head>
  <title>ModernPHP</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="2022"/>
<h1>ModernPHP</h1>

<div>
<span><div><b><font style="font-size: 24px;">一、特性</font></b></div><div><br/></div><div><b>D.闭包:5.3.0中引入</b></div><div>1.闭包是指在你创建时封装周围状态的函数。即使闭包所在的环境不存在了，闭包中封装的状态依然存在。</div><div>2.匿名函数其实就是没有名称的函数。匿名函数可以赋值给变量，还能像其他任何PHP对象那样传递。特别适合作为函数或方法的回调。PHP中闭包和匿名函数是相同的概念。</div><div>3.在PHP必须手动调用闭包对象的bindTo()方法或者使用use关键字把变量附加到闭包上时，附加的变量会记住附加时赋给它的值。</div><div>4.闭包是对象，可以使用$this关键字获取闭包的内部状态。</div><div><br/></div><div><i>/modernphp/ex4.php</i></div><div><br/></div><div><b>E.Zend OPcache:5.5.0引入</b></div><div>1.php是解释型语言，每次伏特加比我非常解析脚本代码编译成zend操作码，会消耗很多资源，字节码缓存能预告编译好，php不用每次都读取、解析和编译。会从内存中直接读取预先编译好的字节码然后立即执行。</div><div>2.编译php时增加 —enablte-opcache ,php.ini中zend_extension=/path/to/opcache.so</div><div><br/></div><div><b>F.内置的HTTP服务器:5.4.0引入</b></div><div>1.php -S localhost:4000，不要在生产环境使用</div><div>2.判断是否内置服务器：php_sapi_name() == ‘cli-server’</div><div><br/></div><div><b><font style="font-size: 24px;">二、标准</font></b></div><div><b><br/></b></div><div><b>A.psr规范：</b></div><div>1.PSR-1:基本的代码风格</div><div>2.PSR-2:严格的代码风格</div><div>3.PSR-3:日志记录器接口</div><div>4.PSR-4:自动加载</div><div><br/></div><div><b>B.PSR-1:</b></div><div>1.PHP标签：必须把PHP放在&lt;?php ?&gt;或&lt;?= ?&gt;中</div><div>2.编码：必须使用UTF8且无BOM</div><div>3.目的：一个PHP文件可以定义符号（类、性状、函数和常量等）或者执行有副作用的操作，但不能同时做这两件事</div><div>4.自动加载：PHP命名空间和类必须遵守PSR-4自动加载器标准</div><div>5.类的名称：PHP类的名称必须 一直使用驼峰式</div><div>6.常量的名称：PHP 常量的名称必须 全部使用大写字母和下划线</div><div>7.方法的名称：必须一直使用camelCase这种驼峰式</div><div><br/></div><div><b>C.PSR-2：</b></div><div>1.贯彻PSR-1</div><div>2.缩进：四个空格</div><div>3.文件和代码行：必须使用UNIX风格换行符（LF），最后一行有个空行，不要使用?&gt;。每行代码不超过80个字符，最多不超过120个。每行字尾不能有空格。</div><div>4.关键字：PHP关键字都应该使用小写字母，如true</div><div>5.命名空间：每个命名空间说一句后必须跟一个穿行，use语句后也是</div><div>7.类：类定义体的起始括号必须在类名之后新起一行，结束括号恬在定义体之后新起一行。如果类扩展其他类或实现接口，extends和implements关键字必须和类名写在同一行</div><div>8.方法：方法定义体的括号位置和类定义体的括号位置一样。参数起始圆括号之后没有空格，结束括号前也没有空格，每个参数后面有一个括号和空格</div><div>9.可见性：类中的每个属性和方法都要声明可见性，可见性由public、protected或private指定，其作用是决定在类的内部和外部如何访问属性和方法。如果声明abstract或final，这两个限定符必须放在可见性关键字之前。如果声明static，必须放在可见性关键字之后。</div><div>10.控制结构：所有控制结构关键字之后都要有一个空格，包括if、elseif、else、switch、case、while、do、for、foreach、try和catch。如果后面有圆括号，与方法圆括号一样。花括号的起始括号应该与关键字在一行，结束括号单独一行</div><div><br/></div><div><b>D.PSR-3:</b></div><div>1.日志功能委托给第三方库实现，最终用户能选择使用他们喜欢的日志记录器组件（如：monolog）</div><div>2.日志记录器组件需要实现Psr\Log\LoggerInterface接口</div><div><br/></div><div><b>E.PSR-4:</b></div><div>1.自动加载器策略是指：在运行时按需查找PHP类、接口或性状，并将其载入PHP解释器。支持PSR-4的标准的PHP组件和框架，使用同一个自动加载器就能找到相关的代码，然后将其载入PHP解释器。</div><div>2.PSR-4依赖PHP命名空间和文件系统目录结构查找并加载PHP类、接口和性状，会把命名空间的前缀和文件系统中的目录对应起来。</div><div>3.不要自己写自动加载器，尽量使用composer</div><div><br/></div><div><i>/modernphp/ex5.php</i><br/></div><div><br/></div><div><b><font style="font-size: 24px;">三、组件</font></b></div><div><br/></div><div>1.组件是打包的代码，用于帮你解决PHP应用中某个具体的问题。严格来说，PHP组件是一系列相关的类、接口和性状</div><div>2.好的组件：作用单一、小型、合作、测试良好、文档完善</div><div>3.composer：自动加载和依赖管理工具</div><div>4.安装composer</div><div>curl -sS <a href="https://getcomposer.org/installer">https://getcomposer.org/installer</a> | php</div><div>sudo mv composer.phar /usr/local/bin/composer</div><div>sudo chmod +x /usr/local/bin/composer</div><div>*中国镜像：composer config -g repo.packagist composer <a href="https://packagist.phpcomposer.com">https://packagist.phpcomposer.com</a></div><div><br/></div><div><i>/modernphp/ex6.php</i><br/></div><div><br/></div><div><b><font style="font-size: 24px;">四、良好实践</font></b></div><div><br/></div><div><b>A.过滤、验证和转义</b></div><div>1.不要相信任何来自不受自己直接控制的数据源中的数据：$_GET;$_POST;$_REQUEST;$_COOKIE;$argv;php://stdin;php://input;file_get_content();远程数据库;远程API;来自客户端的数据</div><div><br/></div><div>B.过滤输入：转义或删除不安全的字符</div><div>1.HTML使用htmlentities()，需要更多功能可以使用HTML Purifier库</div><div>2.SQL查询使用PDO预处理语句</div><div>3.用户资料信息使用filter_val()和filter_input()函数，如邮件、电话、邮编等，其他组件：aura/filter、respect/validation、symphony/validator等</div><div>4.转义输出htmlentities()</div><div><br/></div><div><b>C.密码：</b>绝不能知道用户的密码；不要约束用户的密码；不能通过电子邮件发送用户的密码； 使用bcrypt计算用户密码的哈希值；password_hash()密码哈希API，password_verify()验证密码是否正确，password_needs_rehash()确认密码哈希值是否符合最新密码算法选项，更新用户密码。</div><div>php5.5之前使用组件：ircmaxell/password-compat</div><div><br/></div><div><b>D.日期、时间和时区</b></div><div>1.使用php5.2.0引入 的DateTime、DateInterval和DateTimeZone类</div><div>2.DateInterval表示长度固定的时间段，或者相对而言的时间段，用于修改DateTime实例</div><div>3.DatePeriod类，处理一段时间内反复出现的一系列日期和时间</div><div>4.日期时间组件：nesbot/carbon</div><div><br/></div><div><b>E.数据库</b></div><div>1.PDO扩展：抽象了不同数据库的具体实现，使用一个接口就能编写和执行数据库查询</div><div>2.要不数据库凭据配置文件可访问下载，应该置于web执行目录以外</div><div>3.使用PDOStatement预处理语句</div><div>$statement = $pdo-&gt;prepare(“select * from xx where a=:a”);</div><div>$statement-&gt;bindValue(“:a”,$a);</div><div>4.查询fetch()和fetchAll():</div><div>PDO::FETCH_ASSOC:返回一个关联数组，键值就是列名</div><div>PDO::FETCH_NUM:返回一个键为数字的数组</div><div>PDO::FETCH_BOTH:返回一个既有列名又有键为数字的数组</div><div>PDO::FETCH_OBJ:让fetch()和fetchAll()返回一个对象，对象的属性是数据库的列名</div><div>只返回一列使用fetchColumn()方法</div><div>5.事务：</div><div>$pdo-&gt;beginTransaction();$pdo-&gt;commit();$pdo-&gt;rollBack();</div><div><br/></div><div><b>F.多字节字符串</b></div><div>1.PHP默认每个字符都是八位字符，占一个字节内存，非英文字符会出错，为避免处理多字节字符串时出错，可以安装mb_string扩展</div><div>2.尽量使用utf8，保证随时知道你现在的字符集，php.ini中default_charset = “UTF-8”</div><div><br/></div><div><b>G.流</b></div><div>1.流是PHP4.3.0中引入 ，作用是使用统一的方式处理文件、网络和数据压缩等共用同一套函数和用法的操作。简单而言，流是具有流式行为的资源对象。因此，流可以线性读写，或许还能使用fseek()函数定位到流中的任何位置</div><div>2.流的作用是在出发 地和目的地之间传输数据，可以理解为管道，包括文件、命令行进程、网络连接、压缩文件、临时内存、标准输入或输出，或者是通过PHP流封装协议实现的任何其他资源</div><div>3.流封装协议：包括开始通信、读取数据 、写入数据、结束通信，协议格式：&lt;scheme&gt;://&lt;target&gt;</div><div>读写文件系统默认使用的file://封装协议</div><div>php://流，与PHP脚本的标准输入、标准输出和标准错误文件描述符通信</div><div>php://stdin，只读php流，来源于标准输入</div><div>php://stdout，把数据写入到当前的输入缓冲区，只能写，无法读</div><div>php://memory，从系统内存中读取数据或写入系统内存</div><div>php://temp，和php://memory类似，不过没有可用内存时会把数据写入临时文件</div><div>4.流上下文：有些PHP能接受一系列可选的参数，这些参数叫流上下文，用于定制流的行为</div><div>使用stream_context_create()函数创建</div><div>5.流过滤器：内置了string.rot13、string.toupper、string.tolower和string.strip_tags，使用stream_filter_appen()函数附加到流上</div><div>php://filter方式：php://filter/read=string.toupper/resource=data.txt</div><div>6.自定义流过滤器</div><div>自定义一个类继承自php_user_filter，至少实现filter方法，使用stream_filter_register()注册到php</div><div><br/></div><div><b>H.错误和异常</b></div><div>1.错误和异常都表明出问题了，都会提供错误信息，而且都有错误类型。然而，错误出现的时间比异常早，错误会导致程序脚本停止执行，如果可能，错误会委托给全局错误处理程序处理，有些错误是无法修改的，我们只需片异常，不用管错误</div><div>2.不建议加上@来不让php触发错误</div><div>3.异常是Exception类的对象，在遇到无法修复的状况时抛出。出现问题时，异常用于主动出击，委托职责；异常还可用于防守，预测潜在的问题，减轻其影响</div><div>4.抛出异常：如果你的代码是提供给其他开发者使用的，遇到异常状况时要主动出击，要抛出异常，把异常委托给使用组件或框架的开发者处理，使用throw关键字，后面跟着要抛出的Exception实例</div><div>5.捕获异常：我们应该捕获异常，然后用优雅的方式处理。使用try/catch来进行捕获</div><div>6.异常处理程序：全局异常捕获使用set_exception_handler()函数注册，使用restore_exception_handler()来还原</div><div>7.错误：可以使用trigger_error()自己触发错误，配置error_reporting进行错误记录</div><div>8.错误处理程序：使用die()或exit()，全局错误处理使用set_error_handler()函数来注册，使用restore_error_handler(0来还原</div><div>9.在开发环境中处理错误可以使用filp/whoops，在生产环境中除error_log()外，还可以使用monolog</div><div><br/></div><div><font style="font-style: italic;">/modernphp/ex7.php</font><br/></div><div><br/></div><div><b><font style="font-size: 24px;">五、主机</font></b></div><div><br/></div><div><b>A.共享主机</b></div><div>1.对开发者不友好，硬件需要共享使用，难以定制</div><div><br/></div><div><b>B.虚拟私有服务器</b></div><div>1.VPS看起来像是祼机服务器，其实由一系列资源组成，分布在一台或多台物理服务器上</div><div><br/></div><div><b>C.专用服务器</b></div><div>1.自己定制的专用独立服务器</div><div><br/></div><div><b>D.PaaS</b></div><div>1.无需自己管理，使用服务商的管理面板即可</div><div><br/></div><div><b><font style="font-size: 24px;">六、调优</font></b></div><div><br/></div><div><b>A.php.ini文件</b></div><div>1.memory_limit设置用于单个php进程可以使用的系统内存最大值</div><div>①一共能分配给php多少系统内存？</div><div>②单个php进程平均消耗多少内存？</div><div>③能负担起多少个php-fpm进程？③</div><div>④有足够的系统资源吗？</div><div>应该使用Apache Bench或Seige等压力测试工具进行测试</div><div><br/></div><div><b>B.Zend OPcache</b></div><div>1.可以缓存编译每个PHP脚本得到的操作码，从缓存中直接读取并执行预先编译好的操作码，不用每次处理HTTP请求时都查找、读取和编译php脚本。5.5.0中内置了Zend OPcache扩展。</div><div>2.主要配置：</div><div>opcache.memory_consumption = 64：为操作友缓存分配内存量</div><div>opcache.interned_strings_buffer = 16：用来存储驻留字符串的内存量，这个设置能让PHP-FPM进程池中的所有进程把驻留字符串存储到共享的缓冲区中</div><div>opcache.max_accelerated_files = 4000：最多能存储多少个PHP脚本</div><div>opcache.validate_timestamps = 1：设置为1后经过一段时间后php会检查 php脚本的内容是否有变化，间隔时间由opcache.revalidate_freq设置指定</div><div>opcache.revalidate_freq = 0：设置多久检查PHP脚本是否有变化 </div><div>opcache.fast_shutdown = 1：这么设置能让操作码使用更快的停机步骤，把对象析构和内存释放交给Zend Engine的内存管理器完成</div><div><br/></div><div><b>C.文件上传</b></div><div>1.主要配置：</div><div>file_uploads = 1：允许上传文件</div><div>upload_max_filesize = 10M：上传文件大小</div><div>max_file_uploads = 3：允许同时上传文件的数量</div><div>2.如果需要上传非常大的文件，需要配置nginx配置中的client_max_body_size</div><div><br/></div><div><b>D.最长执行时间</b></div><div>1.max_execution_time = 5：用于设置单个php进程在终止前最长可以运行多长时间，php脚本中可以调用set_tie_limit()函数来覆盖这个设置</div><div>2.长时间脚本应该使用php脚本后台执行来完成</div><div><br/></div><div><b>E.处理会话</b></div><div>1.PHP默认的会话是存储在硬盘中，会拖慢速度，建议使用memcached或redis来存储</div><div>2.配置php.ini使用memcached来存储会话：</div><div>session.save_handler = ‘memcached’</div><div>session.save_path = ‘127.0.0.1:11211’</div><div><br/></div><div><b>F.缓冲输出</b></div><div>1.如果在较少的块中发送更多的数据，而不是在罗多的块中发送较少的数据，那么网络的效率会更高，因此可以使用PHP缓冲输出</div><div>2.相关配置：</div><div>output_buffering = 4096</div><div>implicit_flush = false</div><div><br/></div><div><b>G.真实路径缓存</b></div><div>1.PHP会缓存应用使用的文件路径，这样每次包含或导入文件时就无需不断搜索包含路径了，这个叫真实路径缓存</div><div>2.realpath_cache_size = 64k</div><div><br/></div><div><b><font style="font-size: 24px;">七、部署</font></b></div><div><br/></div><div><b>A.Capistrano</b></div><div>安装在本地设备中，会在本地设备中执行ssh命令与远程服务器通信，会在远程服务器中保存之前部署的应用，而且每次部署的版本放在各自的目录中，会维护五个或更多之前部署的应用，以防需要回滚到早期版本中，还会他去一个current/目录，通过符号链接指向当前部署的应用所在目录 </div><div><br/></div><div><b><font style="font-size: 24px;">八、测试</font></b></div><div><br/></div><div><b>A.测试什么？</b></div><div>1.应该测试应用的最小组成部分，应该隔离测试每个公开的方法、类和函数，确保表现符合预期。如果我们知道各个部分能单独正常运行，就可以砍集成在一起组成整个应用时也能正常运行，这种测试叫单元测试。但是，单独测试各个部分并不能保证各个部分在整个应用中能正常运行，因此我们还要使用自动化测试工具从宏观上验证应用的整体行为，这种测试叫功能测试。</div><div><br/></div><div><b>B.如何测试？</b></div><div>1.单元测试：PHPUnit</div><div>2.测试驱动开发(TDD)：在编写应用代码之前先写测试，故意让测试失败，以此描述应用应该具有怎样的表现，开发好应用的功能后，最终测试会成功通过。</div><div>3.行为驱动开发(BDD)：编写故事，描述应用的表现。</div><div>SpecBDD：类似于单元测试，使用人类能读懂的故事描述行为</div><div>StoryBDD：也是使用故事描述，但是测试的是整体行为而不是低层实现，流行工具是Behat</div><div><br/></div><div><b>C.PHPUnit</b></div><div>1.PHPUnit测试在一起组成测试用例（test case），测试用例在一起组成测试组件(test suite)，PHPUnit会使用测试运行程序(test runner)运行测试组件</div><div>2.一个测试用例是一个PHP类，这个类扩展自PHPUnit_Framework_TestCase类，测试用例中有一些以test开头的公开方法，一个方法是一个测试，在方法中我们断言会发生特定的事情。断言可能通过，也可能失败。我们的目标是让所有断言通过。测试用例的糊锅必须以Test结尾，而且所在的文件必须以Test.php结尾。</div><div>3.测试组件由一系列相关的测试用例组成，如果测试一个PHP组件，通常只会有一个测试组件；如果测试一个由很多不同的子系统或组件构成的大型PHP应用，最好使用多个测试组件组织测试。</div><div>4.PHPUnit默认使用的是命令行运行程序 ，这个运行程序在终端应用中使用phpunit命令调用。</div><div>5.一次只隔离测试一个指定的方法，理想情况下，测试不能依赖其他方法。</div><div><br/></div><div><b>D.TravisCI持续测试</b></div><div>1.http://travis-ci.org针对公开仓库，https://travis-ci.com针对私有仓库，使用git</div><div><br/></div><div>/modernphp/src/Whovian.php</div><div>/modernphp/tests/*</div><div>/modernphp/phpunit.xml</div><div><br/></div><div><font style="font-size: 24px;"><b>九、分析</b></font></div><div><br/></div><div><b>A.什么时候使用分析器</b></div><div>1.我们无需立即分析PHP应用，遇到难以诊断的性能问题时才需要分析，我们可以使用基准测试工具，如Apache Bench和Siege测试应用的性能，如果发现某个URL每秒能承受的请求数很少，可能表明有性能问题，如果问题不是特别明显，就需要使用分析器</div><div><br/></div><div><b>B.分析器的种类</b></div><div>1.两类：一类在开发环境中使用，一类可以在生产环境中使用</div><div>2.Xdebug，应该在开发环境中使用，结果可以使用KCacheGrind或WinCacheGrind展示结果</div><div>3.XHProf，可以在生产环境中使用，由Facebook开发，使用XHGUI显示结果</div><div>4.New Relic，提供了一个自定议的操作系统守护进程和一个PHP扩展，将其挂在PHP应用上后，会把收集的数据发给这个web服务，不是免费的</div><div>5.Blackfire分析器</div><div><br/></div><div><b>C.Xdebug</b></div><div>1.配置文件</div><div>xdebug.profiler_enable = 0：不让xdebug自动运行</div><div>xdebug.profiler_enable_trigger = 1：需要时启动xdebug，可以在php应用的任何一个URL中加上XDEBUG_PROFILE=1就可以启动xdebug</div><div>xdebug.profiler_output_dir = path：保存分析器生成的报告路径</div><div>2.分析：</div><div>windows:WinCacheGrind</div><div>mac:brew install qcachegrind</div><div>web:WebGrind</div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 