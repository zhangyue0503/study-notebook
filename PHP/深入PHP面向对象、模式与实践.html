<html>
<head>
  <title>深入PHP面向对象、模式与实践</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="2072"/>
<h1>深入PHP面向对象、模式与实践</h1>

<div>
<span><div><font style="font-size: 24px;"><b>一、PHP：设计与管理</b></font></div><div><font style="font-size: 24px;"><b>二、PHP与对象</b></font></div><div><br/></div><div><b><font style="font-size: 24px;">三、对象基础</font></b></div><div><b>A.类和对象</b></div><div>1.类是用于生成对象的代码模板</div><div>2.对象是根据类中定义的模板所构造的数据，对象可以被说成是类的“实例”，它是由类定义的数据类型</div><div><br/></div><div><b>B.设置类中的属性</b></div><div>1.属性也被称为成员变量，用来有些存放对象之间互不相同的数据</div><div>2.不建议动态增加属性到对象</div><div><br/></div><div><b>C.使用方法</b></div><div>1.方法是在类中声明的特殊函数，类似到函数声明，让对象执行任务</div><div>2.$this伪变量（pseudo-variable）把类指向一个对象实例</div><div>3.构造方法[constructor method，也称为构造器（constructor）]会被自动调用，可以用来确保必要的属性被设置，并完成任何需要准备的工作</div><div><br/></div><div><b>D.参数和类型</b></div><div>1.基本类型</div><div><ul><li>判断基本类型：is_bool()、is_integer()、is_double()、is_string()、is_object()、is_array()、is_resource()、is_null()<br/></li><li>Php是一种弱类型的语言，不能依靠编译器来防止类型相关的bug，必须考虑到当非法数据类型的参数传递给方法时，会产生怎样的后果<br/></li></ul></div><div>2.获得提示：对象类型</div><div><ul><li>方法定义清晰易懂，不用担心一些类型错误引起的bug<br/></li><li>不能用于强制规定参数为某种基本数据类型，如字符串和整型<br/></li><li>定义一个类也就定义了一个类型，但是一个类型可以用于描述一个家族的从多类<br/></li></ul></div><div><br/></div><div><b>E.继承</b></div><div>1.子类继承父类的特性，这些特性由属性和方法组成。子类可以增加父类（也称为超类，superclass）之外 的新功能，因此子类也被称为父类的“扩展”</div><div>2.parent::调用父类方法</div><div><br/></div><div><b><font style="font-size: 24px;">四、高级特性</font></b></div><div><b>A.静态方法和属性</b></div><div>1.通过对象访问方法和属性，这样的方法和属性是“静态的”（static），必须用static关键字来声明</div><div>2.静态方法是以类作为作用域的函数，静态方法不能访问这个类中的普通 属性，因为那些属性属于一个对象，但可以访问静态属性，如果修改了一个静态属性，那么这个类的所有实例都能访问这个新值</div><div>3.首先，它们在代码中的任何地方都可用（假设你可以访问该类）。其次，类的每个实例都可以访问类中定义的静态属性，所以你可以利用静态属性来设置值，该值可以被类的所有对象使用</div><div><br/></div><div><b>B.常量属性</b></div><div>1.常量属性用const关键字来声明，不以美元符号开头，通常用大写字母来命名常量</div><div>2.常量属性只包含基本数据类型的值，不能将一个对象指派给常量</div><div>3.给已经声明过的常量赋值会引起解析错误</div><div><br/></div><div><b>C.抽象类</b></div><div>1.不能直接实例人，只定义（或部分实现）子类需要的方法。子类可以继承它并且通过实现其中的抽象方法，使抽象类具体化</div><div><br/></div><div><b>D.接口</b></div><div>1.接口只能定义功能，而不包含实现的内容</div><div>2.一个类可以同时继承一个父类和实现做任意个接口</div><div><br/></div><div><b>E.延迟静态绑定：static关键字</b></div><div>1.static类似于self，但它指的是被调用的类而不是包含类</div><div>2.还可以作为静态方法调用的标识符，甚至是从非静态上下文中调用</div><div><br/></div><div><b>F.错误处理</b></div><div>1.PHP5引入异常（exception），从PHP5内置的Exception类（或其子类）实例化得到的特殊对象，接受两个可选的参数，消息字符串和错误代码</div><div><br/></div><div><b>G.Final类和方法</b></div><div>1.final关键字可以终止类的继承，final类不能有子类，final方法不能被覆写</div><div><br/></div><div><b>H.使用拦截器</b></div><div>1.interceptor方法可以“拦截”发送到未定义方法和属性的消息</div><div>2.__get()、__set()用于处理类（或其父类）中未声明的属性</div><div>3.__isset()当客户在一个未定义的属性上调用isset()时调用，__unset()在一个未定义的属性被调用时调用</div><div>4.__call()方法，当客户端要调用类中未定义的方法时，__call()方法会被调用，接受两个参数，一个是方法的名称，另一个是传递给要调用方法的所有参数（数组），__call()方法返回的任何值都会返回给客户，就好像调用一个真实存在的方法一样</div><div>5.委托是指一个对象转发或者委托一个请求给另一个对象，被委托的一方替碑对象处理请求，使用委托可以在代码运行时改变使用的对象，具有更大的灵活性</div><div><br/></div><div><b>I.析构方法</b></div><div>1.当一个对象调用unset()或进程中不同引用 某个对象时，对象就被销毁了</div><div><br/></div><div><b>J.使用__clone()复制对象</b></div><div>1.clone使用“值复制”的方式（by-value copy）新生成一个对象</div><div>2.可以通过实现__clone()来达到控制复制什么，当调用clone时__clone()方法被调用</div><div><br/></div><div><b>K.定义对象的字符串值</b></div><div>1.使用__toString()方法</div><div><br/></div><div><b>L.回调、匿名函数和闭包</b></div><div>1.利用回调，可以在运行时将与组件的核心任务没有直接关系的功能插入到组件中，有了组件回调，就赋予了其他人在你不知道的上下文中扩展你的代码的权利</div><div>2.is_callable()非常智能，能够测试数组，数组形式的有效回调应该以对象作为其第一个元素，以方法名作为其第二个元素</div><div>3.use子句，可以让匿名函数追踪来自其父作用域的变量</div><div><br/></div><div>/shenruphpmianxiangduixiangmoshiyushijian/4.php</div><div><br/></div><div><b><font style="font-size: 24px;">五、对象工具</font></b></div><div><b>A.PHP和包</b></div><div>1.php5.3之前 ，开发人员必须 在全局上下文中命名文件，解决方案将包名放在类名前面，但项目越复杂后类名就会越长</div><div>2.使用命名空间</div><div>3.使用文件系统模拟包：require_once()，只在文件没有被包含过的情况下才能包含，require比include更好，require比require_once效率更高</div><div>4.PEAR风格的命名方式</div><div>6.包含路径</div><div>7.自动加载：__autoload($classname)</div><div><br/></div><div><b>B.类函数和对象函数</b></div><div>1.PHP允许使用字符串来动态地引用类</div><div>2.class_exists()函数检查类是否存在</div><div>3.get_class()检查对象的类，instanceof对象是否属于某个类</div><div>4.get_class_methods(‘className’)得到一个类中所有方法的列表，is_callable(array(类名，方法名))、method_exists(类名，方法名)检查类中的方法可否被调用</div><div>5.get_class_vars()函数接受类名作为参数，返回类的属性数组</div><div>6.get_parent_class()来找到一个类的父类，is_subclass_of()函数检测类是否是另一个类的派生类，class_implements()使用一个类名或一个对象引用作为参数，并且返回一个由接口名构成的数组</div><div>7.call_user_func()可以调用方法或函数，要调用一个函数需要将字符串作为它的第一个参数，要调用类方法，需要数组，第一个元素是一个对象，第二个元素则是要调用的方法名</div><div>8.call_user_func_array()把目标方法所需的任何参数当做作数组来接受</div><div><br/></div><div><b>C.反射API</b></div><div>1.ReflectionClass提供揭示给定类所有信息的方法，无论这个类是用户定义的还是PHP自带的内置类，相比var_dump()和print_r()提供的细节更多</div><div>2.ReflectionMethod对象可以用于检查类中的方法，通过ReflectionClass::getMethods或ReflectionClass::getMethod(‘')来获取</div><div>3.ReflectionParameter对象返回方法的参数信息，通过ReflectionMethod::getParameters()方法获取</div><div><br/></div><div>/shenruphpmianxiangduixiangmoshiyushijian/5.php<br/></div><div><br/></div><div><b><font style="font-size: 24px;">六、对象与设计</font></b></div><div><b>A.代码设计的定义</b></div><div>1.“代码设计”：确定系统的需求、作用域和目标。是定义系统组成并组织各组件间关系的过程。</div><div><br/></div><div><b>B.面向对象设计和过程式编程</b></div><div>1.面向对象和过程式编程的一个核心区别是如何分配职责。过程式编程表现为一系列命令和方法的连续调用。面向对象编程则将职责从客户端代码中移到专门的对象中，尽量减少相互依赖。</div><div>2.职责：过程式代码忙于处理细节，而面向对象代码只需一个接口即可工作，并且不用考虑实现的细节。由于实现由对象负责，而不是由客户端代码负责，所以我们能够很方便地增加对新格式的支持</div><div>3.内聚（cohesion）：是一个模块内部各成分之间相关联程度的度量，理想情况下应该使各组件职责清晰、分工明确 </div><div>4.耦合：当系统各部分代码紧密绑在一起时，就会产生紧密耦合，这时在一个组件中的变化会迫使其他部件随之改变，过程式代码比较容易产生耦合问题</div><div>5.正交（orthogonality）：指将职责相关的组件紧紧组合在一起，而与外部系统环境隔开，保持独立。正交主张重用组件 ，期望不需要任何特殊配置就能把一个组件插入到新系统中。这样的组件有明确的与环境无关的输入和输出。</div><div><br/></div><div><b>C.选择类</b></div><div>1.面向对象系统经常反映真实的事物，即定义一个类就是找到系统中的事物，然后通过方法给予他们动作</div><div>2.让一个类只有一个主要的职责，并且任务要尽可能独立</div><div><br/></div><div><b>D.多态</b></div><div>1.多态：是指在一个公用接口后面维护多个实现，如果在代码中存在大量条件语句，就说明需要使用多态</div><div>2.多态并没有消除条件语句，但多态可以把条件代码集中到一个地方</div><div>3.PHP强制接口由抽象类定义，可以确定子类会实现抽象父类中定义的所有方法，包括类类型提示和方法的访问控制。客户端代码因此可以使用一个公共父类的任意子类而不需要改写代码</div><div>4.PHP无法强制规定类方法返回的数据类型，意味着不同的子类方法可能返回不同类型的对象或基本数据类型，可以靠人为的约定来使多个方法保持一致</div><div><br/></div><div><b>E.封装</b></div><div>1.封装就是对客户端代码隐藏数据和功能，最简单的办法是将属性定义为private或protected。通过对客户端代码隐藏属性，我们创建了一个接口并防止在偶然情况下污染对象中的数据。</div><div>2.多态是另外一种封装。通过把不同的实现放在公共接口之后，我们对客户端代码隐藏了功能的实现。</div><div>3.从某种程度上说，封装是面向对象编程的关键。目标是使系统中的每一部分都尽可能独立</div><div>4.首先，封装可以帮助我们创建正交的代码。其次，封装的范围不怎么重要，无论封装的规模是大是小，类和客户端代码都必须同时关注封装的实现</div><div><br/></div><div><b>F.忘记细节</b></div><div>1.可以只考虑系统中的关键参与者：项目需要的对象类型和这些对象的接口。不要被经验所左右，而要让代码中的结构和关系来引导你，你会发现一个定义良好的接口之后加入实现代码是很容易的。接着你可以灵活地选择、改进或扩展一个可能需要的实现，而不会影响到外界的系统</div><div>2.为了强调接口，按抽象基类而不是具体的子类来思考</div><div>3.“为接口而不是实现编程”</div><div><br/></div><div><b>G.4个方向标</b></div><div>1.代码重复（duplication）</div><div>2.类知道的太多</div><div>3.万能的类</div><div>4.条件语句</div><div><br/></div><div><b>H.UML</b></div><div>1.类图（class diagram）</div><div><br/></div><div><b><font style="font-size: 24px;">七、什么是设计模式？为何使用它们</font></b></div><div><b>A.什么是设计模式</b></div><div>1.设计模式便是分析过的问题和问题解决方案所阐释的优秀实践</div><div>2.设计模式记录并规范化了这些问题及解决方案，使更广泛的开发社区可获得这些来之不易的经验。模式在本质上讲是（或者说应该是）自下而上而非自上而下的。它们来源于实践而不是空洞的理论。</div><div>3.每个模式都描述着一种在我们的环境中一遍又一遍地出现的问题，并描述了对该问题的核心解决方案，以此方式你可以使用该方案上百万次，而从不需要重复做同样的事情</div><div><br/></div><div><b>B.设计模式概览</b></div><div>1.命名</div><div>2.问题</div><div>3.解决方案</div><div>4.效果</div><div><br/></div><div><b>C.《设计模式》格式</b></div><div>1.意图：模式目的简要概括</div><div>2.动机：需要被解决的问题，通常根据一个典型的情况</div><div>3.适用性：检验不同情况下你是否可以应用某模式</div><div>4.结构/交互：可能包含UML类图和交互图，用于描述解决方案中类和对象之间的关系</div><div>5.实现：着眼于解决方案的细节 </div><div>6.示例代码</div><div>7.已知应用</div><div>8.相关模式</div><div><br/></div><div><b>D.为什么使用设计模式</b></div><div>1.一个设计模式定义了一个问题</div><div>2.一个设计模式定义了一个解决方案</div><div>3.设计模式是语言无关的</div><div>4.模式定义了一组词汇</div><div>5.模式是经过测试的</div><div>6.模式是为协作而设计的</div><div>7.设计模式促进良好设计</div><div><br/></div><div><b><font style="font-size: 24px;">八、模式原则</font></b></div><div><b>A.模式的启示</b></div><div><br/></div><div><b>B.组合与继承</b></div><div>1.继承是就对变化的环境及上下文设计的有效方式，然而它会限制灵活性，尤其当类承担多重责任的时候</div><div>2.组合可以以多种方式动态地处理任务，不过可能导致代码可读性下降，但比使用继承更灵活</div><div><br/></div><div><b>C.解耦</b></div><div>1.当系统中一个组件的改变迫使系统其他许多地方也发生改变的时候，就可诊断为紧耦合了。</div><div>2.最好的策略就是提取代码并将其组合在公共接口之后。这可以使类之间相互独立，通过在一个地方集中你的“入口”代码，就能更轻松地切换到一个新的平台而不会影响到系统中更大的部分</div><div><br/></div><div><b>D.针对接口编程，而不是针对实现编程</b></div><div>1.把不同的实现隐藏在父类所定义的共同接口下，然后客户端代码需要一个父类的对象而不是一个子类的对象，从而使客户端代码可以不用关心它实际得到的是哪个具体的实现</div><div>2.从客户端代码的角度看，类方法参数为抽象或能用类型通常都是不错的主意。如果参数对对象类型要求过于严格，就会限制代码在运动时的灵活性</div><div><br/></div><div><b>E.变化的概念</b></div><div>1.“把变化的概念封装起来”，根据一定条件，变化的元素可被提取出来形成子类，而这些元素共同拥有一个抽象父类。而这个新类型能被其他类使用</div><div>2.好处：专注于职责；通过组合提高灵活性；使继承层级体系更紧凑和集中；减少重复；</div><div><br/></div><div><b>F.父子关系</b></div><div>1.“你还不需要他”，通常被应用在应用程序的功能</div><div>2.“用最简单的方式来完成任务”</div><div><br/></div><div><b>G.模式</b></div><div>1.用于生成对象的模式</div><div>2.用于组织对象和类的模式</div><div>3.面向任务的模式</div><div>4.企业模式</div><div>5.数据库模式</div><div><br/></div><div><b><font style="font-size: 24px;">九、生成对象</font></b></div><div><b>A.生成对象的问题和解决方法</b></div><div>1.对象创建有时会成为面向对象设计的一个薄弱环节</div><div>2.“工厂”（factory）就是负责生成对象的类或方法</div><div><br/></div><div><b>B.单例模式</b></div><div>1.对象应该可以被系统中的任何对象使用</div><div>2.对象不应该被储存在会被覆写的全局变量中</div><div>3.系统中不应超过一个对象</div><div>4.定义一个私有的构造方法外部不可实例化</div><div><br/></div><div><b>C.工厂方法模式</b></div><div>1.在代码运行时我们才知道要生成的对象类型</div><div>2.需要能够相对轻松地加入一些新的产品类型</div><div>3.每一个产品类型都可定制特定的功能</div><div><br/></div><div><b>D.抽象工厂模式</b></div><div>1.将系统与实现的细节分离开来</div><div>2.对系统中功能相关的元素强制进行组合</div><div>3.添加新产品将会令人苦恼</div><div><br/></div><div><b>E.原型模式</b></div><div>1.原型模式：使用PHP的clone关键词复制已存在的具体产品，然后具体产品类本身便成为它们自己生成的基础，使用该模式可以用组合代替继承</div><div><br/></div><div>/shenruphpmianxiangduixiangmoshiyushijian/9.php<br/></div><div><br/></div><div><b><font style="font-size: 24px;">十、让面向对象编程更加灵活的模式</font></b></div><div><b>A.构造可灵活创建对象的类</b></div><div>1.为了使项目更爱具灵活性，我们需要将类按一定结构组织起来，以便它们的对象在代码运行时能被构建为有用的结构。</div><div><br/></div><div><b>B.组合模式</b></div><div>1.组合模式定义了一个单根继承体系，使具有截然不同职责的集合可以并肩工作。组合模式中的类必须支持一个共同的操作集，以将其作为它们的首要职责。</div><div>2.原则是局部类和组合类具有同样的接口</div><div>3.缺点：复杂模型需要类型检查、操作成本、不适合关系型数据库保存适合XML等持久化</div><div>4.想像对待单个对象一样对待组合对象，组合对象本质上和局部对象相似，是树型结构 ，所以对整体的操作会影响到局部，通过组合，对客户端代码来说局部的数据又是透明的。组合模式使这些操作和查询对客户端代码透明。对象树可以方便地进行遍历</div><div><br/></div><div><b>C.装饰模式</b></div><div>1.组合模式帮助我们聚合组件，而装饰模式则使用类似结构来帮助我们改变具体组件的功能。该模式同样体现了组合的重要性，但组合是在代码运行时实现的。继承是共享父类特性的一种简单的办法，但可能会使你将需要改变的特性硬编码到继承体系中，而这常会降低系统灵活性</div><div>2.组合和继承通过都是同时使用的。因为装饰对象作为子对象的包装，所以保持基类中的方法尽可能少是很重要的。</div><div><br/></div><div><b>D.外观模式</b></div><div>1.外观模式是一个十分简单的概念，它只是为一个分层或一个子系统创建一个单一的入口。有助于分享项目中的不同部分、对于客户端开发者来说访问代码变得简洁方便。另外由于只在一个地方调用子系统，减少了出错的可能性，并因此可以预估子系统修改带来的问题所在。</div><div><br/></div><div>/shenruphpmianxiangduixiangmoshiyushijian/10.php<br/></div><div><br/></div><div><b><font style="font-size: 24px;">十一、执行及描述任务</font></b></div><div><b>A.解释器模式</b></div><div>1.解释器类经常执行非常相似的任务，所以最好仔细检查创建的类是否重复</div><div><br/></div><div><b>B.策略模式</b></div><div>1.当类必须支持同一个接口的多种实现时，最好的办法常常是提取出这些实现，并将它们旋转在自己的类型中，而不是通过继承原有的类去支持这些实现</div><div><br/></div><div><b>C.观察者模式</b></div><div>1.观察者模式的核心是把客户元素（观察者）从一个中心类（主体）中分离开来。当主体知道事件发生时，观察者需要被通知到。同时，我们并不希望将主体与观察者之间的关系进行硬编码。</div><div>2.SPL中的SplObserver、SplSubject和SplObjectStorage，为观察者的3个元素，可以直接使用</div><div><br/></div><div><b>D.访问者模式</b></div><div><br/></div><div><b>E.命令模式</b></div><div>1.3部分组成：实例化命令对象的客户端（client）、部署命令对象的调用者（invoker）和接受命令的接收者（receiver）</div><div><br/></div><div>/shenruphpmianxiangduixiangmoshiyushijian/11.php<br/></div><div><br/></div><div><b><font style="font-size: 24px;">十二、企业模式</font></b></div><div><b>A.架构概述</b></div><div>1.模式</div><div><ul><li>注册表：该模式用于使数据对进程对进程中所有的类都有效<br/></li><li>前端控制器：规模较大的系统中，该模式可用于尽可能灵活地管理各种不同的命令和视图<br/></li><li>应用控制器：创建一个类来管理视图连加和命令选择<br/></li><li>模板视图：创建模板来处理和显示用户界面，在显示标记中加入动态内容。尽量少使用原始代码<br/></li><li>页面控制器：满足和前端控制器相同的需求，但较为轻量级，灵活性也小一些<br/></li><li>事务脚本：通过简单的规划，用“过程式”的代码来实现程序逻辑<br/></li><li>领域模式：和事务脚本相反，可以为业务参考者和过程构建基于对象的模型<br/></li></ul></div><div>2.应用程序和层：解耦、测试方便、减少代码重复</div><div><ul><li>视图层包括系统用户实际看到和交互的界面，负责显示用户请求的结果及传递新的请求给系统<br/></li><li>命令和控制层处理用户的请求，委托业务逻辑层处理和满足请求，然后选择最适合的视图，将结果显示给用户。实际上，这个层和视图层常常合并为表现层。即使这样，显示的任务应当严格地与请求处理和业务逻辑调用分离开来<br/></li><li>业务逻辑层负责根据请求执行业务操作。它执行需要的计算并整理结果数据。<br/></li><li>数据层负责保存和获取系统中的持久信息。在某些系统中，命令和控制层使用数据层来获取它所需要的业务对象。但在其他系统中，数据层通常尽可能地被隐藏起来。<br/></li></ul></div><div><br/></div><div><b>B.企业架构之外的基础模式</b></div><div>1.注册表（Registry）模式</div><div><ul><li>注册表类提供静态方法（或单例对象的实例化方法）来让其他对象访问其中的数据（通常是对象）。整个系统中的每个对象都可以访问这些数据对象。<br/></li><li>可以构建一个注册表类来模拟应用程序作用域<br/></li></ul></div><div><br/></div><div><b>C.表现层</b></div><div>1.前端控制器</div><div><ul><li>缺点：需要大量的前期开发工作，每次请求都要加载所有的配置信息<br/></li><li>好处：集中了系统的表现逻辑，易于扩展<br/></li></ul></div><div>2.应用控制器：负责映射请求到命令，并映射命令到视图，可以使用各种机制来创建命令与视图之间的关系，给程序带来更大的灵活性</div><div>3.页面控制器：非常简单、极易理解 </div><div>4.模板视图和视图助手</div><div><br/></div><div><b>D.业务逻辑层</b></div><div>1.事务脚本：事务脚本（Transaction Script）模式：描述了不同系统的实现方式，简单易懂而高效，目的在于完成系统的业务目的</div><div>2.领域模型</div><div><br/></div><div>/shenruphpmianxiangduixiangmoshiyushijian/12.php<br/></div><div><br/></div><div><b><font style="font-size: 24px;">十三、数据库模式</font></b></div><div><b>A.数据层</b></div><div><b>B.数据映射器</b></div><div>1.数据映射器是一个负责将数据映射到对象的类</div><div>2.创建用于将领域模型对象映射到关系型数据库的特定类</div><div><br/></div><div><b>C. 标识映射：</b>跟踪系统中的所有对象，以避免重复实例化或不必要的数据库操作</div><div><br/></div><div><b>D.工作单元</b></div><div>1.工作单元可使你只保存那些需要保存的对象</div><div>2.自动保存对象到数据库，确保只将修改过的对象和新创建的对象插入数据库</div><div>3.延迟加载：延迟创建对象或数据库查询，直到确实需要<br/></div><div><br/></div><div><b>E.领域对象工厂：</b>封装创建对象的功能</div><div><br/></div><div><b>F.标识对象：</b>允许客户端程序员自行组装数据库查询条件，而与底层数据库无关</div><div><br/></div><div><b>G.选择工厂和更新工厂模式</b></div><div>1.包括选择工厂和更新工厂封装创建SQL查询的逻辑</div><div>2.领域对象组装器：创建一个在较高层次管理数据存取的控制器</div><div><br/></div><div><b><font style="font-size: 24px;">十四、良好的糟糕的实践</font></b></div><div><b>A.超越代码</b></div><div><b>B.借一个轮子</b></div><div>1.PEAR（PHP Extension and Application Repository,PHP扩展与应用库）</div><div>2.高效率的程序员只把原创代码看做构建项目的一个工具</div><div><br/></div><div><b>C.合作愉快：</b>Subversion</div><div><br/></div><div><b>D.为你的代码插上双翼：</b>Phing</div><div><br/></div><div><b>E.文档：</b>phpDocumentor</div><div><br/></div><div><b>F.测试</b></div><div><br/></div><div><b>G.持续集成</b></div><div><br/></div><div><b><font style="font-size: 24px;">十五、PEAR和Pyrus</font></b></div><div><b>A.什么是PEAR</b></div><div>1.PEAR的核心部分是许多“包”的集合，可以按功能分成不同的类别，库是集中管理的</div><div>2.PEAR的核心包（PEAR基础类，PEAR Foundation Classes）提供了整个类库的骨架—包括错误处理和对命令行参数的处理等核心功能</div><div><br/></div><div><b>B.了解Pyrus</b></div><div>1.在http://pear2.php.net上下载pyrus.phar</div><div><br/></div><div><b>C. 安装PEAR包</b></div><div>1.pear -o install xxx，-o自动安装依赖包，-a安装所有依赖包</div><div><br/></div><div><b>D.使用PEAR包</b></div><div>1.直接require_once</div><div>2.官方的PEAR包都使用标准的PEAR错误处理类PEAR_Error，5.0版本后的PHP使用PEAR_Exception，将捕获异常而不是检测返回类型</div><div><br/></div><div><b>E.创建自己的PEAR包</b></div><div>1.package.xml</div><div><br/></div><div>/shenruphpmianxiangduixiangmoshiyushijian/15.php<br/></div><div><br/></div><div><b><font style="font-size: 24px;">十六、用phpDocumentor生成文档</font></b></div><div><b>A.为什么要使用文档</b></div><div><b>B.安装（phpDocumentor）</b></div><div>1.pear upgrade PhpDocumentor</div><div><br/></div><div><b>C.生成文档</b></div><div>1.phpdoc -d 目录 -t 生成目录 -ti 项目标题 -dn 默认包名</div><div><br/></div><div><b>D.DocBlock注释</b></div><div>1./**格式</div><div>2.@package 包名</div><div><br/></div><div><b>E.类的文档</b></div><div>1. @author，@copyright</div><div><br/></div><div><b>F.文件的文档</b></div><div>1.@license 指向许可文档的URL和描述性文字</div><div><br/></div><div><b>G.属性的文档</b></div><div>1.@var 定义属性的类型</div><div>2.设置-pp on可显示私有属性</div><div><br/></div><div><b>H.方法的文档</b></div><div>1.@param 参数名称 类型 简述</div><div>2.@return 返回值类型 简要描述</div><div><br/></div><div><b>I.在文档中创建链接</b></div><div>1.@see 元素引用（如class::method()）</div><div>2.@link，@uses</div><div><br/></div><div><b><font style="font-size: 24px;">十七、使用Subversion进行版本控制</font></b></div><div><br/></div><div><b><font style="font-size: 24px;">十八、 使用PHPUnit进行测试</font></b></div><div><b>A.功能测试与单元测试</b></div><div>1.功能测试：从一个项目的接口开始，为用可能使用系统的各种方式建模，也被称为验收测试（acceptance test），通常把系统看做一个黑盒——测试只针对产品功能，并不关注项目内部结构和处理过程</div><div>2.单元测试更加关注于类，并将测试方法组合到测试用例中。目标是尽可能地在隔离周边环境的情况下测试每个组件 。</div><div><br/></div><div><b>B.手工测试</b></div><div><br/></div><div><b>C.引入PHPUnit</b></div><div>1.用composer：composer require phpunit/phpunit</div><div>2.断言：指用来判断系统中某个假设是否成立的语句或方法</div><div><br/></div><div><b>D.编写Web测试</b></div><div>1.PHPUnit方式</div><div>2.Selenium</div><div><br/></div><div><b>E.警告</b></div><div>1.测试可以：</div><div><ul><li>帮助预防bug（开发和重构时）<br/></li><li>帮助发现bug（扩大测试覆盖范围时）<br/></li><li>鼓励你关注于系统设计<br/></li><li>使你不再害怕修改代码会导致比它们所解决的问题更多的问题，从而改进代码设计<br/></li><li>给你迁移代码的信心<br/></li></ul></div><div><br/></div><div>/shenruphpmianxiangduixiangmoshiyushijian/18.php<br/></div><div><br/></div><div><b><font style="font-size: 24px;">十九、用Phing实现项目的自动构建</font></b></div><div><br/></div><div><b><font style="font-size: 24px;">二十、持续集成</font></b></div><div><br/></div><div><b><font style="font-size: 24px;">二十一、对象、模式与实践</font></b></div><div><b>A.对象</b></div><div>1.封装和委托</div><div>2.解耦</div><div>3.复用性</div><div><br/></div><div><b>B.模式</b></div><div>1.经过实践检验</div><div>2.模式促进其他模式的使用</div><div>3.公共词汇表</div><div>4.模式改善设计</div><div><br/></div><div><b>C.模式和设计原则 </b></div><div>1.组合优于继承</div><div>2.避免紧耦合</div><div>3.面向接口编程，而不是面向实现编程</div><div>4.封装变化的概念</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div></div><div><br/></div><div><br/></div><div><br/></div><div></div><div><br/></div></span>
</div></body></html> 