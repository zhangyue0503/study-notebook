<html>
<head>
  <title>PHP大神班-优化：docker、redis、nginx</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="1665"/>
<h1>PHP大神班-优化：docker、redis、nginx</h1>

<div><span><div><div><span style="font-size: 24px; font-weight: bold;">Redis+Docker</span></div><div><span style="font-weight: bold;">1.docker环境+redis主从</span></div><ul><li><div>1）Dockerfile</div></li><ul><li><div>FROM centos:latest</div></li><li><div>RUN groupadd -r redis &amp;&amp; useradd  -r -g redis redis</div></li><li><div>RUN yum -y update &amp;&amp;  yum -y install epel-release &amp;&amp; yum -y install redis &amp;&amp; yum -y install net-tools</div></li><li><div>EXPOSE 6379</div></li></ul><li><div>2）创建网络</div></li><ul><li><div>docker network create --subnet=172.10.0.0/16 mynetwork</div></li></ul><li><div>3）添加节点</div></li><ul><li><div>主节点：docker run -itd --name redis-master --net mynetwork -p 6380:6379 --ip 172.10.0.2 redis</div></li><li><div>从节点：docker run -itd --name redis-slave --net mynetwork -p 6381:6379 --ip 172.10.0.3 redis</div></li><li><div>注意ip段，就可以在一台电脑上组建小局域网</div></li></ul><li><div>4）配置从节点conf文件</div></li><ul><li><div>slaveof &lt;主节点ip&gt; &lt;主节点端口号&gt;</div></li></ul><li><div>5）主从都启动后，主节点添加，从节点查看</div></li><li><div>6）-v /宿主机目录:/容器内部目录，共享目录</div></li></ul><div><span style="font-weight: bold;">2.主从复制原理</span></div><div><img src="PHP大神班-优化：docker、redis、nginx_files/Image.png" type="image/png" data-filename="Image.png" style="font-weight: bold;"/><br/></div><ul><li><div>1）保存主节点信息</div></li><li><div>2）从节点内部通过每秒运行的定时任务维护复制相关逻辑</div></li><ul><li><div>建立socket</div></li><li><div>链接失败重试</div></li></ul><li><div>3）发送ping指令</div></li><ul><li><div>检测连接可用</div></li><li><div>是否可授受处理命令</div></li></ul><li><div>4）权限验证：验证masterauth与主节点相同的密码</div></li><li><div>5）同步数据集：核心处理</div></li><li><div>6）命令持续复制：不是强一致性</div></li></ul><div><span style="font-weight: bold;">3.复制偏移量</span>：info replication查看slave_repl_offset</div><div><span style="font-weight: bold;">4.全量复制过程</span></div><div><img src="PHP大神班-优化：docker、redis、nginx_files/Image [1].png" type="image/png" data-filename="Image.png" style="font-weight: bold;"/><br/></div><ul><li><div>1）redis内部发送全量发送命令，要求master主机同步数据</div></li><li><div>2）向从机发送runid和offset，从机没有offset所以全量</div></li><li><div>3）从机slave保存主机的基本信息</div></li><li><div>4）主节点收到全量复制命令后，执行bgsave（异步执行），后台生成rdb文件（快照），并使用一个缓冲区（复制缓冲区）记录从现在开始执行的所有命令</div></li><li><div>5）主机send RDB发送RDB文件给从机</div></li><li><div>6）发送缓冲区数据</div></li><li><div>7）刷新旧数据，从节点在载入主节点的数据前要清除老数据</div></li><li><div>8）加载RDB文件将数据库状态更新至主节点执行bgsave时的数据库状态</div></li></ul><div><span style="font-weight: bold;">5.全量复制开销，主要有以下几项</span></div><ul><li><div>bgsave 时间</div></li><li><div>RDB 文件网络传输时间</div></li><li><div>从节点清空数据的时间</div></li><li><div>从节点加载 RDB 的时间</div></li><li><div>使用debug reload重启可以不改变runid</div></li></ul><div><span style="font-weight: bold;">6.部分复制</span></div><ul><li><div>1）如果网络抖动</div></li><li><div>2）主机master还是会写replbackbuffer（复制缓冲区）</div></li><li><div>3）从机slave继续尝试连接主机</div></li><li><div>4）从机把自己当前runid和offset传给主机并执行pysnc命令同步</div></li><li><div>5）如果master发现offset是在缓冲区范围内，就返回continue命令</div></li><li><div>6）同步了offset的部分数据，所以部分复制的基础就是offset</div></li></ul><div><span style="font-weight: bold;">7.redis如何决定是全量还是部分</span></div><ul><li><div>根据offset和缓冲区大小决定是否部分复制</div></li><li><div>如果offset之后的数据，仍然在复制积压缓冲区，则部分复制</div></li><li><div>如果不在复制积压缓冲区，则全量</div></li><li><div>复制积压缓冲区大小：配置reel-backlog-size</div></li></ul><div><span style="font-weight: bold;">8.Linux tc工具</span>，模拟网络延迟</div><div><span style="font-weight: bold;">9.主节点不安全情况下的不写入配置</span></div><ul><li><div>min-slaves-to-write，不满足指定数量的从节点不写入</div></li><li><div>min-slaves-max-lag，不满足指定延迟不写入</div></li></ul><div><span style="font-weight: bold;">10.哨兵配置</span></div><ul><li><div>1）redis-sentinel.conf</div></li><li><div>2）sentinel monitor mymaster IP 端口</div></li><li><div>3）redid-sentinel /etc/redis-sentinel.conf，启动</div></li></ul><div><span style="font-weight: bold;">11.哨兵注意所有节点配置</span></div><ul><li><div>1）bind 0.0.0.0，注意绑定的ip，线上要指定好</div></li><li><div>2）protected mode=no</div></li></ul><div><span style="font-weight: bold;">12.哨兵在客户端需要连接哨兵服务器</span></div><div><span style="font-weight: bold;">13.docker编排工具</span>：docker-compose</div><div><span style="font-weight: bold;">14.redis-cluster</span></div><ul><li><div>配置文件打开enable-cluster</div></li><li><div>/var/lib/redis/redis-{port}.conf文件中有节点id，使用cluster nodes查看</div></li><li><div>握手：由客户端发起，cluster meet 节点 端口（注意节点要打开端口，防火墙），虚拟机上用的客户机商品映射，使用的外网ip，如：cluster meet 192.168.56.102 6391</div></li><li><div>从节点上设置：CLUSTER REPLICATE 主节点nodeid（cluster nodes里取到的），设置主从备份，如：redis-cli -p 6396  CLUSTER REPLICATE 56767ba29dbee2f362b44a3c0cb2092951738d01</div></li><li><div>添加槽点，如三台分配：</div></li><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">redis-cli  -p 6391  cluster addslots {0..5461}</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">redis-cli  -p 6392 cluster   addslots {5462..10922}</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">redis-cli  -p  6393 cluster addslots {10923..16383}</span></div></li></ul><li><div>测试：</div></li><ul><li><div>redis-cli -c -p 6394 set aaa 111</div></li><li><div>redis-cli -c -p 6394 get aaa</div></li></ul><li><div>具体文档视频06</div></li></ul><div><span style="font-weight: bold;">15.快速构建集群</span>，使用redis-trib.rb，不需要再手动握手并分配槽点了</div><div><br/></div><div><font style="font-size: 24px;"><span style="font-size: 24px; font-weight: bold;">Nginx</span></font></div><div><span style="font-weight: bold;">1.Web服务器方式：</span></div><ul><li><div>1）多进程方式：当有大量请求时，会导致系统性能下降</div></li><li><div>2）多线程方式：开销小于进程，共享内存，稳定性问题，一个进程挂掉所有线程挂掉</div></li></ul><div><span style="font-weight: bold;">2.pcntl，PHP进程控制</span></div><div><span style="font-weight: bold;">3.eventloop实现io复用</span></div><ul><li><div>EventBase类</div></li><li><div>Event类</div></li></ul><div><span style="font-weight: bold;">4.PHP即时通讯框架Workerman</span></div><div><a href="https://www.workerman.net/">https://www.workerman.net/</a></div><div><span style="font-weight: bold;">5.ngx_http_access_module：</span>限制允许ip进行访问</div><div><span style="font-weight: bold;">6.淘宝nginx文档：</span><a href="http://tengine.taobao.org/nginx_docs/cn/docs/">http://tengine.taobao.org/nginx_docs/cn/docs/</a></div><div><span style="font-weight: bold;">7.USR1信号：</span>重新打开日志文件</div><div><span style="font-weight: bold;">8.限流（漏桶算法）：</span></div><ul><li><div>limit_req_zone</div></li><li><div>limit_conn：设置允许一个IP同时的连接数</div></li></ul><div><span style="font-weight: bold;">9.ngx_http_map_module：</span>创建一些和另外变量相关联的变量，可以做ip白名单配合geo.conf文件</div><div><span style="font-weight: bold;">10.proxy模块：</span>用于将请求抛给其他服务器节点（或应用）或upstream服务器池</div><div><span style="font-weight: bold;">11.动态伸缩：</span>consul、nginx-upsync-module</div><div><b>12.lua脚本</b>：<a href="https://www.nginx.com/resources/wiki/modules/lua/">https://www.nginx.com/resources/wiki/modules/lua/</a></div><div><br/></div><div><b><font style="font-size: 24px;">项目</font></b></div><div>1.</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 