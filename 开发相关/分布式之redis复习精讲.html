<html>
<head>
  <title>分布式之redis复习精讲</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="2593"/>
<h1>分布式之redis复习精讲</h1>

<div><span><h2 style="padding: 0px; font-size: 2em; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: rgb(63, 63, 63); letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 2em; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: rgb(63, 63, 63); letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.5;">引言
</span></h2><h3 style="padding: 0px; font-size: 16px; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 16px; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.5;">为什么写这篇文章?
</span></h3><div>博主的<a href="http://www.cnblogs.com/rjzheng/p/8994962.html" style="color: rgb(0, 0, 0); text-decoration: underline;">《分布式之消息队列复习精讲》</a>得到了大家的好评，内心诚惶诚恐，想着再出一篇关于复习精讲的文章。但是还是要说明一下，复习精讲的文章偏面试准备，真正在开发过程中，还是脚踏实地，一步一个脚印，不要投机取巧。</div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">考虑到绝大部分写业务的程序员，在实际开发中使用redis的时候，只会setvalue和getvalue两个操作，对redis整体缺乏一个认知。又恰逢博主某个同事下周要去培训redis，所以博主斗胆以redis为题材，对redis常见问题做一个总结，希望能够弥补大家的知识盲点。
</span></div><h3 style="padding: 0px; font-size: 16px; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 16px; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.5;">复习要点?
</span></h3><div>本文围绕以下几点进行阐述</div><div><br/></div><div>1、为什么使用redis</div><div><br/></div><div>2、使用redis有什么缺点</div><div><br/></div><div>3、单线程的redis为什么这么快</div><div><br/></div><div>4、redis的数据类型，以及每种数据类型的使用场景</div><div><br/></div><div>5、redis的过期策略以及内存淘汰机制</div><div><br/></div><div>6、redis和数据库双写一致性问题</div><div><br/></div><div>7、如何应对缓存穿透和缓存雪崩问题</div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">8、如何解决redis的并发竞争问题
</span></div><h2 style="padding: 0px; font-size: 2em; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: rgb(63, 63, 63); letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 2em; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: rgb(63, 63, 63); letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.5;">正文
</span></h2><h3 style="padding: 0px; font-size: 16px; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 16px; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.5;">1、为什么使用redis
</span></h3><div><span style="font-weight: bold;">分析</span>:博主觉得在项目中使用redis，主要是从两个角度去考虑:<span style="font-weight: bold;">性能</span>和<span style="font-weight: bold;">并发</span>。当然，redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件(如zookpeer等)代替，并不是非要使用redis。因此，这个问题主要从性能和并发两个角度去答。</div><div><br/></div><div><span style="font-weight: bold;">回答</span>:如下所示，分为两点</div><div><br/></div><div><span style="font-weight: bold;">（一）性能</span></div><div><br/></div><div>如下图所示，我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够<span style="font-weight: bold;">迅速响应</span>。</div><div><br/></div><div><img src="分布式之redis复习精讲_files/Image.png" type="image/png" data-filename="Image.png"/><br/></div><div><br/></div><div><span style="color: red; font-weight: bold;">题外话</span><span style="font-weight: bold;">：</span>忽然想聊一下这个<span style="font-weight: bold;">迅速响应</span>的标准。其实根据交互效果的不同，这个响应时间没有固定标准。不过曾经有人这么告诉我:&quot;在理想状态下，我们的页面跳转需要在<span style="font-weight: bold;">瞬间</span>解决，对于页内操作则需要在<span style="font-weight: bold;">刹那</span>间解决。另外，超过<span style="font-weight: bold;">一弹指</span>的耗时操作要有进度提示，并且可以随时中止或取消，这样才能给用户最好的体验。&quot;</div><div><br/></div><div>那么<span style="font-weight: bold;">瞬间、刹那、一弹指</span>具体是多少时间呢？</div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">根据《摩诃僧祗律》记载
</span></div><div style="padding: 0px; white-space: pre-wrap; word-wrap: break-word; font-size: 14px; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="white-space: pre-wrap; word-wrap: break-word; letter-spacing: normal; text-indent: 0px; text-transform: none; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; vertical-align: middle; overflow-x: auto; background-color: rgb(255, 255, 255); font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-top-left-radius: 3px !important; border-top-right-radius: 3px !important; border-bottom-right-radius: 3px !important; border-bottom-left-radius: 3px !important; color: rgb(0, 0, 0); font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5; font-family: &quot;Courier New&quot;, sans-serif; background-position: initial initial; background-repeat: initial initial;">一刹那者为一念，二十念为一瞬，二十瞬为一弹指，二十弹指为一罗预，二十罗预为一须臾，一日一夜有三十须臾。</span></div><div>那么，经过周密的计算，一<span style="font-weight: bold;">瞬间</span>为0.36 秒,一<span style="font-weight: bold;">刹那</span>有 0.018 秒.一<span style="font-weight: bold;">弹指</span>长达 7.2 秒。</div><div><br/></div><div><span style="font-weight: bold;">（二）并发</span></div><div><br/></div><div>如下图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。</div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><img src="分布式之redis复习精讲_files/Image [1].png" type="image/png" data-filename="Image.png"/><span style="-en-paragraph:true;">
</span></div><h3 style="padding: 0px; font-size: 16px; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 16px; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.5;">2、使用redis有什么缺点
</span></h3><div><span style="font-weight: bold;">分析</span>:大家用redis这么久，这个问题是必须要了解的，基本上使用redis都会碰到一些问题，常见的也就几个。</div><div><br/></div><div><span style="font-weight: bold;">回答</span>:主要是四个问题</div><div><br/></div><div>(一)缓存和数据库双写一致性问题</div><div><br/></div><div>(二)缓存雪崩问题</div><div><br/></div><div>(三)缓存击穿问题</div><div><br/></div><div>(四)缓存的并发竞争问题</div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这四个问题，我个人是觉得在项目中，比较常遇见的，具体解决方案，后文给出。
</span></div><h3 style="padding: 0px; font-size: 16px; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 16px; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.5;">3、单线程的redis为什么这么快
</span></h3><div><span style="font-weight: bold;">分析</span>:这个问题其实是对redis内部机制的一个考察。其实根据博主的面试经验，很多人其实都不知道redis是单线程工作模型。所以，这个问题还是应该要复习一下的。</div><div><br/></div><div><span style="font-weight: bold;">回答</span>:主要是以下三点</div><div><br/></div><div>(一)纯内存操作</div><div><br/></div><div>(二)单线程操作，避免了频繁的上下文切换</div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">(三)采用了非阻塞</span><span style="font-weight: bold;-en-paragraph:true;">I/O多路复用机制</span><span style="-en-paragraph:true;">
</span></div><div><span style="color: red; font-weight: bold;">题外话</span><span style="font-weight: bold;">：</span>我们现在要仔细的说一说I/O多路复用机制，因为这个说法实在是太通俗了，通俗到一般人都不懂是什么意思。博主打一个比方：小曲在S城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了<span style="font-weight: bold;">一批</span>快递员，然后小曲发现资金不够了，只够买<span style="font-weight: bold;">一辆</span>车送快递。</div><div><br/></div><div><span style="font-weight: bold;">经营方式一</span></div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在下述问题
</span></div><ul style="padding: 0px; font-size: 14px; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><li style="padding: 0px; list-style-type: disc;"><div><span style="color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 25.2px;">几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递</span></div></li><li style="padding: 0px; list-style-type: disc;"><div><span style="color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 25.2px;">随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了</span></div></li><li style="padding: 0px; list-style-type: disc;"><div><span style="color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 25.2px;">快递员之间的协调很花时间</span></div></li></ul><div>综合上述缺点，小曲痛定思痛，提出了下面的经营方式</div><div><br/></div><div><span style="font-weight: bold;">经营方式二</span></div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按</span><span style="font-weight: bold;-en-paragraph:true;">送达地点</span><span style="-en-paragraph:true;">标注好，然后</span><span style="font-weight: bold;-en-paragraph:true;">依次</span><span style="-en-paragraph:true;">放在一个地方。最后，那个快递员</span><span style="font-weight: bold;-en-paragraph:true;">依次</span><span style="-en-paragraph:true;">的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。
</span></div><div><span style="font-weight: bold;">对比</span></div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">上述两种经营方式对比，是不是明显觉得第二种，效率更高，更好呢。在上述比喻中:
</span></div><ul style="padding: 0px; font-size: 14px; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><li style="padding: 0px; list-style-type: disc;"><div><span style="color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 25.2px;">每个快递员------------------&gt;每个线程</span></div></li><li style="padding: 0px; list-style-type: disc;"><div><span style="color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 25.2px;">每个快递--------------------&gt;每个socket(I/O流)</span></div></li><li style="padding: 0px; list-style-type: disc;"><div><span style="color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 25.2px;">快递的送达地点--------------&gt;socket的不同状态</span></div></li><li style="padding: 0px; list-style-type: disc;"><div><span style="color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 25.2px;">客户送快递请求--------------&gt;来自客户端的请求</span></div></li><li style="padding: 0px; list-style-type: disc;"><div><span style="color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 25.2px;">小曲的经营方式--------------&gt;服务端运行的代码</span></div></li><li style="padding: 0px; list-style-type: disc;"><div><span style="color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 25.2px;">一辆车----------------------&gt;CPU的核数</span></div></li></ul><div>于是我们有如下结论</div><div><br/></div><div>1、经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。</div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">2、经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。
</span></div><div>下面类比到真实的redis线程模型，如图所示</div><div><br/></div><div><img src="分布式之redis复习精讲_files/Image [2].png" type="image/png" data-filename="Image.png"/><br/></div><div><br/></div><div>参照上图，简单来说，就是。我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。</div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">需要说明的是，这个I/O多路复用机制，redis还提供了select、epoll、evport、kqueue等多路复用函数库，大家可以自行去了解。
</span></div><h3 style="padding: 0px; font-size: 16px; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 16px; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.5;">4、redis的数据类型，以及每种数据类型的使用场景
</span></h3><div><span style="font-weight: bold;">分析</span>：是不是觉得这个问题很基础，其实我也这么觉得。然而根据面试经验发现，至少百分八十的人答不上这个问题。建议，在项目中用到后，再类比记忆，体会更深，不要硬记。基本上，一个合格的程序员，五种类型都会用到。</div><div><br/></div><div><span style="font-weight: bold;">回答</span>：一共五种</div><div><br/></div><div>(一)String</div><div><br/></div><div>这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做<span style="color: red; font-weight: bold;">一些复杂的计数功能的缓存。</span></div><div><br/></div><div>(二)hash</div><div><br/></div><div>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做<span style="color: red; font-weight: bold;">单点登录</span>的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</div><div><br/></div><div>(三)list</div><div><br/></div><div>使用List的数据结构，可以<span style="color: red; font-weight: bold;">做简单的消息队列的功能</span>。另外还有一个就是，可以利用lrange命令，<span style="color: red; font-weight: bold;">做基于redis的分页功能</span>，性能极佳，用户体验好。</div><div><br/></div><div>(四)set</div><div><br/></div><div>因为set堆放的是一堆不重复值的集合。所以可以做<span style="color: red; font-weight: bold;">全局去重的功能</span>。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。</div><div><br/></div><div>另外，就是利用交集、并集、差集等操作，可以<span style="color: red; font-weight: bold;">计算共同喜好，全部的喜好，自己独有的喜好等功能</span>。</div><div><br/></div><div>(五)sorted set</div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做</span><span style="color: red; font-weight: bold;-en-paragraph:true;">排行榜应用，取TOP N操作</span><span style="-en-paragraph:true;">。另外，参照另一篇</span><a href="https://www.cnblogs.com/rjzheng/p/8972725.html" style="color: rgb(0, 0, 0); text-decoration: underline;-en-paragraph:true;">《分布式之延时任务方案解析》</a><span style="-en-paragraph:true;">，该文指出了sorted set可以用来做</span><span style="color: red; font-weight: bold;-en-paragraph:true;">延时任务</span><span style="-en-paragraph:true;">。最后一个应用就是可以做</span><span style="color: red; font-weight: bold;-en-paragraph:true;">范围查找</span><span style="-en-paragraph:true;">。
</span></div><h3 style="padding: 0px; font-size: 16px; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 16px; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.5;">5、redis的过期策略以及内存淘汰机制
</span></h3><div><span style="font-weight: bold;">分析</span>:这个问题其实相当重要，到底redis有没用到家，这个问题就可以看出来。比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?</div><div><br/></div><div><span style="font-weight: bold;">回答</span>:</div><div><br/></div><div>redis采用的是定期删除+惰性删除策略。</div><div><br/></div><div><span style="font-weight: bold;">为什么不用定时删除策略?</span></div><div><br/></div><div>定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.</div><div><br/></div><div><span style="font-weight: bold;">定期删除+惰性删除是如何工作的呢?</span></div><div><br/></div><div>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。</div><div><br/></div><div>于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</div><div><br/></div><div><span style="font-weight: bold;">采用定期删除+惰性删除就没其他问题了么?</span></div><div><br/></div><div>不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用<span style="font-weight: bold;">内存淘汰机制</span>。</div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">在redis.conf中有一行配置
</span></div><div style="padding: 0px; white-space: pre-wrap; word-wrap: break-word; font-size: 14px; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="white-space: pre-wrap; word-wrap: break-word; letter-spacing: normal; text-indent: 0px; text-transform: none; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; vertical-align: middle; overflow-x: auto; background-color: rgb(255, 255, 255); font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-top-left-radius: 3px !important; border-top-right-radius: 3px !important; border-bottom-right-radius: 3px !important; border-bottom-left-radius: 3px !important; color: rgb(43, 145, 175); font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5; font-family: &quot;Courier New&quot;, sans-serif; background-position: initial initial; background-repeat: initial initial;"># maxmemory-policy volatile-lru</span></div><div>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)</div><div><br/></div><div>1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。<span style="color: red; font-weight: bold;">应该没人用吧。</span></div><div><br/></div><div>2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。<span style="color: red; font-weight: bold;">推荐使用，目前项目在用这种。</span></div><div><br/></div><div>3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。<span style="color: red; font-weight: bold;">应该也没人用吧，你不删最少使用Key,去随机删。</span></div><div><br/></div><div>4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。<span style="color: red; font-weight: bold;">这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐</span></div><div><br/></div><div>5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。<span style="color: red; font-weight: bold;">依然不推荐</span></div><div><br/></div><div>6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。<span style="color: red; font-weight: bold;">不推荐</span></div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。
</span></div><h3 style="padding: 0px; font-size: 16px; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 16px; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.5;">6、redis和数据库双写一致性问题
</span></h3><div><span style="font-weight: bold;">分析</span>:一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是<span style="font-weight: bold;">如果对数据有强一致性要求，不能放缓存。</span>我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说<span style="font-weight: bold;">降低不一致发生的概率</span>，无法完全避免。因此，有强一致性要求的数据，不能放缓存。</div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;-en-paragraph:true;">回答</span><span style="-en-paragraph:true;">:</span><a href="https://www.cnblogs.com/rjzheng/p/9041659.html" style="color: rgb(0, 0, 0); text-decoration: underline;-en-paragraph:true;">《分布式之数据库和缓存双写一致性方案解析》</a><span style="-en-paragraph:true;">给出了详细的分析，在这里简单的说一说。首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。
</span></div><h3 style="padding: 0px; font-size: 16px; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 16px; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.5;">7、如何应对缓存穿透和缓存雪崩问题
</span></h3><div><span style="font-weight: bold;">分析</span>:这两个问题，说句实在话，一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，流量有几百万左右。这两个问题一定要深刻考虑。</div><div><br/></div><div><span style="font-weight: bold;">回答</span>:如下所示</div><div><br/></div><div><span style="font-weight: bold;">缓存穿透</span>，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</div><div><br/></div><div><span style="color: red; font-weight: bold;">解决方案</span>:</div><div><br/></div><div>(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试</div><div><br/></div><div>(二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做<span style="font-weight: bold;">缓存预热</span>(项目启动前，先加载缓存)操作。</div><div><br/></div><div>(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。</div><div><br/></div><div><span style="font-weight: bold;">缓存雪崩</span>，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。</div><div><br/></div><div><span style="color: red; font-weight: bold;">解决方案</span>:</div><div><br/></div><div>(一)给缓存的失效时间，加上一个随机值，避免集体失效。</div><div><br/></div><div>(二)使用互斥锁，但是该方案吞吐量明显下降了。</div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">(三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点
</span></div><ul style="padding: 0px; font-size: 14px; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><li style="padding: 0px; list-style-type: disc;"><div><span style="color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 25.2px;">I 从缓存A读数据库，有则直接返回</span></div></li><li style="padding: 0px; list-style-type: disc;"><div><span style="color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 25.2px;">II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。</span></div></li><li style="padding: 0px; list-style-type: disc;"><div><span style="color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 25.2px;">III 更新线程同时更新缓存A和缓存B。</span></div></li></ul><h3 style="padding: 0px; font-size: 16px; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 16px; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.5;">8、如何解决redis的并发竞争key问题
</span></h3><div><span style="font-weight: bold;">分析</span>:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主<span style="font-weight: bold;">不推荐使用redis的事务机制。</span>因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，<span style="font-weight: bold;">redis的事务机制，十分鸡肋。</span></div><div><br/></div><div><span style="font-weight: bold;">回答:</span>如下所示</div><div><br/></div><div>(1)如果对这个key操作，<span style="font-weight: bold;">不要求顺序</span></div><div><br/></div><div>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。</div><div><br/></div><div>(2)如果对这个key操作，<span style="font-weight: bold;">要求顺序</span></div><div><br/></div><div>假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.</div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">期望按照key1的value值按照 valueA--&gt;valueB--&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下
</span></div><div style="padding: 0px; white-space: pre-wrap; word-wrap: break-word; font-size: 14px; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><div><span style="vertical-align: middle; overflow-x: auto; background-color: rgb(255, 255, 255); font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-top-left-radius: 3px !important; border-top-right-radius: 3px !important; border-bottom-right-radius: 3px !important; border-bottom-left-radius: 3px !important; color: rgb(0, 0, 0); font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5; font-family: &quot;Courier New&quot;, sans-serif; background-position: initial initial; background-repeat: initial initial;">系统A key 1 {valueA  3:00}</span></div><div><span style="vertical-align: middle; overflow-x: auto; background-color: rgb(255, 255, 255); font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-top-left-radius: 3px !important; border-top-right-radius: 3px !important; border-bottom-right-radius: 3px !important; border-bottom-left-radius: 3px !important; color: rgb(0, 0, 0); font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5; font-family: &quot;Courier New&quot;, sans-serif; background-position: initial initial; background-repeat: initial initial;">系统B key 1 {valueB  3:05}</span></div><div><span style="vertical-align: middle; overflow-x: auto; background-color: rgb(255, 255, 255); font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-top-left-radius: 3px !important; border-top-right-radius: 3px !important; border-bottom-right-radius: 3px !important; border-bottom-left-radius: 3px !important; color: rgb(0, 0, 0); font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5; font-family: &quot;Courier New&quot;, sans-serif; background-position: initial initial; background-repeat: initial initial;">系统C key 1 {valueC  3:10}</span></div></div><div style="padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; text-align: start; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 25.2px;-en-paragraph:true;">那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。
</span></div><div style="padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; text-align: start; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 25.2px;-en-paragraph:true;">其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。
</span></div><h2 style="padding: 0px; font-size: 2em; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: rgb(63, 63, 63); letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 2em; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: rgb(63, 63, 63); letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.5;">总结
</span></h2><div><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 25.2px;-en-paragraph:true;">本文对redis的常见问题做了一个总结。大部分是博主自己在工作中遇到，以及以前面试别人的时候，爱问的一些问题。另外，</span><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 25.2px;-en-paragraph:true;">不推荐大家临时抱佛脚</span><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 25.2px;-en-paragraph:true;">，真正碰到一些有经验的工程师，其实几下就能把你问懵。
</span></div><div><span style="font-family: Verdana;"><u><br/></u></span></div><div></div></span>
</div></body></html> 