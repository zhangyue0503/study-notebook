<html>
<head>
  <title>数据结构与算法之美</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="834"/>
<h1>数据结构与算法之美</h1>

<div><span><div><span style="font-weight: bold;">广义上：</span><span style="font-size: 18px; font-weight: bold;">数据结构</span>就是指一组数据的存储结构。<span style="font-size: 18px; font-weight: bold;">算法</span>就是操作数据的一组方法。</div><div><br/></div><div>数据结构是为算法服务的，算法要作用在特定的数据结构之上。</div><div><br/></div><div>代码：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。所有代码的执行 T(n) 与每行代码的执行次数 n 成正比。</div><div><br/></div><div><span style="font-size: 18px; font-weight: bold;">大 O 时间复杂度</span>实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以也叫作渐进时间复杂度，简称时间复杂度。</div><div><br/></div><div><span style="font-size: 18px; font-weight: bold;">如何分析一段代码的时间复杂度？</span></div><ul><li><div>1）只关注循环执行次数最多的一段代码。核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。</div></li><li><div>2）加法法则：总复杂度等于量级最大的那段代码的复杂度。</div></li><ul><li><div>即使代码循环1000、10000次，只要这个 n 是一个已知的数，跟未知的 n 无关，那么它也是常量级。</div></li></ul><li><div>3）乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。</div></li><ul><li><div>可以把这个法则看成是嵌套循环。</div></li></ul></ul><div><br/></div><div><span style="font-size: 18px; font-weight: bold;">O(1)：</span>只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度都记记作 O(1)。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是 O(1) 。</div><div><br/></div><div><span style="font-size: 18px; font-weight: bold;">O(logn)、O(nlogn)：</span>等比数列对数阶，只要知道 x 就知道要循环多少次了。不管是以2为底还是以3为底，还是以10为底，都记做 O(logn) 。嵌套循环有一层为 logn 就可以记作 O(n*logn) = O(nlogn) 。</div><div><br/></div><div>whille(i&lt;=n){</div><div>    i=i*2;</div><div>}</div><div> </div><div><span style="font-size: 18px; font-weight: bold;">O(m+n)、O(m*n)：</span>m 和 n 分别表示两个不同的数据规模，无法评估谁的量级大，就可以使用这样的表示。</div><div><br/></div><div><span style="font-size: 18px; font-weight: bold;">数组</span>最大的特点是：连续的内存空间和相同类型的数据。数组根据下标随机访问的时间复杂度为 O(1) 。（注意，不是数组的查找时间复杂度为 O(1)，使用 二分查找 数组也得是 O(logN) ）</div><div><br/></div><div><span style="font-size: 18px; font-weight: bold;">链表</span>最大特点：通过指针将一组零散的内存块串联在一起。插入和删除都是  O(1) ，但问题是无法随机访问，所以查找到你需要操作的结点就得 O(n) 遍历。</div><div><br/></div><div><span style="font-size: 18px; font-weight: bold;">递归</span>需要满足的三个条件：</div><ul><li><div>1.一个问题的解可以分解为几个子问题的解</div></li><li><div>2.这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</div></li><li><div>3.存在递归终止条件</div></li></ul><div><br/></div><div><span style="font-size: 18px; font-weight: bold;">跳表：</span>链表+多级索引结构（可以实现链表的二分查找）</div><div><img src="数据结构与算法之美_files/Image.jpg" type="image/jpeg" data-filename="Image.jpg"/><br/></div><div><br/></div><div><span style="font-weight: bold; font-size: 18px;">堆：</span></div><ul><li><div>一个完全二叉树</div></li><li><div>每个节点的值都大于等于（或小于等于）其子树节点的值（大顶堆、小顶堆）</div></li></ul><div><br/></div><div><span style="font-weight: bold; font-size: 18px;">堆化：</span></div><ul><li><div>插入一个数据的时候，把新插入的数据放到数组的最后，然后从下往上堆化（交换）</div></li><li><div>删除推顶数据的时候，把数组中的最后一个元素放到堆顶，然后从上往下堆化</div></li></ul><div><br/></div><div><span style="font-weight: bold; font-size: 18px;">堆排序：</span>包含两个过程，建堆和排序。将下标从n/2到1的节点，依次进行从上到下的推化操作，然后就可以将数组中的数据组织成堆这种数据结构。接下来，迭代地将堆顶的元素放到堆的末尾，并将堆的大小减一，然后再堆化，重复这个过程，直到堆中只剩下一个元素，整个数组中的数据就都是有序排列的了</div><div><br/></div><div><b><font style="font-size: 18px;">字符串匹配：</font></b></div><ul><li><div><b>BF算法：</b>暴力匹配，一个一个对，不行就整个后移，O(n*m)</div></li><li><div><b>RK算法：</b>借助哈希算法对BF算法进行改造，即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较时间，理想状态下O(n)，极端情况下退化为O(n*m)</div></li><li><div><b>BM算法：</b>利用模式串本身的特点，在械串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配效率。算法规则有两类，坏字符规则和好后缀规则</div></li><li><div><b>KMP算法：</b>借鉴BM算法的思想，好后缀规则，增加next数组，O(n+m)</div></li><li><div><b>Trie树：</b>多模式匹配，耗费内存，高效，查找前缀匹配的字符串，如搜索引擎的关键词提示功能</div></li><li><div><b>AC自动机：</b>Trie树的基础上增加类似KMP的next数组（失败指针）</div></li></ul><div><br/></div><div><b><font style="font-size: 18px;">贪心算法：</font></b>霍夫曼编码、Prim、Kruskal、Dijkstra 等都会用到</div><ul><li><div>针对一组数据，定义了限制值和期望值，系统从中选出几个数据，在满足限制值的情况下，期望值最大</div></li><li><div><span>每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据</span></div></li><li><div><span>专注于当下最优，但可能无法取得全局最优</span></div></li></ul><div><span><br/></span></div><div><b><font style="font-size: 18px;">分治算法：</font></b>“分而治之”，将问题划分成 n 个规模较小而结构与原问题相似的子问题，递归地解决这些子问，然后再合并其结果，就得到原问题的解。可以降低问题求解的时间复杂度，或者解决觉海量数据处理问题，比如 MapReduce</div><div><span><br/></span></div><div><span><b><font style="font-size: 18px;">回溯算法：</font></b>解决广义的搜索问题，从一组可能的解中，选择出一个满足要求的解。非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。可以解决八皇后、0-1背包问题、图的着色、旅行商、数独、全排列、正则表达式匹配等问题</span></div><div><span><span><br/></span></span></div><div><span><span><b><font style="font-size: 18px;">动态规划：</font></b></span></span></div><ul><li><div>“一个模型”：问题可以抽象成分阶段决策的最优解模型</div></li><li><div>“三个特征”：最优子结构、无后效性和重复子问题</div></li><li><div>状态转移表法：回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码</div></li><li><div>状态转移方程法：找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码</div></li></ul><div><br/></div><div><br/></div><div><span><br/></span></div><div><br/></div></span>
</div></body></html> 