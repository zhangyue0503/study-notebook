<html>
<head>
  <title>大话数据结构</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="2077"/>
<h1>大话数据结构</h1>

<div>
<span><div><b><font style="font-size: 24px;">一、数据结构绪论</font></b></div><div><b>A.数据结构起源</b></div><div>1.数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。</div><div>2.程序设计=数据结构+算法</div><div><br/></div><div><b>B.基本概念和术语</b></div><div>1.数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合</div><div>2.数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。</div><div>3.数据项：一个数据元素可以上若干个数据项组成。数据项是数据不可分割的最小单位</div><div>4.数据对象：是性质相同的数据元素的集合，是数据的子集</div><div>5.数据结构：是相互之间存在一种或多种特定关系的数据元素的集合</div><div><br/></div><div><b>C.逻辑结构与物理结构</b></div><div>1.逻辑结构：数据对象中数据元素之间的相互关系</div><div><ul><li>集合结构：数据元素除了同属于一个集合外，它们之间没有其他关系。<br/></li><li>线性结构：数据元素之间是一对一的关系<br/></li><li>树形结构：数据元素之间存在一种一对多的层次关系<br/></li><li>图形结构：数据元素之间是多对多的关系<br/></li></ul></div><div>2.物理结构：指数据的逻辑结构在计算机中的存储形式</div><div><ul><li>顺序存储结构：把数据元素放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的（数组）<br/></li><li>链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的<br/></li></ul></div><div><br/></div><div><b>D.抽象数据类型</b></div><div>1.数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</div><div><b>C语言中数据类型：</b></div><div><ul><li>原子类型，不可以再分解 的基本类型；<br/></li><li>结构类型，由若干个类型组合而成，是可以再分解的；<br/></li></ul></div><div>2.抽象是指抽取出事物具有的普遍性的本质。</div><div>3.抽象数据类型（Abstract Data Type,ADT）：是指一个数学模型及定义在该模型上的一组操作。</div><div><ul><li>抽象的意义在于数据类型的数学抽象特性。<br/></li><li>一个抽象数据类型定义了：一个数据对象、数据对象中各数据元素之间的关系及对数据元素的操作。<br/></li><li>抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。<br/></li></ul></div><div><br/></div><div><b><font style="font-size: 24px;">二、算法</font></b></div><div><b>A.算法</b></div><div>1.算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作</div><div><br/></div><div><b>B.算法的特性</b></div><div>1.输入输出：算法有零个或多个输入，算法至少有一个或多个输出</div><div>2.有穷性：指算法在执行有限的步骤后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成</div><div>3.确定性：算法的每一步骤都具有确定的含义，不会出现二义性</div><div>4.可执行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成</div><div><br/></div><div><b>C.算法设计的要求</b></div><div>1.正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案</div><div><ul><li>算法程序没有语法错误<br/></li><li>算法程序对于合法的输入数据能够产生满足要求的输出结果<br/></li><li>算法程序对于非法的输入数据能够得出满足规格说明的结果<br/></li><li>算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果<br/></li></ul></div><div>2.可读性：算法设计的另一目的是为了便于阅读、理解和交流</div><div>3.健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果</div><div>4.时间效率高和存储量低：时间效率指的是算法的执行时间，对于同一个问题，如果有多个算法能够解决，执行时间短的算法效率高，执行时间长的效率低。存储量需求指的是算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间</div><div><br/></div><div><b>D.算法效率的度量方法</b></div><div>1.事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。缺点：</div><div><ul><li>必须依据算法事先编制好程序<br/></li><li>时间的比较依赖计算机硬件和软件等环境因素<br/></li><li>算法的测试数据设计困难<br/></li></ul></div><div>2.事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算</div><div><ul><li>一个程序的运行时间，依赖于算法的好坏和问题的输入规模。所谓问题输入规模是指输入量的多少。<br/></li><li>在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。<br/></li></ul></div><div><br/></div><div><b>E.函数的渐近增长</b></div><div>1.函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有n&gt;N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)</div><div>2.最高次项相乘的常数并不重要</div><div>3.最高次项的指数大的，函数随着n的增长，结果也变得增长特别快</div><div>4.判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数</div><div>5.某个算法，随着n的增大，它会越来越优于另一算法，或者越来越差于另一算法</div><div><br/></div><div><b>F.算法时间复杂度</b></div><div>1.算法时间复杂度：在进行算法分析时，语句总执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作T(n)=O(f(n))。它表示问题规模的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。</div><div>2.推导大O阶方法</div><div><ul><li>用常数1取代运行时间中的所有加法常数<br/></li><li>在修改后的运行次数函数中，只保留最高阶项<br/></li><li>如果最高阶项存在且不是1，则去除与这个项相乘的常数<br/></li></ul></div><div>3.常数阶：与问题的大小无关（n的多少），执行时间恒定的算法，我们称之为具有O(1)的时间复杂度，又称为常数阶</div><div>4.线性阶：分析算法的复杂度，关键就是要分析循环结构的运行情况，如一个为n的循环就是O(n)</div><div>5.对数阶：在循环中i*2之后，有多少个i*2就会大于n，由2x=n，x=log2n，时间复杂度为O(log2n)</div><div>6.平方阶：嵌套循环，例如两层循环，基本上心O(n2)为主</div><div><br/></div><div><b>G.常见的时间复杂度</b></div><div>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</div><div><br/></div><div><b>H.最坏情况与平均情况</b></div><div>1.最坏情况是一种保证，除特殊情况，我们提到的运行时间都是最坏情况运行时间（最坏时间复杂度）</div><div>2.平均运行时间是最有意义的，因为它是期望的运行时间（平均时间复杂度）</div><div><br/></div><div><b>I.算法空间复杂度</b></div><div>1.算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中n为问题的规模，f(n)为语句关于n所占存储空间的函数</div><div><br/></div><div>/shujujiegou/1.c</div><div><br/></div><div><b><font style="font-size: 24px;">三、线性表</font></b></div><div><b>A.线性表的定义</b></div><div>1.线性表（List）：零个或多个数据元素的有限序列。</div><div>2.线性表元素的个数n(n&gt;=0)定义为线性表的长度，当n=0时，称为空表。</div><div>3.在较复杂的线性表中，一个数据元素可以由若干个数据项组成</div><div><br/></div><div><b>B.线性表的顺序存储结构</b></div><div>1.线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</div><div>2.一维数组实现顺序存储结构，三个属性：存储空间的起始位置、线性表的最大存储容量、线性表当前的长度</div><div>3.数组长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的；线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作操作的进行，这个量是变化的。</div><div>4.存储器中每个存储单元都有自己的编号，这个编号称为地址</div><div><br/></div><div><b>C.线性存储结构的插入与删除</b></div><div>1.插入算法思路：</div><div><ul><li>如果插入位置不合理，抛出异常；<br/></li><li>如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；<br/></li><li>从最后一个元素向前遍历到第i个位置，分别将它们都向后移动一个位置；<br/></li><li>将要插入元素填入位置i处；<br/></li><li>表长加1；<br/></li></ul></div><div>2.删除算法思路：</div><div><ul><li>如果删除位置不合理，抛出异常；<br/></li><li>取出删除元素；<br/></li><li>从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；<br/></li><li>表长减1；<br/></li></ul></div><div>3.线性表的顺序存储结构，在存、读数据时，时间复杂度为O(1)；在插入、删除时，时间复杂度为O(n)；</div><div>4.优点：</div><div><ul><li>无须为表示表中元素之间的逻辑关系而增加额外的存储空间<br/></li><li>可以快速地存取表中任一位置的元素<br/></li></ul></div><div>5.缺点：</div><div><ul><li>插入和删除操作需要移动大量元素<br/></li><li>当线性表长度变化较大时，难以确定存储空间的容量<br/></li><li>千万存储空间的碎片<br/></li></ul><div><br/></div></div><div><b>D.线性表链式存储结构定义</b></div><div>1.为了表示每个数据元素<span lang="EN-US">a<sub>i</sub></span>与其直接后继元素<span lang="EN-US">a<sub>i-1</sub></span>之间的逻辑关系，对数据元素<span lang="EN-US">a<sub>i</sub></span>来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称为指针或链。这两部分信息组成数据元素<span lang="EN-US">a<sub>i</sub></span>的存储映像，称为节点（Node）。</div><div>2.n个结点（<span lang="EN-US">a<sub>i</sub></span>的存储映像）链结成一个链表，即为线性表的链式存储结构，因此，链表的每个节点中只包含一个指针域，所以叫做单链表。</div><div>3.链表中第一个节点的存储位置叫做头指针，通常会在单链表的第一个结点前附设一个结点，称为头结点。</div><div><br/></div><div><b>E.线性表链式存储结构代码描述</b></div><div>1.结点由存放数据元素的数据域存放后继节点地址的指针域组成。</div><div><br/></div><div><b>F.单链表的读取</b></div><div>1.获得链表第i个数据的算法思路：</div><div><ul><li>声明一个结点p指向链表第一个结点，初始化j从1开始<br/></li><li>当j&lt;1时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1<br/></li><li>若到链表末尾p为空，则说明第i个元素不存在<br/></li><li>否则查找成功，返回结点p的数据<br/></li></ul></div><div><br/></div><div><b>G.单链表的插入与删除</b></div><div>1.单链表第i个数据插入结点的算法思路：</div><div><ul><li>声明一结点p指向链表第一个结点，初始化j从1开始<br/></li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1<br/></li><li>若到链表末尾p为空，则说明第i个元素不存在<br/></li><li>否则查找成功，在系统中生成一个空结点s<br/></li><li>将数据元素e赋值给s-&gt;data<br/></li><li>单链表的插入标准语句s-&gt;next=p-&gt;next;p-&gt;next=s;<br/></li><li>返回成功<br/></li></ul></div><div><br/></div><div><b>H.单链表的删除</b></div><div>1.单链表第i个数据删除结点的算法思路：</div><div><ul><li>声明一个结点p指向链表第一个节点，初始化j从1开始<br/></li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1<br/></li><li>若到链表末尾p为空，则说明第i个元素不存在<br/></li><li>否则查找成功，将欲删除的结点p-&gt;next赋值给q<br/></li><li>单链表的删除标准语句p-&gt;next=q-&gt;next<br/></li><li>将q结点中的数据复制给e，作为返回<br/></li><li>释放q结点<br/></li><li>返回成功<br/></li></ul></div><div>2.对于插入或删除数据越频繁的操作，单链表的效率优势就越明显</div><div><br/></div><div><b>I.单链表的整表创建</b></div><div>1.单链表整表创建的算法思路：</div><div><ul><li>声明一结点p和计数器变量<br/></li><li>初始化一空链表L<br/></li><li>让L的头结点的指针指向NULL，即建立一个带头结点的单链表<br/></li><li>循环：生成一个新结点赋值给p；随机生成一数字赋值给p的数据域p-&gt;data；将p插入到头结点与前一新结点之间<br/></li></ul></div><div><br/></div><div><b>J.单链表的整表删除</b></div><div>1.单链表删除的算法思路：</div><div><ul><li>声明一个结点p和q<br/></li><li>将第一个结点赋值给q<br/></li><li>循环：将下一节点赋值给q；释放p；将q赋值给p<br/></li></ul></div><div><br/></div><div><b>K.单链表结构与顺序存储结构优缺点</b></div><div>1.若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若要频繁插入和删除时，宜采用单链表结构。</div><div>2.当线性表中的元素个数变化较大或者根本不知道有多大时，使用单链表。</div><div><br/></div><div><b>L.静态链表</b></div><div>1.用数组来代替指针，来描述单链表。</div><div>2.我们让数组的元素都是由两个数据域组成，data和cur。也就是说，数组的每个下标都对应一个data和一个cur。</div><div><br/></div><div><b>M.循环链表</b></div><div>1.将单链表中终端节点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的就是循环链表（circular linked list）</div><div><br/></div><div><b>N.双向链表</b></div><div>1.双向链表（double linked list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域</div><div><br/></div><div>/shujujiegou/2.c<br/></div><div>/shujujiegou/2-1.c<br/></div><div><br/></div><div><b><font style="font-size: 24px;">四、栈与队列</font></b></div><div><b>A.栈的定义</b></div><div>1.栈（stack）是限定仅在表尾进行插入和删除操作的线性表。</div><div>2.允许插入和删除的一端称为栈顶（Top），另一端称为栈底（bottom），不含任何元素的栈称为空栈。栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构。</div><div>3.栈是线性表。栈的插入操作，叫做进栈，也称压栈、入栈；栈的删除操作，叫做出栈，也称弹栈。</div><div><br/></div><div><b>B.两栈共享空间</b></div><div>1.数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为栈的末端，即下标为数组长度n-1处，向中间靠拢。</div><div><br/></div><div><b>C.栈的链式存储结构</b></div><div>1.简称链栈。不存在栈满的情况，除非内存用完。</div><div>2.如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些</div><div><br/></div><div><b>D.栈的应用—递归</b></div><div>1.递归：一个直接调用自己或通过一系列的调用语句间接地调用自己的函数称为递归函数。</div><div>2.每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。</div><div><br/></div><div><b>E.队列的定义</b></div><div>1.队列：队列（Queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表</div><div>2.队列是一种先进先出（）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</div><div>3.循环队列：头尾相接的顺序存储结构称为循环队列；队列满的条件：（rear+1）%QueueSize==front；计算队列长度公式：(rear-front+QueueSize)%QueueSize</div><div><br/></div><div><b>F.队列的链式存储结构</b></div><div>1.队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列</div><div><br/></div><div>/shujujiegou/4.c<br/></div><div><div></div></div><div>/shujujiegou/4-1.c</div><div>/shujujiegou/4-2.c</div><div>/shujujiegou/4-3.c</div><div>/shujujiegou/4-4.c</div><div>/shujujiegou/4-5.c<br/></div><div><br/></div><div><b><font style="font-size: 24px;">五、串</font></b></div><div><b>A.串的定义</b></div><div>1.串（string）：是由零个或多个字符组成的有限序列，又名字符串</div><div>2.一般记为s=“a1a2a3……an”(n&gt;=0)，串中的字符数目n称为串的长度，零个字符串被称为空串（null string）</div><div><br/></div><div><b>B.串的比较</b></div><div>1.串的比较是通过组成串的字符之间的编码来进行的，而字符编码指的是字符在对应字符集中的序号</div><div>2.给定两个串，s(a1a2……an),t=(b1b2……bm)：</div><div><ul><li>当n&lt;m时，且a1==b1()<br/></li><li>存在某个k&lt;=min(m,n)，使得ai=bi(I=1,2……,k-1)<br/></li></ul></div><div><br/></div><div><i><b>T=<span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-position: normal; font-variant-caps: normal; font-variant-numeric: normal; font-variant-alternates: normal; font-variant-east-asian: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 28px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; float: none;">a b a c a a b a c a b a c a b a a b b（主串）</span></b></i></div><div><div></div></div><div><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-position: normal; font-variant-caps: normal; font-variant-numeric: normal; font-variant-alternates: normal; font-variant-east-asian: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 28px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; float: none;"><i><b>W=<span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-position: normal; font-variant-caps: normal; font-variant-numeric: normal; font-variant-alternates: normal; font-variant-east-asian: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 28px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; float: none;">a b a c a b（模式串）</span></b></i></span><br/></div><div><br/></div><div><b>C.朴素的模式匹配算法</b></div><div>1.简单来说就是对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串作大循环，每个字符开头做T的长度小循环，直到匹配成功或全部遍历完成为止。T[0]==W[0]，如果T[1]!=W[1]，则再进行T[1]==W[0]</div><div>2.比较低效，时间复杂度O((n-m+1)*m)</div><div><br/></div><div><b>D.KMP算法</b></div><div>1.时间复杂度：O(n+m)，仅当模式与主串之间存在许多“部分匹配”的情况下才体现出优势，否则差异不明显</div><div>2.基本思想（百度）：</div><div><ul><li>在简单的一次匹配失败后，我们会想将模式串尽量的右移和主串进行匹配。右移的距离在KMP算法中是如此计算的：在已经匹配的模式串子串中，找出最长的相同的前缀和后缀，然后移动使它们重叠。<br/></li><li>在T[5]与W[5]出现了不匹配，而T[0]~T[4]是匹配的，现在T[0]~T[4]就是已经匹配的模式串子串，现在移动找出最长的相同的前缀和后缀并使他们重叠<br/></li><li>例如：T[5]!=W[5]，下次从T[5]==W[0]开始</li></ul></div><div><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-position: normal; font-variant-caps: normal; font-variant-numeric: normal; font-variant-alternates: normal; font-variant-east-asian: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 28px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; float: none;"><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-position: normal; font-variant-caps: normal; font-variant-numeric: normal; font-variant-alternates: normal; font-variant-east-asian: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 28px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; float: none;"><br/></span></span></div><div>/shujujiegou/5.c<br/></div><div><br/></div><div><b><font style="font-size: 24px;">六、树</font></b></div><div><b>A.树的定义</b></div><div>1.树（Tree）是n(n&gt;=0)个结点的有限集。n=0时称为空树。在任意一颗非空树中：(1)有且仅有一个特定的称为根(Root)的结点；(2)当n&gt;1时，其余节点可分为m(m&gt;0)个互不相交的有限集T1、T2……Tm，其中每一个集合本身又是一颗树，并且称为根的子树(SubTree)</div><div>2.强调：n&gt;0时根结点是唯一的，不可能存在多个根结点；m&gt;0时，子树的个数没有限制，但它们一定是互不相交的；</div><div>3.结点分类：结点拥有的子树数称为结点的度(Degree)。度为0的结点称为叶子节点(Leaf)或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点外，分支结点也称为内部结点。树的度是树内部各结点的度的最大值</div><div>4.结点间关系：结点的子树的根称为该结点的孩子(Child)，相应地，该结点称为孩子的双亲(Parent)。同一个双亲的孩子之间称为兄弟(Sibling)。结点的祖先是从根到该结点所经分支上的所有结点。以某结点为根的子树中的任一结点都称为该结点的子孙。</div><div>5.结点的层次(Level)从根开始定义，根为第一层，根的孩子为第二层。双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为树的深度(Depth)或高度</div><div>6.如果将树中结点的各子树从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树</div><div>7.森林(Forest)是m(m&gt;0)棵互不相交的树的集合</div><div><br/></div><div><b>B.树的存储结构</b></div><div>1.双亲表示法</div><div><ul><li>假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置<br/></li><li>可扩展双亲域、长子域和右兄弟域等<br/></li><li>存储结构的设计是一个非常灵活的过程。一个存储结构设计得是否合理，取决于基于该存储结构的运算是否合适、是否方便，时间复杂度好不好等<br/></li></ul></div><div>2.孩子表示法</div><div><ul><li>每个结点有多个指针域，其中每个指针指向一个子树的根结点，这种方法叫做多重链表表示法<br/></li><li>方案一：指针域的个数就等于树的度<br/></li><li>方案二：每个节点指针域的个数就等于该结点的度<br/></li><li>孩子表示法：把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子节点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一给数组中<br/></li><li>双亲孩子表示法：将双亲法和孩子法结合<br/></li></ul></div><div>3.孩子兄弟表示法：任意一颗树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟</div><div><br/></div><div><b>C.二叉树</b></div><div>1.二叉树(Binary Tree) 是n(n&gt;0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成</div><div>2.特点：</div><div><ul><li>每个结点最多有两棵子树，所以不存在度大于2的结点<br/></li><li>左子树与右子树是有顺序的，次序不能任意颠倒<br/></li><li>即使树中某一结点只有一棵子树，也要区分它是左子树还是右子树<br/></li></ul></div><div>3.基本形态：空二叉树、只有一个根结点、根结点只有左子树、根结点只有右子树、根结点既有左子树也有右子树</div><div>4.特殊二叉树：</div><div><ul><li>斜树：所有的结点都只有左结点的二叉树叫做左斜树。所有结点都只有右结子树的二叉树叫做右斜树。两者统称为斜树。<br/></li><li>满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。特点：叶子只能出现在最下一层；非叶子结点的度一定是2；同样尝试的二叉树，满二叉树的结点个数最多，叶子最多<br/></li><li>完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。<br/></li><li>完全二叉树的特点：叶子结点只能出现在最下两层；最下层的叶子一定集中在左部连续位置；倒数二层，若有子结点，一定都在右部连续位置；如果节点为为1，则该结点只有左孩子；同样结点数的二叉树，完全二叉数深度小。<br/></li></ul></div><div><br/></div><div><b>D.二叉树的的性质</b></div><div>1.在二叉树的第i层上至多有<span lang="EN-US">2<sup>i-1</sup></span>个结点(i&gt;=1)</div><div>2.尝试为k的二叉树至多有<span lang="EN-US">2<sup>k</sup></span>-1个结点(k&gt;=1)</div><div>3.对任何一棵二叉树T，如果其终端结点数为n<span lang="EN-US"><sub>0</sub></span>，度为2的结点数为n<span lang="EN-US"><sub>2</sub></span>，则n<span lang="EN-US"><sub>0</sub></span>=n<span lang="EN-US"><sub>2</sub></span>+1<span lang="EN-US"><sub></sub></span></div><div>4.具有n个结点的完全二叉树的深度为[<span lang="EN-US">log<sub>2</sub>n</span>]+1([x]表示不大于x的最大整数)</div><div>5.如果对一棵有n个结点的完全二叉树（其深度为[<span lang="EN-US">log<sub>2</sub>n</span>]+1）的结点按层序编号（从第1层到第[<span lang="EN-US">log<sub>2</sub>n</span>]+1层，每层从左到右），对任一结点i（1&lt;=i&lt;=n）有：</div><div><ul><li>如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点[i/2]；<br/></li><li>如果2i&gt;n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i；<br/></li><li>如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1；<br/></li></ul></div><div><br/></div><div><b>E.二叉树的存储结构</b></div><div>1.顺序存储结构一般只用于完全二叉树</div><div>2.二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域，这种链表称为二叉链表</div><div><br/></div><div><span lang="EN-US"><sub></sub></span></div><div><b>F.二叉树的遍历</b></div><div>1.二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点疲访问一次且仅被访问一次</div><div>2.遍历方法：</div><div><ul><li>前序遍历：规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。<br/></li><li>中序遍历：规则是若二叉树为空，则空操作返回，否则从根节点开始（注意不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。<br/></li><li>后序遍历：规则是若二叉树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。<br/></li><li>层序遍历：规则是若二叉树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。<br/></li><li>性质：已知前序和中序，可以确定二叉树；已知中序和后序，可以确定二叉树；已知前序和后序，无法确定二叉树；<br/></li></ul></div><div><br/></div><div><b>G.线索二叉树</b></div><div>1.我们把指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索列表，相应的二叉树就称为线索二叉树（Threaded Binary Tree）</div><div>2.其实就是把一棵二叉树转成了一个双向链表，对二叉树以某种次序遍历使其变为线索二叉树的过程就称做是线索化。线索化的过程就是在遍历的过程中修改指针的过程。</div><div>3.如果使用的二叉树需要经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。时间复杂度为O(n)。</div><div><br/></div><div><b>H.树、森林与二叉树的转换</b></div><div>1.树转换为二叉树：</div><div><ul><li>加线。在所有兄弟结点之间增加一条连线。<br/></li><li>去线。对树中的每个结点，只保留它与第一个孩子结点之间的连线，删除它与其他孩子结点之间的连线。<br/></li><li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。<br/></li></ul></div><div>2.森林转换为二叉树</div><div><ul><li>把每个树转换为二叉树<br/></li><li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树<br/></li></ul></div><div>3.二叉树转为树</div><div><ul><li>加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的左孩子结点、右孩子的右孩子的右孩子的……，就是左孩子的右孩子N个右孩子结点都作为此结点的孩子。将该结点与这些中孩子结点用线连接起来。<br/></li><li>去线。删除原二叉树中所有结点与其右孩子结点的连线。<br/></li><li>层次调整。使之结构层次分明。<br/></li></ul></div><div>4.二叉树转换为森林：判断根结点有没有右孩子</div><div><ul><li>从根结点开始，若右孩子存在，则把与右孩子结点的边线删除，再查看分离后的二叉树，若右孩子存在，则边线删除……，直到所有右孩子连线都删除为止，得到分享的二叉树。<br/></li><li>再将每棵分离后的二叉树转换为树即可。<br/></li></ul></div><div>5.树的遍历</div><div><ul><li>先根遍历树，先访问树的根结点，然后依次先根遍历根的每棵子树<br/></li><li>后根遍历树，即先依次后根遍历每棵子树，然后再访问根结点。<br/></li></ul></div><div>6.森林的遍历</div><div><ul><li>前序遍历，先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林<br/></li><li>后序遍历，先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林<br/></li></ul></div><div><br/></div><div><b>I.赫夫曼树及其应用</b></div><div>1.从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称为路径长度。树的路径长度就是从树根到每一结点的路径长度之和。</div><div>2.赫夫曼算法描述</div><div><ul><li>根据给定的n个权值{w1,w2,w3……wn}构成n棵二叉树的集合F={T1,T2,……Tn}，其中每棵二叉树Ti中只有一个带权为wi根结点，其左右子树均为空<br/></li><li>在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和<br/></li><li>在F中删除这两棵树，同时将新得到的二叉树加入F中<br/></li><li>重复步骤2和3，直到F只含一棵树为止。这棵树便是赫夫曼树。<br/></li></ul></div><div>3.若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符编码的前缀，这种编码称为前缀编码。</div><div>4.赫夫曼编码：设需要编码的字符集为{d1,d2……dn}，各个字符在电文中出现的次数或频率集合为{w1,w2……wn}，以d1,d2……dn作为叶子节点，以w1,w2,……wn作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表0，右分支代表1，则从根结点到叶子节点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，就是就赫夫曼编码</div><div><br/></div><div>/shujujiegou/6.c<br/></div><div><br/></div><div><b><font style="font-size: 24px;">七、图</font></b></div><div><b>A.图的定义</b></div><div>1.图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</div><div>2.注意：</div><div><ul><li>图中元素称为顶点（Vertex）<br/></li><li>线性表中可以没有元素称为空表，树中可以没有结点叫做空树，图结构中不允许没有顶点<br/></li><li>图中任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示<br/></li></ul></div><div>3.各种图定义</div><div><ul><li>无向边：若顶点<span lang="EN-US">v<sub>i</sub></span>到<span lang="EN-US">v<sub>j</sub></span>之间的边没有方向，则称这条边为元向边（Edge），用无向序偶对（<span lang="EN-US">v<sub>i</sub>,v<sub>j</sub></span>）来表示。如果图中任意两个顶点之间的边都是无向边，则称该图为无向图（Undirected grpahs）<br/></li><li>有向边：若从顶点<span lang="EN-US">v<sub>i</sub></span>到<span lang="EN-US">v<sub>j</sub></span>的边有方向，则称这条边为有向边，也称为弧（Arc）。用有序偶&lt;<span lang="EN-US">v<sub>i</sub>,v<sub>j</sub></span>&gt;来表示，<span lang="EN-US">v<sub>i</sub></span>称为弧尾（Tail），<span lang="EN-US">v<sub>j</sub></span>称为弧头（Head）。如果图中任意两个顶点之间的边都是有向边，则该图称为有向图（Directed grpahs）<br/></li><li>*无向边用小括号表示，有向边用尖括号表示<br/></li><li>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图<br/></li><li>在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有n个顶点的无向完全图有n*(n-1)/2条边。<br/></li><li>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有n*(n-1)条边<br/></li><li>有很少条边或弧的图称为稀疏图，反之称为稠密图<br/></li><li>有些图的边或弧具有与它相关的数字，这种与图的边或者弧相关的数叫做权（Weight）。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图统称为网（Network）。<br/></li><li>假设有两上图G=(V,{E})和G’=(V’,{E’})，如果V’包含于V且E’包含于E,则称G’为G的子图（Subgraph）<br/></li></ul></div><div>4.图的顶点与边间关系</div><div><ul><li>对于无向图G=(V,{E})，如果边(<span lang="EN-US">v<sub>i</sub>,v<sub>j</sub></span>)属于E，则称顶点v和v’互为邻接点(Adjacent)，即v和v’相邻接。边(<span lang="EN-US">v<sub>i</sub>,v<sub>j</sub></span>)依附(incident)于顶点v和v’，或者说(v,v’)与顶点v和v’相关联。顶点v的度（Degree）是和v相关联的边的数目<br/></li><li>对于有向图G=(V,{E})，如果弧&lt;<span lang="EN-US">v<sub>i</sub>,v<sub>j</sub></span>&gt;属于E，则称顶点v连接到顶点v。弧&lt;v,v’&gt;和顶点v,v’相关联。以顶点v为头的弧的数目称为v的入度（InDegree），记为ID（v）；以v为尾的弧的数目称为v的出度（OutDegree），记为OD(v)；顶点v的度为TD(v)=ID(v)+OD(v)<br/></li><li>无向图G=(V,{E})中从顶点v到顶点v’的路径（path）是一个顶点序列（v=<span lang="EN-US">v<sub>i,0</sub></span>，<span lang="EN-US">v<sub>i,1</sub></span>，……，<span lang="EN-US">v<sub>i,m</sub></span>），其中<span lang="EN-US">v<sub>i,j</sub></span>-1属于E，1&lt;=j&lt;=m<br/></li><li>路径的长度是路径上边或弧的数目<br/></li><li>第一个顶点到最后一个顶点相同的路径称为回路或环（Cycle）。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点外，其余顶点不重复出现的回路，称为简单回路或简单环。<br/></li></ul></div><div>5.连通图相关术语</div><div><ul><li>在无向图G中，如果从顶点v到顶点v’有路径，则称v和v’是连通的。如果对于图中任意两个顶点<span lang="EN-US">v<sub>i</sub>,v<sub>j</sub></span>属于E，<span lang="EN-US">v<sub>i</sub></span>和vj都是连通的，则称G是连通图（Connected Graph）<br/></li><li>无向图中的极大连通子图称为连通分量，强调：要是子图；子图要是连通的；连通子图含有极大顶点数；具有极大顶点数的连通子图包含依附于这些顶点的所有边<br/></li><li>在有向图G中，如果对于每一对<span lang="EN-US">v<sub>i</sub>,v<sub>j</sub></span>属性V，<span lang="EN-US">v<sub>i</sub></span>!=<span lang="EN-US">v<sub>j</sub></span>，从<span lang="EN-US">v<sub>i</sub></span>到<span lang="EN-US">v<sub>j</sub></span>和从<span lang="EN-US">v<sub>j</sub></span>到<span lang="EN-US">v<sub>i</sub></span>都存在路径，则称G是强连通图。有向图中的极大强连通子图称做有向图的强连通分量<br/></li><li>一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边<br/></li><li>如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一棵有向树。一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧<br/></li></ul></div><div><br/></div><div><b>B.图的存储结构</b></div><div>1.邻接矩阵：图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。</div><div>2.邻接表：将结点存入数组，并对结点的孩子进行存储，这种数组与链表相结合的存储方法称为邻接链表。</div><div><ul><li>图中顶点用一个一维数组存储，每个数据元素还要存储指向第一个邻接点的指针<br/></li><li>图中每个顶点<span lang="EN-US">v<sub>i</sub></span>的所有邻接点构成一个线性表，使用单链表存储，无向图称为顶点<span lang="EN-US">v<sub>i</sub></span>的边表，有向图则称为顶点<span lang="EN-US">v<sub>i</sub></span>作为弧尾的出边表<br/></li><li>对于有向图，可以建立一个有向图的逆邻接表，即对每个顶点<span lang="EN-US">v<sub>i</sub></span>都建立一个链接为<span lang="EN-US">v<sub>i</sub></span>为弧头的表<br/></li><li>对于带权值的网图，可以在边界结点定义中再增加一个weight的数据域，存储仅值信息<br/></li></ul></div><div>3.十字链表：将邻接表和逆邻接表结合在一起使用，在有向图的应用中，是非常好的数据结构模型</div><div>4.邻接多重表：与邻接表的差别，仅仅是在于同一条边在邻接表中用两个结点表示</div><div>5.边靠数组：由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标、终点下标和权组成</div><div><br/></div><div><b>C.图的遍历</b></div><div>1.图的遍历和树的遍历类似，从图中某一顶点出发访遍图中其余观点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历（Traversing Graph）</div><div>2.尝试优先遍历（Depth_First_Search），也称为尝试优先搜索，简称GFS。</div><div><ul><li>从图中的某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径想通的顶点都被访问到。<br/></li><li>若图中尚有顶点未被访问，则另选图中一个未被访问的顶点作起始点，重复上述过程，直至图中所有访问点都被访问到为止。<br/></li><li>例如从顶点开始一路访问右结点，递归遍历右结点完成后访问左结点，类似树的遍历<br/></li></ul></div><div>3.广度优先遍历（Breadth_First_Search）：又称广度优先搜索，又称BFS。类似于树的层序遍历。</div><div><ul><li>与深度优先遍历在时间复杂度上是一样的<br/></li><li>深度优先更适合目标比较明确 ，以找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况<br/></li></ul></div><div><br/></div><div><b>D.最小生成树</b></div><div>1.把构造连通网的最小代价生成树称为最小生成树（Minimum Cost Spanning Tree）</div><div>2.普里姆（Prim）算法</div><div><ul><li>假设N=(P,{E})是连通网，TE是N上最小生成树中边的集合。算法从U={u<span style="font-size: 11.666666030883789px;">0</span>}(u<span style="font-size: 11.666666030883789px;">0</span>∈V)，TE={}开始。重复执行下述 操作：在所有u∈U,v∈V-U的边(u,v)∈E中找一条代价最小的边(u<span style="font-size: 11.666666030883789px;">0</span>,v<span style="font-size: 11.666666030883789px;">0</span>)并入集合TE，同时v<span style="font-size: 11.666666030883789px;">0</span>并入U，直至U=V为止。此时TE中必有n-1条边，则T=(V,{TE})为N的最小生成树<br/></li></ul></div><div>3.克鲁斯卡尔（Kruskal）算法</div><div><ul><li>假设N=(V,{E})是连通网，则令最小生成树的初始状态为只有n个顶点而无边的非连通图T={V,{}}，图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点落在T中不同的连通仅是上，则将此边加入到T中，否则会去此边而选择下一条代价最小的边。依次类推，直至T中所有顶点都在同一连通分量上为止<br/></li></ul></div><div>4.克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，所以对于稀疏图有很大的优势；而普里姆算法对于稠密图，即边数非常多的情况会更好一些</div><div><br/></div><div>E.最短路径</div><div>1.对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点</div><div>2.迪杰斯特拉（Dijkstra）算法</div><div>并不是一下就求出<span lang="EN-US">v<span style="font-size: 11.666666030883789px;">1</span></span>到<span lang="EN-US">v<span style="font-size: 11.666666030883789px;">n</span></span>的最短路径，而是一步步求出它们之间顶点的最短路径，过程中都是基于已经求出的最短路径的基础上，求得最远顶点的最短路径，最终得到结果</div><div>解决了从某个源点到其余各顶点的最短路径问题，时间复杂度为O(n^3)</div><div>3.费洛伊德（Floyd）算法</div><div>公式：<span lang="EN-US">D<sup>0</sup>[v][w]=min{D<sup>-1</sup>[v][w],D<sup>-1</sup>[v][0]+D<sup>-1</sup>[0][w]}</span></div><div>代码简洁，一个二重循环初始化加一个三重循环权值修正，时间复杂度也是O(n^3)，如果面临需要求所有顶点至所有顶点的最短路径问题时，弗洛伊德（Floyd）算法应该是不错的选择</div><div><br/></div><div>F.拓扑排序</div><div>1.在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AOC网（Activity On Vertex Network）</div><div>2.设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列<span lang="EN-US">v<span style="font-size: 11.666666030883789px;">1</span></span>……<span lang="EN-US">v<span style="font-size: 11.666666030883789px;">n</span></span>，满足若从顶点vi到vj有一条路径，则在顶点序列中顶点<span lang="EN-US">v<sub>i</sub></span>必在顶点<span lang="EN-US">v<span style="font-size: 11.666666030883789px;">j</span></span>之前。则我们称这样的顶点序列为一个拓扑序列</div><div>3.所谓拓扑排序，其实就是对一个有向图构造拓扑序列的过程</div><div>4.基本思路：从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，走到输出全部顶点或者AOV网中不存在入度为0的顶点为止</div><div>5.整个算法的时间复杂度为O(n+e)</div><div><br/></div><div>G.关键路径</div><div>1.在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为AOE网（Activity On Edge Network）</div><div>2.路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动</div><div>3.算法原理：只需要找到所有活动的最早开始时间和最晚开始时间，并且比较它们 ，如果相等就意味着此活动是关键活动，活动间的路径为关键路径，几个参数：</div><div>事件的最早发生时间etv（earliest time of vertex）：即顶点<span lang="EN-US">v<span style="font-size: 11.666666030883789px;">k</span></span>的最早发生时间</div><div>事件的最晚发生暖意ltv（latest time of vertex）：即顶点<span lang="EN-US">v<span style="font-size: 11.666666030883789px;">k</span></span>的最晚发生时间，也就是每个顶点对应的事件最晚需要开始的时间，超出此时间将会延误整个工期</div><div>活动的最早开工时间ete（earliest time of edge）：即弧a<span lang="EN-US"><span style="font-size: 11.666666030883789px;">k</span></span>的最早发生时间</div><div>活动的最晚开工时间lte（latest time of edge）：即弧a<span lang="EN-US"><span style="font-size: 11.666666030883789px;">k</span></span>的最晚发生时间，也就是不推迟工期的最晚开工时间</div><div><br/></div><div>/shujujiegou/7.c<br/></div><div><br/></div><div><b><font style="font-size: 24px;">八、查找</font></b></div><div><b>A.查找概论</b></div><div>1.查找表（Search Table）是由同一类型的数据元素（或记录）构成的集合</div><div>2.关键字（Key）是数据元素中某个数据项的值，用它可以标识一个数据元素。也可以标识一个记录的某个数据项（字段），我们称为关键码。若此关键字可以唯一地标识一个记录，则称此关键字为为主关键字（Primary Key）。对于那些可以识别多个数据元素（或记录）的关键字，称为次关键字（Secondary Key）</div><div>3.查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</div><div>4.静态查找表（Static Search Table）：只查找操作的查找表。操作有：</div><div><ul><li>查询某个“特定的”数据元素是否在查找表中<br/></li><li>检索某个“特定的”数据元素和各种属性<br/></li></ul></div><div>5.动态查找表（Dynamic Search Table）：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。操作有：</div><div><ul><li>查找时插入数据元素<br/></li><li>查找时删除数据元素<br/></li></ul></div><div><br/></div><div><b>B.顺序表查找</b></div><div>1.顺序查找（Sequential Search）又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不相等时，则表中没有所查的记录，查找不成功</div><div>2. 时间复杂度：O(n)</div><div><br/></div><div><b>C.有序表查找</b></div><div>1.折半查找（Binary Search）技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。时间复杂度O(logn)</div><div>2.插值查找（Interpolation Search）是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式key-a[low]/a[high]-a[low]。</div><div>3.斐波那契查找：如果要查找的记录在左侧，则左侧的数据都不用再判断了，不断反复进行下去，对处于当中的大部分数据，其工作效率要高一些，折半查找是进行加法与除法运算，插值查找 进行按照那样的四则运算，而斐波那契查找只是最简单加减法运算。核心在于：</div><div><ul><li>当key=a[mid]时，查找就成功<br/></li><li>当k&lt;a[mid]时，新范围是low个到第mid-1个，此时范围个数为F[k-1]-1个<br/></li><li>当key&lt;a[mid]时，新范围是m+1个到第high个，此时范围个数为F[k-2]-1<br/></li></ul></div><div><br/></div><div><b>D.线性索引查找</b></div><div>1.索引就是把一个关键字与它对应的记录相关联的过程。所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。</div><div>2.稠密索引：是指在线性索引中，将数据集中的每个记录对应一个索引项。对于稠密索引这个索引用来说，索引项一定是按照关键码有序的排列</div><div>3.分块索引：</div><div><ul><li>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：块内无序，即每一块内的记录不要求有序；块间有序；<br/></li><li>定义的分块索引的索引项结构分三个数据项：最大关键码；块中的记录个数；用于指向块首数据元素的指针；<br/></li><li>分块索引表中查找分两步：在分块索引表中查找要查关键字所在的块；根据块首指针找到相应的块，并在块中顺序查找关键码。<br/></li></ul></div><div>4.倒排索引：</div><div><ul><li>索引项的通用结构是：次关键码；记录号表；<br/></li><li>其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）。这样的索引方法就是倒排索引（inverted index）。<br/></li></ul></div><div><br/></div><div><b>E.二叉排序树</b></div><div>1.二叉排序树（Binary Sort Tree），又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。</div><div><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值；<br/></li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br/></li><li>它的左、右子树也分别为二叉排序树<br/></li></ul></div><div><br/></div><div><b>F.平衡二叉树（AVL树）</b></div><div>1.平衡二叉树（Self-Balancing Binary Search Tree或Height-Balanced Binary Search Tree），是一种二叉排序树，其中每一个节点的左子树和左子树的高度差至多等于1.</div><div>2.我们将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF（Balance Factor），平衡二叉树上所有结点的平衡因子只可能是-1，0和1.</div><div>3.距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为最小不平衡子树</div><div>4.实现原理：在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最不不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。当最小不平衡子树根结点的平衡因子BF是大于1时，就右旋，小于-1时就左旋。插入结点后，最小不平衡子树的BF与它的子树的BF符号相反时，就需要对结点先进行一次旋转以使得符号相同后，再反向旋转一次才能够完成平衡操作。</div><div><br/></div><div><b>G.多路查找树（B树）</b></div><div>1.多路查找 树（muitl-ray search tree），其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素</div><div>2.2-3树：其中的每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为3结点）</div><div><ul><li>一个2结点包含一个元素和两个孩子（或没有孩子），且与二叉排序树类似，但这2结点要么没孩子，要么就有2个<br/></li><li>一个3结点包含一小一大两个元素和三个孩子（或没有孩子）<br/></li></ul></div><div>3.2-3-4树：其实就是2-3树的概念扩展，包括了4结点的使用。一个4结点包含小中磊三个元素和四个孩子（或没有孩子），一个4结点要么没孩子，要么有4个孩子</div><div>4.B树（B-tree）：是一种平衡的多路查找树。2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶（order）。一个m阶的B树具有如下属性：</div><div><ul><li>如果要结点不是叶结点，则至少有两棵子树<br/></li><li>每一个非根的分支结点都有k-1个元素和k个孩子，其中[m/2]&lt;=k&lt;=m。每一个叶子结点n都有k-1个元素，其中[m/2]&lt;=k&lt;=m<br/></li><li>所有叶子结点都位于同一层次<br/></li><li>所有分支结点包含下列信息数据（n,A0,K1,A1,K2,A2……Kn,An），其中：Ki(i=1,2……,n)为关键字，且Ki&lt;Ki+1(i=1,2……,n);Ai(i=0,2,……,n)为指向子树根结点的指针，且指针Ai-1所指子树中所有结点的关键字均小于Ki，An所指子树中所有结点的关键字均大于Kn，n([m/2]-1&lt;=n&lt;=m-1)为关键字的个数（或n+1为子树的个数）<br/></li></ul></div><div>5.B+树，在B树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子结点）中再次列出。另外，每一个叶子结点都会保存一个指向后一路子结点的指针。一棵m阶的B+树和m阶的B树的差异在于：</div><div><ul><li>有n棵子树的结点中包含有n个关键字<br/></li><li>所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接<br/></li><li>所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）关键字<br/></li></ul></div><div><br/></div><div><b>H.散列表查找（哈希表）概述</b></div><div>1.散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)，f称为散列函数，又称为哈希（Hash）函数。采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）</div><div>2.散列技术既是一种存储方法，也是一种查找方法。最适合的求解问题是查找与给定值相等的记录。</div><div>3.散列技术不适合多同样关键字或范围查找</div><div>4.两个关键字key1!=key2，但是却有f(key1)==f(key2)，这种现象称为冲突（collision），并把key1和key2称为这个散列函数的同义词（synonym）</div><div><br/></div><div><b>I.散列函数的构造方法</b></div><div>1.好的散列函数：计算简单、散列地址分布均匀</div><div>2.直接定址法：f(key)=a*key+b（a,b为常数），适合查找表较小且连续的情况</div><div>3.数字分析法：制取使用关键字的一部分来计算散列存储位置的方法，适合处理关键字位数比较大的情况，且事先知道关键字的分布且关键字的若干位分布较均匀</div><div>4.平方取中法：适合不知道关键字的分布，而位数又不是很大的情况</div><div>5.折叠法：将关键字从左到右分割成位数相等的几部分（注意最后一部分位数不够时可以短些），然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。事先不需要知道关键字的分布，适合关键字位数较多的情况。</div><div>6.除留余数法：f(key) = key mod p(p&lt;=m)，最常用的，若散列表表长为m，通常p为小于或等于表长（最好接近m）的最小质数或不包含小于20质因子的合数</div><div>7.随机数法：f(key) = random(key)</div><div><br/></div><div><b>J.处理散列冲突的方法</b></div><div>1.开放定址法：就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。fi(key) = (f(key)+di) MOD m (di=1,2,3……,m-1)</div><div><ul><li>二次探测法，增加平方运算为了不让关键字都聚集在某一块区域：fi(key) = (f(key)+di) MOD m (di=1^1,-1^1,2^2,-2^2……,q^1,-q^q,q&lt;=m/2)<br/></li><li>随机探测法：fi(key) = (f(key)+di) MOD m (di是一个随机数列)<br/></li></ul></div><div>2.再散列函数法：fi(key) = RHi(key) (I=1,2,……,k)</div><div>3.链地址法：将所有关键字为同义词的记录存储在一个单链表中，称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。</div><div>4.公共溢出区法：为所有冲突的关键字建立一个公共的溢出区来存放</div><div><br/></div><div><b>K.散列表查找实现</b></div><div>1.散列查找的平均查找长度取决于：</div><div><ul><li>散列防水涂料旭否均匀<br/></li><li>处理冲突的方法<br/></li><li>散列表的装填因子<br/></li></ul></div><div><br/></div><div>/shujujiegou/8.c<br/></div><div><br/></div><div><b><font style="font-size: 24px;">九、排序</font></b></div><div><b>A.排序的基本概念与分类</b></div><div>1.假设含有n个记录的序列为{r1,r2……,rn}，其相应的关键字分别为{k1,k2,……,kn}，需确定1，2，……，n的一种排列p1,p2,……,pn，使其相应的关键字满足kp1&lt;=kp2&lt;=……&lt;=kpn（非递减或非递增）关系，即使得序列成为一个按关键字有序的序列{rp1,rp2,……,rpn}，这样的操作就称为排序</div><div>2.排序的稳定性：假设ki=kj（1&lt;=i&lt;=n,1&lt;=j&lt;=n,i!=j），且在排序前的序列中ri领先于rj（即i&lt;j）。如果排序后ri仍依靠于rj，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中rj领先ri，则称所用的排序方法是不稳定的。</div><div>3.外排序：是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。</div><div>4.内排序：是在排序整个过程中，待排序的所有记录全部被放置在内存中。</div><div><ul><li>性能受三方面影响：时间性能、辅助空间、算法的复杂性<br/></li><li>内排序分为：插入排序、交换排序、选择排序和归并排序<br/></li><li>按算法复杂度：简单算法（冒泡排序、简单选择排序、直接插入排序）、改进算法（希尔排序、堆排序、归并排序、快速排序）<br/></li></ul></div><div><br/></div><div><b>B.冒泡排序</b></div><div>1.冒泡排序（Bubble Sort）一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。</div><div><br/></div><div><b>C.简单选择排序</b></div><div>1.简单选择排序法（Simple Selection Sort）就是通过n-i关键字间的比较，从n-i+1个记录中先出关键字最小的记录，并和第i（1&lt;=i&lt;=n）个记录交换之</div><div><br/></div><div><b>D.直接插入排序算法</b></div><div>1.直接插入排序（Straight Insertion Sort）的基本操作是将一个记录插入到已经排好的有序列表中，从而得到一个新的、记录数增1的有序表</div><div><br/></div><div><b>E.希尔排序</b></div><div>1.将大量记录数的记录进行分组。分割成若干个子序列，在这些子序列内分别进行直接插入排序，当整个序列基本有序时，注意只是基本有序时，再对全体记录进行一次直接插入排序</div><div>2.所谓基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间</div><div>3.跳跃分割：将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序</div><div><br/></div><div><b>F.堆排序</b></div><div>1.堆是具有下列性质的完全二叉树：每个结点都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</div><div>2.堆排序（Heap Sort）将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列。</div><div><br/></div><div><b>G.归并排序</b></div><div>1.归并排序（Merging Sort）假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到[n/2]（[x]表示不小于x的最小整数）个长度为2或1的有序子序列；两款两两归并，……，如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为2路归并排序</div><div><br/></div><div><b>H.快速排序</b></div><div>1.快速排序（Quick Sort）的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的</div><div><br/></div><div>/shujujiegou/9.c<span>    </span></div><div><br/></div></span>
</div></body></html> 