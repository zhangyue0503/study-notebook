<html>
<head>
  <title>代码里的世界观</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="940"/>
<h1>代码里的世界观</h1>

<div><span><div>数据和代码的关系：</div><ul><li><div>1）数据是根本目的，代码是手段，代码永远是为数据服务的</div></li><li><div>2）有什么样的数据，决定了会有什么样的代码</div></li></ul><div><br/></div><div>如果重构一个系统，抓不住头绪，不妨从数据的角度进行重新梳理和思考。这样抓住源头往往能拨开迷雾，站在更高的角度去理解这个系统，从而生成最佳的想法</div><div><br/></div><div>封装，将一些相互关联的因素装在一起</div><div><br/></div><div>封装将若干数据和方法组合在一个叫“类”的身体里。数据是肉体，而方法是让身体动起来的各种行为。方法存在的意义就是操作它对应的数据</div><div><br/></div><div>public直接体现一个类对外的表象。每一个public方法正式发布后，都代表着一个小小的承诺。既然是承诺，就不要轻易修改，因为很可能被外部引用，一旦修改就会引发一系列麻烦</div><div><br/></div><div>private的优势：</div><ul><li><div>1）能灵活控制读写的权限</div></li><li><div>2）为数据抽象提供可能</div></li><li><div>3）安全性</div></li><li><div>4）能轻松地进行各种逻辑扩展</div></li></ul><div><br/></div><div>尽量暴露方法，不要暴露数据！数据好比是肉体，方法好比是盔甲。让肉体经受风吹雨打，总不如让盔甲承受安全</div><div><br/></div><div>如果服务主要针对于内部其他模块，可以直接暴露原始数据</div><div>如果你们的代码是以通用模块的方式提供给对方，而对方是谁你完全不知道，如何调用你也完全不知道，此时需要很谨慎地去实现数据的只读性，或者仅仅提供备份数据</div><div><br/></div><div>定义private方法的场景：</div><ul><li><div>1）抽象出来的一些边边角角的小功能方法</div></li><li><div>2）纯粹就是好几处相同或相似的代码，为了缩减行数，硬把这几处代码替换为一个private函数</div></li><li><div>3）可能一些public方法过于强大，业务上不想让外面知道这么多细节</div></li></ul><div><br/></div><div>任何一个private方法是不能独立存在的，它必须依附至少一个public方法，所以在大部分情况下，单元测试只需要测试public方法，通过public方法顺便测试到private方法即可</div><div><br/></div><div>多态给程序员带来的最大价值是实现了“面向抽象编程，面向接口编程”</div><div><br/></div><div>“面向抽象编程”本质上是对数据的抽象化，“面向接口编程”本质上是对行为的抽象化</div><div><br/></div><div>面向抽象，是要在关键且合适的地方去抽象，如果处处都抽象，代价会非常大，得不偿失</div><div><br/></div><div>参数化和工厂模式是消灭或隔离new的两种武器</div><div><br/></div><div>用户需求是决定抽象到何种程度的决定因素</div><div><br/></div><div>其实大部分的耦合是业务逻辑的要求，是为了满足正当的需求所产生的。这样的耦合正是我们所需要的</div><div><br/></div><div>切记：数据之间若存在相关性，一定要有体现</div><div><br/></div><div>如果有两个数据，你中有我，我中有你，形成双向依赖，这种“谈恋爱”的方式是危险的，因为一方要分手，会给另一方造成麻烦</div><div><br/></div><div>假如一个公共变量，你错误地修改了它，则直接影响到所有使用它的人。这种耦合导致的错误是非常可怕的。比如死锁，等于耦合到了极致，完全成了一团乱麻，无法分开了。需要尽量做到公共资源是不可变的，或者操作它的途径非常有限、可控。</div><div><br/></div><div>重构的目标应该是：重构后，能一次性解决可预见的问题，即对某一个具体需求的重构有足够的远见。</div><div><br/></div><div>一般项目在迭代开发的时候，有两分精力是放在用户看不到的内部优化中，八分精力放在新需求的开发上，这样整个产品的质量在持续 迭代中才能有很好的保障</div><div><br/></div><div>两个解耦原则：</div><div>1）让模块逻辑独立而完整</div><div>对内有完整的逻辑，而所依赖的外部资源尽可能是不变量</div><div>对外体现的特性也是“不变量”（或者尽可能做到不变量），让别人可以放心地依赖我</div><div>2）让连接桥梁坚固而兼容：尽量让变化落在岛屿上，而不是桥梁上，因为更换桥梁的成本更高，风险要更大</div><div><br/></div><div>把自己所需要的数据都明确标识在参数列表里，把自己能提供的全集中在返回值里。如果你需要的某项数据不在参数里，你就会依赖上别人，因为你多半需要指名道姓地标明某个第三方来特供；同理，如果你提供的数据不全在返回值和参数里，别人会依赖上你</div><div><br/></div><div>当程序员对一个类或一个方法的使用需要额外的记忆时，这不是好代码</div><div><br/></div><div>返回值是bool的，对业务进行描述判断的方法，称为“规约”。在开发项目的时候要有意识地和客户沟通，刻意地把这些规约提炼出来。这些都是很宝贵的资料</div><div><br/></div><div>在手动或半手动管理内存的语言里，了解每个对象的生命周期是基本功，时刻都要注意。</div><div><br/></div><div>垃圾收集器的主流算法有两种：</div><div>引用计数算法</div><div>可达性遍历算法</div><div><br/></div><div>我们应该尽量让实体对象能拥有值对象，而不要出现值对象去拥有实体对象的情况</div><div><br/></div><div>是不是所有的类似if(ivar == data)这样的判断语句，都应该封装进数组进行判断呢？当特殊数据理论上的数量是无限的，不能穷举的时候，适用！如果能够被穷举的话，而且个数比较少，直接用if…else枚举判断就好</div><div><br/></div><div>数据化的优势就是为了拥抱将来的变化，没有变化的可能就无须使用了</div><div><br/></div><div>反射中的核心功能（并非所有功能）从业务的本质看，就是将代码数据化！</div><div><br/></div><div>反射把神秘莫测的代码，用可视化的string数据呈现在用户面前。“如果在这个地方，函数名是可配置的数据该多好？那可以考虑用反射”</div><div><br/></div><div>反射能将模块和模块之间的绑定从编译期延迟到运行期</div><div><br/></div><div>反射是破坏封装的，通过反射可以申通无阻地访问类的私有方法甚至私有变量，让每个人的隐私无处遁形。反射还会让代码的可读性和调试性受到影响</div><div><br/></div><div>剥离新接口还是新增中间类？</div><ul><li><div>如果抽象出的方法不依赖于新增数据，就剥离出新接口。接口描述的功能比较轻量级，可以是泛泛的概念，可以修饰完全不同的类</div></li><li><div>如果抽象出的方法需要新定义数据，就新定义中间类。继承就显得重量级一些，面对的是基于新增数据产生的新功能，无法随意更改替换的</div></li></ul><div><br/></div><div>如果外部对父类的行为已经形成了强烈的依赖关系，子类仍毫无顾忌地覆盖了父类的行为，且行动范围在父类行动范围之外，那么可能会违反里氏替换原则</div><div><br/></div><div>多个子类出现后，通过继承和多态从而产生动态的效果，这是组合做不到的</div><div><br/></div><div>组合的优势在于，能够实现一个并不固定某具体功能的类</div><div><br/></div><div>描述两个对象之间的关系是用继承还是组合，关键是判断功能之间是否有相关性</div><div><br/></div><div>组合代表的关系比依赖更紧密。继承、组合和依赖所代表的关系，其紧密程度是依次降低的。关系越松，越能产生灵活性。因此，组合比继承灵活，同时依赖明显比组合更松散、更灵活</div><div><br/></div><div>组合和依赖的核心区别是A是否拥有B的一个对象实例，组合有，依赖没有。因为组合里的这个对象是可以持久的，并且是状态相关的。组合里，A可以先初始化B的实例，却并不急于马上调用B，我可以等到合适的时候再调用。这点依赖做不到，依赖必须在该函数执行期内去使用，否则对象被销毁，便过期了</div><div><br/></div><div>无状态函数：</div><ul><li><div>多次调用同一个函数，每次调用都是彼此独立的</div></li><li><div>如果输入是一致的，那么输出也是一致的</div></li></ul><div><br/></div><div>无状态函数的优势：</div><ul><li><div>结果是稳定的、可预期的</div></li><li><div>可以放心地支持多线程并发</div></li></ul><div><br/></div><div>为了节省内存空间，同时也确实没有必要为同一个对象创建那么多副本，于是有了引用传递。但引用传递的共享内存特点也会导致内存数据可能被经过的每个函数修改，所以这个特性有得有弊，我们享受效率提升的同时，也经常承受它的负面影响。值传递是彻底解决引用传递负面影响的首选，但它需要不停地复制，所以效率低下</div><div><br/></div><div>抽象类的接口：</div><ul><li><div>1）抽象类是针对数据的抽象描述，更强调“你是什么”</div></li><li><div>2）接口是针对行为的抽象描述，更强调“你能干什么”</div></li></ul><div><br/></div><div>对类（包括抽象类）的设计来说，数据和方法总是要包含得完整些，才能配得上这种封装类型。继承的时候，难免把一些不要的功能继承进来，而接口的定义往往是轻量级的，它经常被拆分得很细</div><div><br/></div><div>抽象类是静态概念的描述，接口是对动态行为特征的描述</div><div><br/></div><div>接口一般应用于：</div><ul><li><div>面积多个人或多个模块之间的协同合作</div></li><li><div>对方法的抽象</div></li><li><div>模块之间解耦的工具</div></li></ul><div><br/></div><div>对多个经常添加修改的同类判断不宜使用if…else</div><div><br/></div><div>static的私密作用是将类名淡化了，而突出了参数的重要性，参数由原来作为宾语的辅助位置上升到了主语的领头羊位置</div><div><br/></div><div>让第一个参数（而且是类参数）反客为主，那么可以实现类扩展，如static void Drive(Person person, Car car)，为person添加驾驶汽车的能力</div><div><br/></div><div>如果一个方法是任何场景下都可能用到，那么理所当然定义成类成员方法。如果只是局部场景下可能用到，则优先定义成类扩展</div><div><br/></div><div>对编程的兴趣，最终都来源于从最理性的代码中获得的感性记忆</div><div><br/></div><div>如果你的生产环境不如意，那么会很大程度地限制人力的发挥。设计架构时，要考虑到开发环境和调试环境，把瓶颈问题解决好</div><div><br/></div><div>软件开发的设计，还要将测试流程考虑进去。有的项目采用敏捷开发，小步快跑，多次发布。但并不是所有行业都是这样的。有的公司里，产品发布相对谨慎，测试漫长，任何一个小小的改动，你觉得肯定过，没必要测。但别人不会这么认为，后续工作都会接踵而至。因为这是整个产品生产的流程所决定的</div><div><br/></div><div>隐式约定真正的风险在于数据的拆包和解包过程中，某一方可能没有完全遵守封底导致出现数据不一致的情况</div><div><br/></div><div>当你设计架构的日志上传，将主体数据和context数据分离，在概念上先分清楚，这样很有利于后面展开思路</div><div><br/></div><div>抛出异常的目的不是给最终用户看的，而是在被最终用户感知之前，被中间某一层的代码处理掉</div><div><br/></div><div>异常的使用技巧：</div><ul><li><div>1）迟早检查并抛出异常，不要运行到函数深处再被动抛出。函数出错误的地方越深，带来的副作用越大</div></li><li><div>2）不要加大catch的负担。任何一块代码，如果具有完整的判断逻辑，减少对周围的依赖，这段代码也更容易被移植</div></li><li><div>3）尽量少用try…catch语句</div></li><li><div>4）保持克制，不要滥用</div></li><ul><li><div>最底下的model层无须考虑异常处理</div></li><li><div>业务层尽量精确地按异常种类处理异常</div></li><li><div>最上面的展示层捕获最终的所有漏风之鱼</div></li></ul></ul><div><br/></div><div>你的代码是可测试的，进而意味着你的代码是可重构的。随时验证每一步重构的正确性，让重构的风险降到最低</div><div><br/></div><div>即使你不写测试用例，你的脑海里也应该时时刻刻装着单元测试，脑补你代码的测试用例！只有你的脑子里时刻装载着单元测试，才能酝酿出最上乘的代码</div><div><br/></div><div>如果一个模块本身就足够大，需要完全靠自己从零搭建，这时一定要事先设计评审，否则走弯路的代价是不可承受的</div><div><br/></div><div>代码评审的好处：</div><ul><li><div>提高代码质量</div></li><li><div>修复bug的代价最小</div></li><li><div>促使团队之间相互备份</div></li><li><div>代码写得烂，反而会增加这个项目对该程序员的依赖性</div></li></ul><div><br/></div><div>出现烂代码的原因：</div><ul><li><div>水平暂时确实很烂</div></li><li><div>“懒”点出现</div></li><li><div>“舍不得”心理</div></li></ul><div><br/></div><div>代码评审关键是流程化：</div><ul><li><div>1）规定一个固定的周期去做代码评审</div></li><li><div>2）硬性规定代码评审属于任务的一部分</div></li><li><div>3）一定要有个主审人提前去看代码，否则效果大打折扣</div></li><li><div>4）被审核的开发者，最好能主动提出哪些代码可能存在潜在的问题</div></li><li><div>5）会议中提出来的疑问点，会议中当场讨论</div></li><li><div>6）会议上，大家有机会头脑风暴，架构优化的正确选择要建立在完备的信息之上</div></li><li><div>7）3个方面去进行代码评审</div></li><ul><li><div>变量名和函数名是不是准确？</div></li><li><div>有没有明显的BUG？</div></li><li><div>整体设计有没有优化的空间？</div></li></ul></ul><div><br/></div><div>编程的写作目的只有“如何描述得更准确、更简单”，它并不需要有趣</div><div><br/></div><div>精确描述每个函数名、变量名和类名，能大大有利于整体思路的构建</div><div><br/></div><div>少依赖注释的一个重要原因：程序员可能不停地修改代码，但程序员很维保证不停地去维护相应注释，尤其是别人写的注释。久而久之，容易造成代码和注释脱节</div><div><br/></div><div>不要期望函数名和参数描述不了的信息，让注释去描述</div><div><br/></div><div>一定要站在用户体验的角度去和产品经理争论，这样才能占领制高点。切不可直接站在实现难度的角度去争论</div><div><br/></div><div>你所经历的产品或项目将决定你技术水平的高度，业余学习决定你知识的宽度</div><div><br/></div><div>弥补短板比扩充长板更难，随着年龄的增长，只会变得越来越难。弥补短板要趁早，越年轻的时候，越要注重短板的弥补。而只要努力，你的长板往往会更长。年纪越往上，侧重点越应该在长板，让自己的长板得到释放，得到发挥</div><div><br/></div><div>最好的职业规划是不要以退休为终点，因为退休之后你的人生还很长。要以一辈子为终点，这种思维更开阔</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 