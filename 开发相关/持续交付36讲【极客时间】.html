<html>
<head>
  <title>持续交付36讲【极客时间】</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="982"/>
<h1>持续交付36讲【极客时间】</h1>

<div><span><div>持续交付“发布流水线”：</div><div><br/></div><div>虽然持续交付着重打造的是发布流水线部分，但它所要达到的目标是在“最终用户”和“研发团队”之间建立紧密 的反馈环：通过持续交付新的软件版本，以验证想法和软件改动的正确性，并衡量这些改动对软件价值的影响</div><div><br/></div><div>持续集成的三个层次：</div><ul><li><div>1）分模块编码</div></li><li><div>2）整体集成</div></li><li><div>3）实现以上两个过程的自动化，并形成闭环</div></li></ul><div><br/></div><div>DevOps（Dev，开发；Ops，运维）：</div><ul><li><div>1）一组技术，包括：自动化运维、持续交付、高频部署、Docker等</div></li><li><div>2）一个职能，全栈工程师</div></li><li><div>3）一种文化，推倒Dev与Ops之间的阻碍墙</div></li><li><div>4）一种组织结构，将Dev和Ops置于一个团队内，一同工作，同化目标，以达到DevOps文化地彻底贯彻</div></li></ul><div><br/></div><div>采用不同的代码分支策略，意味着实施不同的代码集成与上线流程，这会影响整个研发团队每日的协作方式，因此研发团队通常会很认真地选择自己的策略</div><div><br/></div><div>主干分支开发优缺点：</div><div><img src="持续交付36讲【极客时间】_files/Image.png" type="image/png" data-filename="Image.png"/><br/></div><div><br/></div><div>Git Flow示意图：</div><div><img src="持续交付36讲【极客时间】_files/Image [1].png" type="image/png" data-filename="Image.png"/><br/></div><div><br/></div><div>GitHub Flow示意图：</div><div><img src="持续交付36讲【极客时间】_files/Image [2].png" type="image/png" data-filename="Image.png"/><br/></div><div><br/></div><div>GitHub Flow：</div><ul><li><div>master分支中包含稳定的代码，它已经或即将被部署到生产环境。任何开发人员都不允许把未测试或未审查 的代码直接提交到master分支。对代码的任何修改，包括Bug修复、热修复、新功能开发等都在单独的分支中进行。不管是一行代码的小改动，还是需要几个星期开发的新功能，都采用同样的方式来管理。</div></li><li><div>当需要修改时，从master分支创建一个新的分支，所有相关的代码修改都在新分支中进行。开发人员可以自由地提交代码和提交到远程仓库</div></li><li><div>当新分支中的代码全部完成之后，通过GitHub提交一个新的pull request。团队中的其他人员会对代码进行审查，提出修养的修改意见。由持续集成服务器（如Jenkins）对新分支进行自动化测试。当代码通过自动化测试和代码审查之后，该分支的代码被合并到master分支。再从master分支部署到生产环境</div></li></ul><div><br/></div><div>GitLab Flow发布场景：</div><div><img src="持续交付36讲【极客时间】_files/Image [3].png" type="image/png" data-filename="Image.png"/><br/></div><div><br/></div><div>带生产分支的GitLab Flow：</div><div><img src="持续交付36讲【极客时间】_files/Image [4].png" type="image/png" data-filename="Image.png"/><br/></div><div><br/></div><div>带环境分支的GitLab Flow：</div><div><img src="持续交付36讲【极客时间】_files/Image [5].png" type="image/png" data-filename="Image.png"/><br/></div><div><br/></div><div>带发布分支的GitLab Flow：</div><div><img src="持续交付36讲【极客时间】_files/Image [6].png" type="image/png" data-filename="Image.png"/><br/></div><div><br/></div><div>特性分支开发的优缺点：</div><div><img src="持续交付36讲【极客时间】_files/Image [7].png" type="image/png" data-filename="Image.png"/><br/></div><div><br/></div><div>分支策略的选择：</div><div><img src="持续交付36讲【极客时间】_files/Image [8].png" type="image/png" data-filename="Image.png"/><br/></div><div><br/></div><div>回滚：</div><ul><li><div>1）包回滚是指，线上运行的系统，从现在的版本回滚到以前稳定的老版本</div></li><li><div>2）代码回滚是指，Git分支的指针（游标），从指向当前有问题的版本改为指向一个该分支历史树上没问题的版本，而这个版本可以是曾经的commit，也可以是新建的commit</div></li></ul><div><br/></div><div>哪些情况下需要回滚代码：</div><ul><li><div>1）开发人员独立使用的分支上，如果最近产生的commit都没有价值，应该废弃掉，此时就需要把代码回滚到以前的版本</div></li><li><div>2）代码集成到团队的集成分支且尚未发布，但在后续测试中发现这部分代码有问题，且一时半会儿解决不掉，为了不把问题传递给下次的集成，此时就需要把有问题的代码从集成分支中回滚掉</div></li><li><div>3）代码已经发布到线上，线上包回滚后发现是新上线的代码引起的问题，且需要一段时间修复，此时又有其他功能需要上线，那么主干分支必须把代码回滚到产品包对应的commit</div></li></ul><div><br/></div><div>代码回滚原则：</div><ul><li><div>1）集成分支上的commit都是项目阶段性的成果，即使最近的发布不需要某些commit的功能，但仍然需要保留这些commit，以备后续之需</div></li><li><div>2）开发人员会基于集成分支上的commit拉取新分支，如果集成分支采用reset的方式清除了该commit，下次开发人员把新分支合并回集成分支进，又会把被清除的commit申请合入，很可能导致不需要的功能再次被引入到集成分支</div></li></ul><div><br/></div><div>三种典型的回滚场景及策略：</div><div><img src="持续交付36讲【极客时间】_files/Image [9].png" type="image/png" data-filename="Image.png"/><br/></div><div><br/></div><div>测试环境容易被忽略：</div><ul><li><div>1）我们总是把环境理想化，忽略了其管理的难度</div></li><li><div>2）我们也很少设立专职的环境管理员，导致环境长期处于混乱</div></li></ul><div><br/></div><div>不论一套环境用户是测试还是开发，以下几个需求都是必须被做到的</div><ul><li><div>1）可得性，即在开发一个新项目时，能快速获取构建一个环境需要的机器，基础设施。最好的情况是，能随时可得，随时归还</div></li><li><div>2）快速部署，妈在搭建新环境时，能以最快的速度构建出一整套完整的环境</div></li><li><div>3）独立性，即一个环境在使用过程中，可以不受其他项目测试人员的干扰</div></li><li><div>4）稳定性，即不会因为下游服务，基础设施的异常，造成测试中断、等待</div></li><li><div>5）高仿真，主要分为两个方面：“测试数据真实”，即能在测试环境构建出真实的测试用例；“环境真实”，即基础服务的架构和行为与线上环境保持一致，避免因为环境不一致造成测试结果不一致</div></li></ul><div><br/></div><div>应该怎样去规划和设计环境呢？</div><ul><li><div>1）公共与泳道的</div></li><ul><li><div>抽象公共环境，其中的公共服务基本都属于底层服务，相对比较稳定，这是解耦环境的重中之重。如中间件、框架类服务、底层业务公共（账户、登陆、基本信息）服务</div></li><li><div>通过泳道方式隔离相关测试应用，利用LB和SOA中间件对路由功能的支持，在一个大的公共集成测试环境中隔离出一个个独立的功能测试环境</div></li></ul><li><div>2）避免产生多套公共环境</div></li><li><div>3）减轻配置的复杂度：</div></li><ul><li><div>制定一套统一配置的解决方案</div></li><li><div>要让环境自己说话，有效减少配置项</div></li></ul></ul><div><br/></div><div>从面向的目标来看，环境配置大体上可以分为两大部分：</div><ul><li><div>1）以环境中每台服务器为对象的运行时配置</div></li><li><div>2）以一个环境为整体目标的独立环境配置</div></li></ul><div><br/></div><div>我们不光要考虑单个实例初始化配置，还要考虑每次JDK、Tomcat等基础软件的版本升级引起的运行时配置的变更，而且这些变更都需要被清晰地记录下来，从而保证扩容出新的服务器时能取到正确的、最新的配置</div><div><br/></div><div>要让一个环境能够符合需求的正常工作，需要考虑：</div><ul><li><div>1）这个环境所依赖的数据库该如何配置，缓存服务器又该如何配置</div></li><li><div>2）如果是分布式系统，或者SOA架构的话，就需要考虑服务中心、配置中心行装一系列的中间件的配置问题</div></li></ul><div><br/></div><div>所谓标准化，就是为了在一定范围内获得最佳秩序，对实际的或潜在的问题特定共同的、可重复使用的规则</div><div><br/></div><div>建议在实施持续交付时，去推动形成以下几个方面的规范：</div><ul><li><div>1）代码及依赖规范</div></li><li><div>2）命名规范</div></li><li><div>3）开发规范</div></li><li><div>4）配置规范</div></li><li><div>5）部署规范</div></li><li><div>6）安全规范</div></li><li><div>7）测试规范</div></li></ul><div><br/></div><div>配置管理：是通过技术或行政手段对软件产品及其开发过程和生命周期进行控制、规范的一系列措施。它的目标是记录软件产品的演化过程，确保软件开发者在软件生命周期的各个阶段都能得到精确的产品配置信息</div><div><br/></div><div>配置：是指独立于程序之外，但又对程序产生作用的可配变量。也就是说，同一份代码在不同的配置下，会产生不同的结果</div><div><br/></div><div>配置和配置管理有着本质上的不同：配置管理服务于软件研发过程，而配置则服务于程序本身</div><div><br/></div><div>打包时配置的基本思想是：构建时完全不清楚程序所以要部署的环境，因此只完成最基本的默认配置；而发布时清晰地知晓环境信息，因此可根据环境信息，进行相关配置的替换</div><div><br/></div><div>先回滚配置还是先回滚代码？最好的办法是保证配置与代码的兼容性，这有点类似于数据库的schema变更。比如，只增加配置不删减配置、不改变配置的数据类型而是新增一个配置等方法。同时，也要做好代码版本与配置版本的对应管理</div><div><br/></div><div>域名的维护尽量在SLB（负载均衡）类似的软件负载中间件上实现，而不要在DNS上实现。因为域名变更 时，通过泛域名的指向，SLB二次解析可以做到域名访问的实时切换。而如果配置在DNS上，域名的变更就无法做到瞬时生效了</div><div><br/></div><div>容器技术统一了软件环境和软件代码，交付产物中既包括了软件环境，又包括了软件代码。也就是说，容器帮我们重新定义了交付标准</div><div><br/></div><div>不可变基础设施：在这种模式中，任何基础设施的实例（包括服务器、容器等各种软硬件）一旦创建之后便成为一种只读状态，不可对其进行任何更改。如果需要修改或升级某些实例，唯一的方式就是创建一批新的实例来替换它</div><div><br/></div><div>当你使用成熟的构建工具进行构建时，如果无法通过一些软件技术手段提升软件本身的构建速度，那么根据构建特点，有针对性地升级硬件资源，是最简单粗暴的方法</div><div><br/></div><div>如果你的团队暂没有条件自己搭建私有仓库的话，可以使用国内一些私有仓库，来提升下载速度。当然，在选择私有仓库时，你要尽量挑选那些被广泛使用的仓库，避免安全隐患</div><div><br/></div><div>五种常见的构建提速方式：</div><ul><li><div>1）升级硬件资源，最直接和粗暴的提速方式</div></li><li><div>2）搭建私有仓库，避免从外网下载依赖</div></li><li><div>3）使用本地缓存，减少每次构建时依赖下载的消耗</div></li><li><div>4）规范构建流程，通过异步方式解决旁支流程的拍卖行</div></li><li><div>5）善用构建工具，根据实际情况合理发挥的工具特性</div></li></ul><div><br/></div><div>如何做好镜像的优化呢？</div><ul><li><div>1）选择合适的Base镜像</div></li><li><div>2）减少不必要的镜像层的产生</div></li><li><div>3）充分利用指令的缓存</div></li></ul><div><br/></div><div>互联网产品通常不用deploy，也不用release，而是使用rollout这个词。发布是一个慢慢滚动向前、逐步生效的过程</div><div><br/></div><div>比较完善的变更发布流程：</div><ul><li><div>1）下载新的版本，不执行覆盖</div></li><li><div>2）通知上游调用方，自己现在为暂停服务状态</div></li><li><div>3）运行命令load变更重启服务</div></li><li><div>4）验证服务的健康状况</div></li><li><div>5）通知上游调用方，自己服务恢复正常</div></li></ul><div><br/></div><div>灰度发布是指，渐进式地更新每台机器运行的版本，一段时期内集群内运行着多个不同的版本，同一个API在不同机器上返回的结果很可能不同</div><div><br/></div><div>几种灰度发布方式：</div><ul><li><div>1）蓝绿发布，先增加一套新的集群，发布新版本到这批新机器，并进行验证，新版本服务器并不接入外部流量</div></li><ul><li><div>需要额外的服务器集群支持，对于负载高的核心应用机器需求可观，实现难度巨大且成本较高</div></li><li><div>好处是所有服务都使用这种方式时，实际上创造了蓝绿两套环境，隔离性最好、最可控，回滚切换几乎没有成本</div></li></ul><li><div>2）滚动发布，是不添加新机器 ，从同样的集群服务器中挑选一批，停止上面的服务，并更新为新版本，进行验证，验证完毕后接入流量</div></li><ul><li><div>比蓝绿发布节省资源，但发布过程中同时会有两个版本对外提供服务，无论对自身或是调用者都有较高的兼容性要求，需要团队间的合作妥协</div></li></ul><li><div>3）金丝雀发布，从集群中挑选特定服务器或一小批符合要求的特征用户，对其进行版本更新及验证，随后逐步更新剩余服务器。需要精细的流控和数据的支持，同样有版本兼容的需求</div></li></ul><div><br/></div><div>根据不可变模式，推导出来的发布方法：</div><ul><li><div>1）构建一个新的基础设施</div></li><li><div>2）测试新的基础设施是否符合需求</div></li><li><div>3）将引用指向这个新的基础设施</div></li><li><div>4）保留原有基础设施以备回滚</div></li></ul><div><br/></div><div>容器是一个惊人的发明，它使得每一次变更都成为了一次发布，而每一次发布都成为了系统的重新构建，从而使得“一致”模型的目标能够达成</div><div><br/></div><div>每一次变更都是一次发布，而每一次发布都是系统重新构建，更形象点说，每一次发布都是一个独立镜像的启动</div><div><br/></div><div>高效的发布系统架构应该是清晰的、健壮的、低耦合的，从而达到在最糟糕的情况下也能动作的目的</div><div><br/></div><div>携程的发布系统架构：</div><div><img src="持续交付36讲【极客时间】_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><ul><li><div>1）每台服务实例上的发布脚本一旦产生则不再修改，以达到不可变模型的要求</div></li><li><div>2）发布引擎和Salt Master之间采用异步通信，但为增强系统健壮性，要有同步轮询的备案</div></li><li><div>3）面对频繁 的信息获取，要善用缓存，但同时也一定要慎用缓存，注意发布信息的新鲜度</div></li></ul><div><br/></div><div>携程发布系统的流程：</div><div><img src="持续交付36讲【极客时间】_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>全是发布是互联网应用发布的最好方式</div><div><br/></div><div>千万不要认为发布结束，就万事大吉了。特别是生产发布，发布结束时才是最危险的时刻</div><div><br/></div><div>从一般意义上来讲，我们会把监控分为以下几类：</div><ul><li><div>1）用户侧监控，关注的是用户真正感受到的访问速度和结果</div></li><li><div>2）网络监控，即CDN与核心网络的监控</div></li><li><div>3）业务监控，关注的是核心业务指标的波动</div></li><li><div>4）应用监控，即服务调用链的监控</div></li><li><div>5）系统监控，即基础设施、虚拟机及操作系统的监控</div></li></ul><div><br/></div><div>有统计数据证明，在整个软件开发生命周期中，有70%左右的代码逻辑设计和编码缺陷属于重复性错误，完全可以通过静态代码分析发现和修复</div><div><br/></div><div>挑选合适的静态代码分析工具，自动化地执行代码检查和分析，可以极大地提高代码静态检查的可靠性，节省测试成本</div><div><br/></div><div>Sonar静态代码检查工具</div><div><br/></div><div>静态代码检查的相关流程：</div><ul><li><div>1）鼓励开发人员在开发环境下执行静态检查（不管是IDE还是编辑器加命令行）</div></li><li><div>2）不管采用的是主干开发还是特性分支开发的分支策略，都尽可能地在代码合入主干之前，通过静态检查</div></li><li><div>3）没有通过静态检查的产品包，不允许发布到线上或用户验证环境</div></li></ul><div><br/></div><div>破坏性测试就是通过有效地测试手段，使软件应用程序出现奔溃或失败的情况，然后测试在这样的情况下，软件运行会产生什么结果，而这些结果又是否符合预期</div><div><br/></div><div>设计破坏性测试的测试用例时，会考虑两个维度：</div><ul><li><div>1）破坏点的具体测试，即设计一个或一组操作，能够导致应用或系统奔溃或异常</div></li><ul><li><div>出现问题后的系统或软件是否有能力按预期捕获和处理异常</div></li><li><div>确认被破坏的系统是否有能力按照预期设计进行必要的修复，以确保能够继续处理后续内容</div></li></ul><li><div>2）整个系统的破坏性测试，使用压力、暴力、阻断链路等方法，找到需要进行破坏性测试的具体的点</div></li></ul><div><br/></div><div>绝大部分破坏性测试都会在单元测试、功能测试阶段执行。而执行测试的环境也往往是局部的测试子环境</div><div><br/></div><div>混沌工程是在分布式系统上建立的实验，其目的是建立对系统承受混乱冲击能力的信心</div><div><br/></div><div>分布式系统的弱点：</div><ul><li><div>1）当服务不可用时，不可用或不完事的回退能力</div></li><li><div>2）不合理的设置超时时间引起重试风暴</div></li><li><div>3）依赖服务接收过多的流量，从而导致中断</div></li><li><div>4）由单个故障点引起的级联故障</div></li><li><div>5）……</div></li></ul><div><br/></div><div>混沌工程的实验步骤：</div><ul><li><div>1）将正常系统的一些正常行为的可测量数据定义为“稳定态”</div></li><li><div>2）建立一个对照组，并假设对照组和实验组都保持“稳定态”</div></li><li><div>3）引入真实世界的变量，如服务器崩溃、断网、磁盘损坏等</div></li><li><div>4）尝试寻找对照组和实验组之间的差异，找出系统弱点</div></li></ul><div><br/></div><div>混沌工程几个高级原则：</div><ul><li><div>1）使用改变现实世界的事件，就在要在真实的场景中进行实验，而不要想象和构造一些假想和假设的场景</div></li><li><div>2）在生产环境运行，为了发现真实场景的弱点</div></li><li><div>3）自动化连续实现</div></li><li><div>4）最小爆破半径，尽量减少对用户的负面影响，减少范围和程度</div></li></ul><div><br/></div><div>要做到和实际用户操作一致，最好的方法就是记录实际用户在生产环境的操作，然后在测试环境中回话</div><div><br/></div><div>交付平台化七个步骤：</div><ul><li><div>1）确定模块及范围</div></li><ul><li><div>代码管理模块，谢谢会和代码审核、静态扫描和分支管理等模块相联系</div></li><li><div>集成编译模块，也会与依赖管理、单元测试、加密打包等模块相生相随</div></li><li><div>环境管理模块，离不开配置管理、路由管理等模块</div></li><li><div>发布部署模块，还需要监控模块和流控模块的支持</div></li></ul></ul><div><img src="持续交付36讲【极客时间】_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><ul><li><div>2）学会做减法</div></li><ul><li><div>横向缩小范围：优先实现上述模块的一部分</div></li><li><div>减少纵向深度：优先支持单一技术栈</div></li></ul><li><div>3）制定标准：标准先行</div></li><li><div>4）选择合适的驱动器：用来驱动整个持续交付流水线的引擎</div></li><li><div>5）抽象公共能力</div></li><ul><li><div>帐户与权限，包括单点登录，以及鉴权、授权体系</div></li><li><div>用户行为日志，即任何行动都要能够被追溯</div></li><li><div>消息通知，即提供统一的通知能力</div></li><li><div>安全与故障处理，即系统级的防护能力和故障降级</div></li></ul><li><div>6）考虑用户入口：用户入口，是提供一个统一的站点、使用命令行格式、使用IDE插件，还是直接使用Jenkins系统作为与用户交互的界面，可以根据团队的资源、能力等实际情况进行选择</div></li><li><div>7）聚力而成：团队</div></li></ul><div><br/></div><div>《持续交付：发布可靠软件的系统方法》中列举的反模式：</div><ul><li><div>1）手工部署软件</div></li><li><div>2）开发完之后才向类生产环境部署</div></li><li><div>3）生产环境需要手工配置管理</div></li></ul><div><br/></div><div>云计算对持续交付的影响：</div><ul><li><div>1）能够很容易地打破持续交付的反模式</div></li><li><div>2）可以使持续交付的编译模块变得更为灵活，提升利用率</div></li><li><div>3）可以自由地发挥想象力，简化环境管理的工作</div></li><li><div>4）可以使用存储服务，使持续交付工作更便捷</div></li></ul><div><br/></div><div>对于移动App的持续交付来说，我们特别需要维护版本的相关信息，并对每个版本进行管理</div><div><br/></div><div>发布快车模式，就像一列由多节车厢组成的火车，每一节车厢代表一个发布版本，整个火车以一节节车厢或者说一个个版本的节奏，定期向前发车。而工程师们，则会把自己开发完成的功能集成到一节节的车厢上，这样集成在一节车厢的功能代码，就形成了一个新的版本</div><div><img src="持续交付36讲【极客时间】_files/Image [13].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>发布快车三个关键点：</div><ul><li><div>1）并不是说所有开发的功能，都一定要集成到最近的那节车厢、最近的那个版本中</div></li><li><div>2）我们必须要保证固定间隔的发车时间，每周、每两周都可以，但必须保证每个车厢到点即发</div></li><li><div>3）这个过程的最终产物是可以发布到市场的版本，而不是发布到用户侧的版本</div></li></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 