<html>
<head>
  <title>分布式之数据库和缓存双写一致性方案解析</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="2597"/>
<h1>分布式之数据库和缓存双写一致性方案解析</h1>

<div><span><h2 style="padding: 0px; font-size: 2em; font-weight: bold; line-height: 1.5; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: rgb(63, 63, 63); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 2em; font-weight: bold; line-height: 1.5; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: rgb(63, 63, 63); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-east-asian: normal; font-variant-position: normal; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">引言
</span></h2><h3 style="padding: 0px; font-size: 16px; font-weight: bold; line-height: 1.5; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 16px; font-weight: bold; line-height: 1.5; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant: normal; letter-spacing: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);">为什么写这篇文章？
</span></h3><p style="padding: 0px; text-indent: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant: normal; letter-spacing: normal; line-height: 25.2px; orphans: auto; text-align: start; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></p><div>首先，缓存由于其高并发和高性能的特性，已经在项目中被广泛使用。在读取缓存方面，大家没啥疑问，都是按照下图的流程来进行业务操作。</div><div><br/></div><div><img src="分布式之数据库和缓存双写一致性方案解析_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">但是在更新缓存方面，对于更新完数据库，是更新缓存呢，还是删除缓存。又或者是先删除缓存，再更新数据库，其实大家存在很大的争议。目前没有一篇全面的博客，对这几种方案进行解析。于是博主战战兢兢，顶着被大家喷的风险，写了这篇文章。
</span></div><p></p><h3 style="padding: 0px; font-size: 16px; font-weight: bold; line-height: 1.5; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 16px; font-weight: bold; line-height: 1.5; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant: normal; letter-spacing: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);">文章结构
</span></h3><p style="padding: 0px; text-indent: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant: normal; letter-spacing: normal; line-height: 25.2px; orphans: auto; text-align: start; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></p><div>本文由以下三个部分组成</div><div><br/></div><div>1、讲解缓存更新策略</div><div><br/></div><div>2、对每种策略进行缺点分析</div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">3、针对缺点给出改进方案
</span></div><p></p><h2 style="padding: 0px; font-size: 2em; font-weight: bold; line-height: 1.5; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: rgb(63, 63, 63); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 2em; font-weight: bold; line-height: 1.5; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: rgb(63, 63, 63); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant: normal; letter-spacing: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);">正文
</span></h2><p style="padding: 0px; text-indent: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant: normal; letter-spacing: normal; line-height: 25.2px; orphans: auto; text-align: start; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></p><div>先做一个说明，从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。因此，接下来讨论的思路不依赖于给缓存设置过期时间这个方案。</div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">在这里，我们讨论</span><span style="font-weight: bold; color: red;-en-paragraph:true;">三种</span><span style="-en-paragraph:true;">更新策略：
</span></div><p></p><ol style="padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant: normal; letter-spacing: normal; line-height: 25.2px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><li style="padding: 0px; list-style-type: decimal;"><div>先更新数据库，再更新缓存</div></li><li style="padding: 0px; list-style-type: decimal;"><div>先删除缓存，再更新数据库</div></li><li style="padding: 0px; list-style-type: decimal;"><div>先更新数据库，再删除缓存</div></li></ol><div style="padding: 0px; text-indent: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-east-asian: normal; font-variant-position: normal; letter-spacing: normal; line-height: 25.2px; text-align: start; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-east-asian: normal; font-variant-position: normal; letter-spacing: normal; line-height: 25.2px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);-en-paragraph:true;">应该没人问我，为什么没有先更新缓存，再更新数据库这种策略。
</span></div><h3 style="padding: 0px; font-size: 16px; font-weight: bold; line-height: 1.5; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 16px; font-weight: bold; line-height: 1.5; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant: normal; letter-spacing: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);">(1)先更新数据库，再更新缓存
</span></h3><p style="padding: 0px; text-indent: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant: normal; letter-spacing: normal; line-height: 25.2px; orphans: auto; text-align: start; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></p><div>这套方案，大家是普遍反对的。为什么呢？有如下两点原因。</div><div><br/></div><div><span style="font-weight: bold; color: blue;">原因一（线程安全角度）</span></div><div><br/></div><div>同时有请求A和请求B进行更新操作，那么会出现</div><div><br/></div><div>（1）线程A更新了数据库</div><div><br/></div><div>（2）线程B更新了数据库</div><div><br/></div><div>（3）线程B更新了缓存</div><div><br/></div><div>（4）线程A更新了缓存</div><div><br/></div><div>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。</div><div><br/></div><div><span style="font-weight: bold; color: blue;">原因二（业务场景角度）</span></div><div><br/></div><div>有如下两点：</div><div><br/></div><div>（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。</div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。
</span></div><p></p><div style="padding: 0px; text-indent: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-east-asian: normal; font-variant-position: normal; letter-spacing: normal; line-height: 25.2px; text-align: start; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-east-asian: normal; font-variant-position: normal; letter-spacing: normal; line-height: 25.2px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);-en-paragraph:true;">接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。
</span></div><h3 style="padding: 0px; font-size: 16px; font-weight: bold; line-height: 1.5; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 16px; font-weight: bold; line-height: 1.5; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant: normal; letter-spacing: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);">(2)先删缓存，再更新数据库
</span></h3><p style="padding: 0px; text-indent: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant: normal; letter-spacing: normal; line-height: 25.2px; orphans: auto; text-align: start; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></p><div>该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</div><div><br/></div><div>（1）请求A进行写操作，删除缓存</div><div><br/></div><div>（2）请求B查询发现缓存不存在</div><div><br/></div><div>（3）请求B去数据库查询得到旧值</div><div><br/></div><div>（4）请求B将旧值写入缓存</div><div><br/></div><div>（5）请求A将新值写入数据库</div><div><br/></div><div>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</div><div><br/></div><div>那么，<span style="font-weight: bold; color: red;">如何解决呢？</span><span style="font-weight: bold;">采用延时双删策略</span></div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">伪代码如下
</span></div><p></p><div style="padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant: normal; letter-spacing: normal; line-height: 25.2px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><div style="padding: 0px; white-space: pre-wrap; word-wrap: break-word;"><div><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(0, 0, 255); background: rgb(255, 255, 255);">public</span><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(0, 0, 0); background: rgb(255, 255, 255);"> </span><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(0, 0, 255); background: rgb(255, 255, 255);">void</span><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(0, 0, 0); background: rgb(255, 255, 255);"> </span><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(163, 21, 21); background: rgb(255, 255, 255);">write</span><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(0, 0, 0); background: rgb(255, 255, 255);">(String key,Object data)</span><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(0, 0, 0); background: rgb(255, 255, 255);">{</span></div><div><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(0, 0, 0); background: rgb(255, 255, 255);">        redis.</span><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(0, 0, 0); background: rgb(255, 255, 255);">delKey</span><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(0, 0, 0); background: rgb(255, 255, 255);">(key);</span></div><div><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(0, 0, 0); background: rgb(255, 255, 255);">        db.</span><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(0, 0, 0); background: rgb(255, 255, 255);">updateData</span><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(0, 0, 0); background: rgb(255, 255, 255);">(data);</span></div><div><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(0, 0, 0); background: rgb(255, 255, 255);">        Thread.</span><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(0, 0, 0); background: rgb(255, 255, 255);">sleep</span><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(0, 0, 0); background: rgb(255, 255, 255);">(</span><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(0, 0, 0); background: rgb(255, 255, 255);">1000</span><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(0, 0, 0); background: rgb(255, 255, 255);">);</span></div><div><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(0, 0, 0); background: rgb(255, 255, 255);">        redis.</span><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(0, 0, 0); background: rgb(255, 255, 255);">delKey</span><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(0, 0, 0); background: rgb(255, 255, 255);">(key);</span></div><div><span style="line-height: 1.5 !important; vertical-align: middle; font-family: 'Courier New', sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; border-radius: 3px !important; overflow-x: auto; color: rgb(0, 0, 0); background: rgb(255, 255, 255);">    }</span></div></div></div><p style="padding: 0px; text-indent: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant: normal; letter-spacing: normal; line-height: 25.2px; orphans: auto; text-align: start; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></p><div>转化为中文描述就是</div><div><br/></div><div>（1）先淘汰缓存</div><div><br/></div><div>（2）再写数据库（这两步和原来一样）</div><div><br/></div><div>（3）休眠1秒，再次淘汰缓存</div><div><br/></div><div>这么做，可以将1秒内所造成的缓存脏数据，再次删除。</div><div><br/></div><div><span style="font-weight: bold; font-size: 14px;">那么，这个1秒怎么确定的，具体该休眠多久呢？</span></div><div><br/></div><div>针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</div><div><br/></div><div><span style="font-weight: bold; font-size: 14px;">如果你用了mysql的读写分离架构怎么办？</span></div><div><br/></div><div>ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。</div><div><br/></div><div>（1）请求A进行写操作，删除缓存</div><div><br/></div><div>（2）请求A将数据写入数据库了，</div><div><br/></div><div>（3）请求B查询缓存发现，缓存没有值</div><div><br/></div><div>（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值</div><div><br/></div><div>（5）请求B将旧值写入缓存</div><div><br/></div><div>（6）数据库完成主从同步，从库变为新值</div><div><br/></div><div>上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。</div><div><br/></div><div><span style="font-weight: bold; font-size: 14px;">采用这种同步淘汰策略，吞吐量降低怎么办？</span></div><div><br/></div><div>ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。</div><div><br/></div><div><span style="font-weight: bold; font-size: 14px;">第二次删除,如果删除失败怎么办？</span></div><div><br/></div><div>这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：</div><div><br/></div><div>（1）请求A进行写操作，删除缓存</div><div><br/></div><div>（2）请求B查询发现缓存不存在</div><div><br/></div><div>（3）请求B去数据库查询得到旧值</div><div><br/></div><div>（4）请求B将旧值写入缓存</div><div><br/></div><div>（5）请求A将新值写入数据库</div><div><br/></div><div>（6）请求A试图去删除请求B写入对缓存值，结果失败了。</div><div><br/></div><div>ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。</div><div><br/></div><div><span style="font-weight: bold; font-size: 14px;">如何解决呢？</span></div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">具体解决方案，且看博主对第(3)种更新策略的解析。
</span></div><p></p><h3 style="padding: 0px; font-size: 16px; font-weight: bold; line-height: 1.5; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 16px; font-weight: bold; line-height: 1.5; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant: normal; letter-spacing: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);">(3)先更新数据库，再删缓存
</span></h3><div style="padding: 0px; text-indent: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-east-asian: normal; font-variant-position: normal; letter-spacing: normal; line-height: 25.2px; text-align: start; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-east-asian: normal; font-variant-position: normal; letter-spacing: normal; line-height: 25.2px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);-en-paragraph:true;">首先，先说一下。老外提出了一个缓存更新套路，名为</span><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside" style="text-indent: 0px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-east-asian: normal; font-variant-position: normal; letter-spacing: normal; line-height: 25.2px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration: underline;-en-paragraph:true;">《Cache-Aside pattern》</a><span style="text-indent: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-east-asian: normal; font-variant-position: normal; letter-spacing: normal; line-height: 25.2px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);-en-paragraph:true;">。其中就指出
</span></div><ul style="padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant: normal; letter-spacing: normal; line-height: 25.2px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><li style="padding: 0px; list-style-type: disc;"><div><span style="font-weight: bold;">失效</span>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</div></li><li style="padding: 0px; list-style-type: disc;"><div><span style="font-weight: bold;">命中</span>：应用程序从cache中取数据，取到后返回。</div></li><li style="padding: 0px; list-style-type: disc;"><div><span style="font-weight: bold;">更新</span>：先把数据存到数据库中，成功后，再让缓存失效。</div></li></ul><p style="padding: 0px; text-indent: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant: normal; letter-spacing: normal; line-height: 25.2px; orphans: auto; text-align: start; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></p><div>另外，知名社交网站facebook也在论文<a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf" style="color: rgb(0, 0, 0); text-decoration: underline;">《Scaling Memcache at Facebook》</a>中提出，他们用的也是先更新数据库，再删缓存的策略。</div><div><br/></div><div><span style="font-weight: bold; font-size: 14px;">这种情况不存在并发问题么？</span></div><div><br/></div><div>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</div><div><br/></div><div>（1）缓存刚好失效</div><div><br/></div><div>（2）请求A查询数据库，得一个旧值</div><div><br/></div><div>（3）请求B将新值写入数据库</div><div><br/></div><div>（4）请求B删除缓存</div><div><br/></div><div>（5）请求A将查到的旧值写入缓存</div><div><br/></div><div>ok，如果发生上述情况，确实是会发生脏数据。</div><div><br/></div><div><span style="font-weight: bold; color: red;">然而，发生这种情况的概率又有多少呢？</span></div><div><br/></div><div>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。</div><div><br/></div><div>假设，有人非要抬杠，有强迫症，一定要解决怎么办？</div><div><br/></div><div><span style="font-weight: bold; font-size: 14px;">如何解决上述并发问题？</span></div><div><br/></div><div>首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。</div><div><br/></div><div><span style="font-weight: bold; font-size: 14px;">还有其他造成不一致的原因么？</span></div><div><br/></div><div>有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。</div><div><br/></div><div><span style="font-weight: bold; font-size: 14px;">如何解决</span><span style="font-weight: bold;">？</span></div><div><br/></div><div>提供一个保障的重试机制即可，这里给出两套方案。</div><div><br/></div><div><span style="font-weight: bold; color: blue;">方案一</span>：</div><div><br/></div><div>如下图所示</div><div><br/></div><div><img src="分布式之数据库和缓存双写一致性方案解析_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>流程如下所示</div><div><br/></div><div>（1）更新数据库数据；</div><div><br/></div><div>（2）缓存因为种种问题删除失败</div><div><br/></div><div>（3）将需要删除的key发送至消息队列</div><div><br/></div><div>（4）自己消费消息，获得需要删除的key</div><div><br/></div><div>（5）继续重试删除操作，直到成功</div><div><br/></div><div>然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。</div><div><br/></div><div><span style="font-weight: bold; color: blue;">方案二</span>：</div><div><br/></div><div><img src="分布式之数据库和缓存双写一致性方案解析_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>流程如下图所示：</div><div><br/></div><div>（1）更新数据库数据</div><div><br/></div><div>（2）数据库会将操作信息写入binlog日志当中</div><div><br/></div><div>（3）订阅程序提取出所需要的数据以及key</div><div><br/></div><div>（4）另起一段非业务代码，获得该信息</div><div><br/></div><div>（5）尝试删除缓存操作，发现删除失败</div><div><br/></div><div>（6）将这些信息发送至消息队列</div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">（7）重新从消息队列中获得该数据，重试操作。
</span></div><p></p><div style="padding: 0px; text-indent: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-east-asian: normal; font-variant-position: normal; letter-spacing: normal; line-height: 25.2px; text-align: start; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-east-asian: normal; font-variant-position: normal; letter-spacing: normal; line-height: 25.2px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); font-weight: bold;-en-paragraph:true;">备注说明：</span><span style="text-indent: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-east-asian: normal; font-variant-position: normal; letter-spacing: normal; line-height: 25.2px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);-en-paragraph:true;">上述的</span><span style="text-indent: 0px; color: red; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-east-asian: normal; font-variant-position: normal; letter-spacing: normal; line-height: 25.2px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);-en-paragraph:true;">订阅binlog程序</span><span style="text-indent: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-east-asian: normal; font-variant-position: normal; letter-spacing: normal; line-height: 25.2px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);-en-paragraph:true;">在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。至于oracle中，博主目前不知道有没有现成中间件可以使用。另外，重试机制，博主是采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，这些大家可以灵活自由发挥，只是提供一个思路。
</span></div><h2 style="padding: 0px; font-size: 2em; font-weight: bold; line-height: 1.5; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: rgb(63, 63, 63); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 2em; font-weight: bold; line-height: 1.5; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: rgb(63, 63, 63); color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant: normal; letter-spacing: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);">总结
</span></h2><div><span style="text-indent: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-east-asian: normal; font-variant-position: normal; letter-spacing: normal; line-height: 25.2px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;-en-paragraph:true;">本文其实是对目前互联网中已有的一致性方案，进行了一个总结。对于先删缓存，再更新数据库的更新策略，还有方案提出维护一个内存队列的方式，博主看了一下，觉得实现异常复杂，没有必要，因此没有必要在文中给出。最后，希望大家有所收获。
</span></div></span>
</div></body></html> 