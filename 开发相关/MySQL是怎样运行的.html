<html>
<head>
  <title>MySQL是怎样运行的</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="521"/>
<h1>MySQL是怎样运行的</h1>

<div><span><div><span style="font-family: unset; font-weight: bold;">启动：</span></div><div>mysqld_safe 守护进程</div><div>m<span style="font-size: unset; font-family: unset;">ysql.server 间接调用mysqld_safe</span></div><div><span style="font-size: unset;"><br/></span></div><div><span style="font-weight: bold;">配置文件加载顺序：</span></div><div>/etc/my.cnf</div><div>/etc/mysql/my.cnf</div><div>SYSCONFDIR/my.cnf</div><div>$MYSQL_HOME/my.cnf</div><div>--defaults-extra-file 命令行指定</div><div>~/.my.cnf</div><div>~/.mylogin.cnf</div><div><span style="font-size: unset; font-family: unset;">最后的优先级最高</span></div><div><span style="font-size: unset;"><br/></span></div><div><span style="font-size: unset;"><span style="font-size: unset; font-family: unset; font-weight: bold;">配置文件组：</span></span></div><div><span style="font-size: unset; font-family: unset;">[server]、[mysqld]、[mysqld_safe]、[mysql.server]</span></div><div><span style="font-size: unset; font-family: unset;">[client]、[mysql]</span></div><div><span style="font-size: unset; font-family: unset;">[mysqladmin]、[mysqldump]</span></div><div><span style="font-size: unset;"><br/></span></div><div>mysqld_safe/m<span style="font-size: unset; font-family: unset;">ysql.server 使用</span> <span style="font-size: unset; font-family: unset;">[server]、[mysqld]、[mysqld_safe]</span></div><div>mysql 使用 <span style="font-size: unset; font-family: unset;">[client]、[mysql]</span></div><div>mysqladmin 使用 <span style="font-size: unset; font-family: unset;">[client]、</span><span style="font-size: unset; font-family: unset;">[mysqladmin]</span></div><div><span style="font-size: unset; font-family: unset;">mysqldump 使用 </span><span style="font-size: unset; font-family: unset;">[client]、</span><span style="font-size: unset; font-family: unset;">[mysqldump]</span></div><div><span style="font-size: unset;"><br/></span></div><div><span style="font-size: unset; font-family: unset;">按文件内部的顺序，以最后定义的为准</span></div><div><span style="font-size: unset;"><br/></span></div><div><span style="font-weight: bold;">系统变量：</span></div><div>SHOW [GLOBAL|SESSION] VARIABLES LIKE ‘%xxxxx%’;</div><div>SET [GLOBAL|SESSION] xxxx=xxx;</div><div><br/></div><div><span style="font-weight: bold;">状态变量：</span></div><div>SHOW [GLOBAL|SESSION] STATUS LIKE ‘%xxxxx%’;</div><div><br/></div><div><span style="font-family: unset; font-weight: bold;"><font style="font-size: 24px;">B+树，索引：</font></span></div><div><span style="font-weight: bold;">INNODB 索引即数据，数据即索引，</span><span style="font-size: unset; font-weight: bold; font-family: unset;">索引数据一起存放：</span></div><ul><li><div>主键（聚簇）：叶子节点存放数据（数据页），上级到根节点存放目录（页目录，主键范围+下级页号），二分查找快速定位，一般不超过 4 层</div></li><li><div>二级索引：非主键，叶子节点存放列值和主键，上级到根节点页目录（列值范围+主键范围+下级页号），找到最终数据后再到聚簇中找到真实数据（回表）</div></li><li><div>联合索引：多列值+主键值，按顺序依次排序比较</div></li></ul><div><br/></div><div><span style="font-weight: bold;">MyISAM 索引是索引，数据是数据：</span></div><ul><li><div><span style="font-size: unset; font-family: unset;">主键索引也是二级索引，索引与数据分开存放，有单独的索引文件，索引记录主键与行号对应关系，没有聚簇</span></div></li><li><div><span style="font-size: unset; font-family: unset;">其它列二级索引也类似，主键与行号关系，直接偏移到文件中取数据，回表速度快</span></div></li></ul><div><span style="font-size: unset;"><br/></span></div><div><span style="font-size: unset; font-family: unset;">在使用索引来减少需要扫描的记录数量时，应该先找到使用该索引执行查询时对应的扫描区间和形成该扫描区间的边界条件，然后就可以扫描各个扫描区间中的记录。如果扫描的是二级索引记录，并且如果需要完整的用户记录，就需要根据获取到的每条二级索引记录的主键值进行回表操作。</span></div><div><span style="font-size: unset;"><br/></span></div><div><span style="font-family: unset; font-weight: bold;"><font style="font-size: 18px;">索引代价：</font></span></div><ul><li><div>空间：每个索引都要建立一个B+树，每一个节点都是一个数据页，每个数据页默认点16KB</div></li><li><div>时间：增删改时会进行页面分裂、页面回收等操作，查询执行时也会选择最好的索引但会增加分析时间</div></li></ul><div><br/></div><div><span style="font-weight: bold;"><font style="font-size: 18px;">更好创建利用索引：</font></span></div><ul><li><div>只为用于搜索、排序或分组的列创建索引</div></li><ul><li><div>排序、分组联合索引要按索引列顺序</div></li></ul><li><div>考虑索引列中不重复值的个数（重复值高回表代价高）</div></li><li><div>索引列的类型尽量小（存储少，磁盘IO少）</div></li><li><div>列前缀建立索引（字符串类型），排序无效</div></li><li><div>覆盖索引（不用回表）</div></li><li><div>让索引列以列名形式在搜索条件中单独出来，避免 key2 *2 &lt;4 这种</div></li><li><div>新插入记录时主键顺序（自动增长主键，避免频繁页分裂）</div></li><li><div>避免冗余、重复索引</div></li><li><div>回表代价高的不如直接聚簇索引全表扫，可以limit减少回表次数</div></li></ul><div><span style="font-size: unset;"><br/></span></div><div><b><font style="font-size: 18px;">表空间</font></b></div><ul><li><div><span style="font-size: unset;">表空间=集团军</span></div></li><li><div><span style="font-size: unset;">段=师</span></div></li><ul><li><div>零散页面及完整的区的集合</div></li><li><div>多个链表管理不用的区</div></li></ul><li><div><span style="font-size: unset;">区=团</span></div></li><ul><li><div><span style="font-size: unset;">FSEG区属于段</span></div></li><li><div><span style="font-size: unset;">FREE、FREE_FRAG、FULL_FRAG则是独立团，属于军部</span></div></li><li><div>64个页组成一个区，256个区组成一个组</div></li></ul><li><div>系统基本表中，SYS_TABLES、SYS_COLUMNS、SYS_INDEXES、SYS_FILEDS重要，对应 information_schema 中的 INNODB_SYS_XXXXX 表，描述元数据信息，不是真正的原始基本表，是系统启动时从原始基本表中读到 information_shcema 库中的</div></li></ul><div><br/></div><div><b><font style="font-size: 18px;">单表查找</font></b></div><ul><li><div>const：主键或唯一二级索引，有NULL值例外</div></li><li><div>ref：搜索条件为二级索引列与常数进行等值比较，形成的扫描区间为单点扫描区间，采用二级索引来执行查询，每查到一条就回表一条</div></li><ul><li><div>包含NULL值，有 is NULL 条件，最多只能到 ref 无法达到 const</div></li><li><div>多列二级索引，只要最左边连续的列是与常数比较，没有 &gt; 之类的，就可以达到 ref ，否则到 range</div></li></ul><li><div>ref_or_null：k = ‘abc’ or k is NULL ，比 ref 多一次 null 查找，null 值会放在索引最左边</div></li><li><div>range：非等值条件，使用索引执行查询时，对应的扫描区间为若干个单点扫描区间或者范围扫描区间</div></li><li><div>index：select k1,k2,k3 where k2=‘xxx’，k2不是最左索引列，但不用回表，扫描记录小，成本少</div></li><ul><li><div>当全表扫时 order by 主键 时，也是 index</div></li></ul><li><div>all：全表扫聚簇</div></li></ul><div><br/></div><div><b>索引合并：</b></div><ul><li><div>Intersection：交集索引合并，对不同索引中扫描到的记录和id值取交集，只为这些id进行回表操作，and，需要索引是主键排序的</div></li><li><div>Union：并集索引合并，对不同索引中扫描到的记录的id值取并集，为这些id值执行回表操作，or，需要索引是主键排序的</div></li><li><div>Sort-Union：先将从各个索引中扫描到的记录的主键值进行排序，再按照执行 Union 索引合并的方式执行查询</div></li></ul><div><br/></div><div><b><font style="font-size: 18px;">连接查询</font></b></div><ul><li><div>两表的连接查询中，驱动表只需要访问一次，被驱动表可能需要访问多次</div></li><ul><li><div>每获得一条驱动表记录，就立即到被驱动表中寻找匹配的记录</div></li></ul><li><div>内连接，若驱动表中的记录在被驱动表中没有找到与之匹配的记录，则该记录不会加入到最后的结果集，inner join，可以不用 on 子句，驱动表和被驱动表可以互换</div></li><li><div>外连接，即使驱动表中的记录在被驱动表中没有匹配的记录，也仍然加入到结果集，left/right join on ，必须要 on 子句，驱动表和被驱动表不能互换，要指明</div></li><li><div>左外连接，选取左侧的表为驱动表；右外连接，选取右侧的表为驱动表</div></li><li><div>where子句，不管内外连接，不符合条件的都不显示</div></li><li><div>on子句，外链接会显示，不匹配的显示null。专门为外连接驱动表中的记录在被驱动表找不到匹配记录时是否应该把该驱动表记录加入结果集中的场景提出的。放到内连接时效果与where相同。</div></li><li><div>连接原理：</div></li><ul><li><div>嵌套循环连接：表1结果给表2，表2执行单表，表1+表2结果集给表3，表3查单表，依次类推</div></li><li><div>使用索引加快连接速度：为被驱动表建立合适索引，被驱动表需要多次查询，不建议 * 查询</div></li><li><div>基于块的嵌套循环连接：join_buffer_size 可配置，默认 256kb，驱动表可以缓存的空间，可以将被驱动表一次性加载到内存中，不需要每次连接被驱动表时去单表查询及回表，不建议 * 查询，被驱动表小或被驱动表查询字段内容少效果好</div></li></ul><li><div>尽量减少驱动表的扇出（驱动表查出的数据）；访问被驱动表的成本要尽量低（被驱动表连接上建立索引，最好是主键或唯一二级索引）；</div></li></ul><div><br/></div><div><b><font style="font-size: 24px;"><u>优化规则</u></font></b></div><div><b><br/></b></div><div><b>语句优化</b></div><ul><li><div>移除不必要的括号</div></li><li><div>常量传递</div></li><li><div>移除没用的条件</div></li><li><div>表达式计算</div></li><li><div>HAVING子句和WHERE子名的合并</div></li><li><div>常量表检测：没记录或只有一条；能走聚集或唯一索引</div></li><li><div>外连接消除：</div></li><ul><li><div>内连接可以自动判断使用哪边当驱动表，效果更好</div></li><li><div>外链接中，被驱动表的WHERE子句符合空值拒绝条件（is not null），可以转换内连接</div></li></ul></ul><div><br/></div><div><b>子查询根据结果集分为：</b>标量子查询（一行一列）、行子查询（一行多列）、列子查询（一列多行）、表子查询（多行多列）</div><div><br/></div><div><b>子查询与外层查询的关系：</b></div><ul><li><div>不相关子查询：与外层查询无关。select f from a where k  = (select f from b where b=x)</div></li><li><div>相关子查询：与外层查询有关。select f from a where k  = (select f from b where b=f)</div></li></ul><div><br/></div><div><b>子查询运行：</b></div><ul><li><div>标量或行非相关子查询：先运行子查询，将结果当参数运行外层查询</div></li><li><div>标量或行相关子查询：先查外层，获得一条后执行子查询，根据子查询结果进行WHERE判断，放入结集</div></li></ul><div><br/></div><div><b>IN子查询优化：</b></div><ul><li><div>物化表：将子查询结果集中的记录保存到临时表</div></li><li><div>物化表转连接</div></li><li><div>物化表转半连接</div></li><ul><li><div>子查询表上拉：子查询的查询列表处只有主键或唯一索引时，上拉到外层的FROM中</div></li><li><div>重复值消除：a可能对应多个b，消除重复的b记录，临时表处理</div></li><li><div><span>松散扫描：利用b表的索引反向查询a表记录</span></div></li><li><div>半连接物化</div></li><li><div>首次匹配</div></li></ul><li><div>半连接转换条件</div></li><ul><li><div>子查询与IN操作邪恶的男人是布尔表达式，在外层的WHERE或ON中出现</div></li><li><div>子查询里面不能有 UNION</div></li><li><div>子查询不包含 GROUP BY、HAVING</div></li><li><div>外层查询条件不能有OR</div></li><li><div>NOT IN不行（不相关子查询可以先物化）</div></li><li><div>IN位于SELECT中</div></li><li><div>无法半连接转换的可能转化为 EXISTS（EXISTS返回布尔值，可以更好利用索引组织语句）</div></li></ul></ul><div><br/></div><div><font style="font-size: 24px;"><b style=""><u>EXPLAIN</u></b></font></div><ul><li><div>table：表名</div></li><li><div>id：针对每个SELECT给定一个id</div></li><ul><li><div>连查的id是一样的</div></li><li><div>子查询如果内部优化为连查后也会一样</div></li><li><div>union查会出现临时表，union all不会</div></li></ul><li><div>select_type：小查询在大查询中扮演的角色</div></li><ul><li><div>SIMPLE：查询中不包含UNION或者子查询，连接查询也是SIMPLE</div></li><li><div>PRIMARY：UNION、UNION ALL 或者子查询的大查询，最左边的的就是 PRIMARY</div></li><li><div>UNION：UNION、UNION ALL 或者子查询的大查询，除最左边的</div></li><li><div>UNION RESULT：UNION 时的临时表</div></li><li><div>SUBQUERY：如果子查询不能转为半连接形式，并且子查询是不相关查询，而且优化器决定采用将该子查询物化的方案来执行时。物化后该查询只执行一次。</div></li><li><div>DEPENDENT SUBQUERY：如果子查询不能转为半连接形式，并且子查询是相关查询。子查询可能被执行多次。</div></li><li><div>DEPENDENT UNION：包括UNION或者UNION ALL，如果各个小查询都依赖于外层查询，则除了最左边那个小查询外，其余小查询都是 DEPENDENT UNION 。select * from a where k in (select k1 from b where k1=‘x’ union select k1 from c where k1 = ‘x')</div></li><li><div>DERIVED：包含派生表的查询中，如果是以物化派生表的方式执行查询，则派生表对应的子查询。</div></li><li><div>MATERIALIZED：当优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询。</div></li></ul><li><div>partitions：分区信息</div></li><li><div>type：什么访问方法（system、const、eq_ref、ref、fulltext、ref_or_null、index_merge、unique_subquery、index_subquery、range、index、ALL）</div></li><ul><li><div>system：表中只有一条记录，并且该表使用的存储引擎统计是准确的（MyISAM、MEMORY）</div></li><li><div>const：主键或唯一二级索引与常量匹配</div></li></ul><ul><li><div>eq_ref：连接查询时，如果被驱动表是通过主键或者非NULL唯一二级索引等值匹配的</div></li><li><div>ref：通过普通二级索引与常量进行等值匹配</div></li><li><div>ref_or_null：对普通二级索引列进行等值匹配并且该索引列的值可以是NULL时</div></li><li><div>index_merge：优化器使用索引合并</div></li><li><div>unique_subquery：包含in子查询的语句，如果优化器决定将in子查询转换为EXISTS子查询，且子查询在转换之后可以使用主键或者不允许存储NULL值的唯一二级索引进行等值匹配</div></li><li><div>index_subquery：与unique_subquery类似，只不过在访问子查询中的表使用的是普通索引</div></li><li><div>range：使用索引获取某些单点扫描区间的记录，或者范围扫描区间 In &lt; &gt;</div></li><li><div>index：可以使用索引覆盖，但需要扫描全部的索引记录（全表扫描但对主键排序时，也是index）</div></li></ul><li><div>possible_keys：在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些（type为index是空的），并不是越多越好，可能用到的索引越多，优化器要计算成本的时间就越长</div></li><li><div>key：实际用到的索引有哪些</div></li><li><div>key_len：扫描区间长度</div></li><ul><li><div>该索引列实际数据最多占用的存储空间长度，如varchar(100) utf8，则为 3*100=300</div></li><li><div>NULL值+1</div></li><li><div>变成类型2字节+2</div></li></ul><li><div>ref：当type是const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery时，表示与索引列进行等值匹配的东西是啥，可能是 const 常数，或者某个列，或者函数func</div></li><li><div>rows：预计扫描的记录行数</div></li><li><div>filtered：扇出时预估比率</div></li><ul><li><div>全表扫描时来执行单表查询，估计出满足全部搜索条件的记录有多少</div></li><li><div>索引扫描时，估计出在满足索引扫描区间的搜索条件外，还满足其它搜索条件的记录有多少条</div></li><li><div>连接查询时比较有意义，比如驱动表rows1000，filtered10.0，表示可能有1000*10%条记录，被驱动表需要执行100将查询</div></li></ul><li><div>Extra：额外信息</div></li><ul><li><div>No tables used：没有FROM子句</div></li><li><div>Impossible WHERE：WHERE子句永远为 FALSE时</div></li><li><div>No matching min/max row：使用MAX或MIN函数时，并没有记录符合WHERE中的搜索条件时</div></li><li><div>Using index：使用覆盖索引执行查询时</div></li><li><div>Using index condition：搜索条件中虽然出现了索引列，但却不能充当边界条件来形成扫描区间，也就是不能减少需要扫描的记录数量（索引条件下推，优化器尽可能减少回表次数）</div></li><li><div>Using where：当某个搜索条件需要在 server层进行判断时</div></li><li><div>Using join buffer（Block Nested Loop）：连接查询中，被驱动表不能有效地利用索引加快访问速度，也就是基于块的嵌套循环算法来执行连接查询</div></li><li><div>Using intersect(…)、Using union(…)、Using sort_union(…)：使用了索引合并</div></li><li><div>Zero limit：limit子句的参数为0时，表示不打算返回任何记录</div></li><li><div>Using filesort：对结果集排序时，无法用到索引，只能进行文件排序</div></li><li><div>Using temporary：DISTINCT、GROUP BY、UNION时，无法利用索引来完成查询，就会建立临时表，如果使用到了临时表，就显示这个。</div></li><ul><li><div>GROUP BY默认会排序，即使不写ORDER BY也会同时出现 Using temporary 和 Using filesort ，可以自己指定一个 ORDER BY NULL 。</div></li><li><div>建立和维护临时表成本很大，出现 Using temporary 不是好事。</div></li></ul><li><div>Start temporary、End temporary：半连接执行策略为 Duplicate Weedout，也就是通过建立临时表来外外层查询记录去重时，驱动表表示为 Start temporary ，被驱动表表示为 End temporary 。</div></li><li><div>LooseScan：IN转为半连接时，如果采用的是 LooseScan 。</div></li><li><div>FirstMatch(tbl_name)：IN子查询为半林品如减肥，采用的是 FirstMarch</div></li></ul></ul><div><br/></div><div><b><font style="font-size: 18px;">Buffer Pool</font></b></div><ul><li><div>服务启动时向操作系统申请的连续内存，用于加载缓存页</div></li><li><div>innodb_buffer_pool_size：缓冲池大小，字节设置，只能是 innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances 的倍数</div></li><li><div>innodb_buffer_pool_instances：缓存池实例数量，每个实例大小=innodb_buffer_pool_size/Innodb_buffer_pool_instances，innodb_buffer_pool_size小于1G时，innodb_buffer_pool_instances设置无效，都是1个，实例内存之下是多个chunk</div></li><li><div>innodb_buffer_pool_chunk_size：指定chunk大小，默认128，在实例之下以chunk为单位向系统申请内存，实例不是直接一次申请一个大的完整内存空间，只能在服务启动时指定</div></li><li><div>SHOW ENGINE INNODB STATUS：查看 BUFFER POOL AND MEMORY 相关信息</div></li><ul><li><div>Total memory allocated：申请的内存大小</div></li><li><div>Buffer pool size：可以容纳多少缓冲页</div></li></ul></ul><div><br/></div><div><b><font style="font-size: 24px;">事务</font></b></div><div><br/></div><div><b>redo log</b>：在系统因崩溃而重启时将之前事务中的记录更新到数据页（原子性问题）</div><ul><li><div>innodb_log_buffer_size：指定redo log缓冲区大小</div></li><li><div>SHOW ENGINE INNODB STATUS：查看 LOG 相关信息</div></li><ul><li><div>Log sequence number：当前系统写入 redo 的日志量，包括 log buffer中的</div></li><li><div>Log flushed up to：表示写入到磁盘的 redo 日志量</div></li><li><div>Pages flushed un to：表示 flush 链表中被最早修改的那个页面对应的 oldest_modification 属性值</div></li><li><div>Last checkpoint at：表示当前系统 checkpoint_lsn 值</div></li></ul><li><div>innodb_flush_log_at_trx_commit：redo log持久性设置</div></li><ul><li><div>0：当前事务提交不刷磁盘，由后台线程刷，如果中间断了就没了</div></li><li><div>1：事务提交时就刷日志，默认值</div></li><li><div>2：将redo 日志写到操作系统缓冲区，如果数据库挂了，但操作系统没挂，还可以恢复</div></li></ul></ul><div><br/></div><div><b>undo log</b>：回滚日志（原子性问题）</div><div><br/></div><div><b>事务隔离级别：</b>并发情况下，让事务按顺序一个一个执行，最终执行效果和单个执行一样（隔离性、一致性问题）</div><div><br/></div><div><b><font style="font-size: 18px;">事务并发执行的一致性问题：</font></b></div><ul><li><div><span>脏写：一个事务修改了另一个未提交事务修改过的数据</span></div></li><li><div>脏读：一个事务读到了另一个未提交事务修改过的数据</div></li><li><div>不可重复读：一个事务修改了另一个未提交事务读取的数据，也叫模糊读</div></li><li><div>幻读：一个事务先根据某些搜索条件查询出一些记录，在该事务未提交时，另一个事务写入了一些符合那些搜索条件的记录（CUD）</div></li></ul><div><br/></div><div><b><font style="font-size: 18px;">四种隔离级别：</font></b></div><ul><li><div>READ UNCOMMITTED：未提交读，脏写不会发生（性能最高）</div></li><li><div>READ COMMITTED：已提交读，脏写、脏读不会发生</div></li><li><div>REPEATABLE READ：可重复读，脏写、脏读、不可重复读不会发生（MySQL默认，很大程度上不会出现幻读）</div></li><li><div>SERIALIZABLE：可串行化，全都不会发生（性能最差）</div></li></ul><div><br/></div><div>MVVC，多版本并发控制，解决READ COMMITTED和REPEATABLE READ的读问题，生成ReadView的时机不同，READ COMMITTED每次SELECT生成ReadView，REPEATABLE READ第一次生成ReadView，所以REPEATABLE READ可以很大程度上避免幻读。</div><div><br/></div><div>SET TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE]</div><div><br/></div><div>my.cnf</div><div>[mysqld]</div><div>transaction-isolation = READ-COMMITTED</div><div><br/></div><div><b><font style="font-size: 24px;">锁</font></b></div><div><br/></div><div>写-写操作，默认加锁排队</div><div><br/></div><div>读-写/写-读操作：</div><ul><li><div>使用MVVC，性能好，数据不是最新</div></li><li><div>使用锁，性能差，数据最新，但不能解决幻读问题</div></li></ul><div><br/></div><div>一致性读或一致性无锁读，事务使用MVVC读，不会加锁，普通的 SELECT 语句。</div><div><br/></div><div><b>锁定读：共享锁，S锁；独占锁，X锁。</b></div><ul><li><div>S锁共享，两个事务都可以有S锁；SX不兼容，一个事务S锁，另一个不能上X锁；XX不兼容，一个事务X锁，另一个不管是S还是X都不行。</div></li><li><div>加S锁语句：select … LOCK IN SHARE MODE；</div></li><li><div>加X锁语句：select … FOR UPDATE; update … ；delete … ；</div></li></ul><div><br/></div><div><b>InnoDB意向锁：</b></div><ul><li><div>意向共享锁（IS）：当事务准备在某条记录上加S锁时，需要先在表级别加一个IS锁</div></li><li><div>意向独占锁（IX）：当事务准备在某条记录上加X锁时，需要先在表级别加一个IX锁</div></li><li><div>它们仅仅是为了在之后加表级别的S和X锁时可以快速判断表中的记录是否被上锁，IS和IS、IX和IX、IS和IX是兼容的</div></li></ul><div><br/></div><div><b><font style="font-size: 18px;">MyISAM只有表级锁，并且没有事务，适合大量SELECT和INSERT类型的数据，并且MyISAM还有并发插入的特性。（大数据日志记录等）</font></b></div><div><br/></div><div>INNODB表锁：没啥用</div><ul><li><div><span style="font-family: unset; font-size: unset;">元数据锁MDL：ALTER TABLE、DROP TABLE时会阻塞其它查询语句，并且等之前事务全部提交之后才开始执行</span></div></li><li><div>AUTO-INC锁：INSERT时锁定自动增长列，锁整表</div></li><ul><li><div>可以设置 innodb_autoinc_lock_mode ：0使用AUTO-INC、2使用轻量锁（行锁）、1根据插入语句数量确定</div></li><li><div>设置为2，使用轻量锁时，不同事务中生成的列值是交叉的，有主从复制的场景中不安全</div></li></ul></ul><div><br/></div><div><b><font style="font-size: 18px;">INNODB行锁：</font></b></div><ul><li><div>Record Lock：记录锁，对记录本身加锁</div></li><li><div>Gap Lock：锁住记录前的间隙，防止别的事务向该间隙插入新记录</div></li><li><div>Next-Key Lock：上面两个的结合体，保护自己，也不让别的向间隙插入</div></li><li><div><span style="font-family: unset; font-size: unset;">Insert Intention Lock：没啥用</span></div></li><li><div>隐式锁：依靠记录的trx_id属性来保护不被别的事务改动记录</div></li></ul><div><br/></div><div><b>查看锁信息</b></div><ul><li><div>information_schema库中的 INNODB_TRX、INNODB_LOCKS、INNODB_LOCK_WAITS 表来查看事务和锁相关的信息</div></li><li><div>SHOW ENGINE INNODB STATUS 中 TRANSACTIONS</div></li></ul><div><br/></div><div><b><font style="font-size: 18px;">死锁：</font></b>互相持有对方需要的锁而导致事务无法继续执行，INNODB会选择一个较小的事务回滚，可以通过查看死锁日志来分析 SHOW ENGINE INNODB STATUS 中 LATEST DETECTED DEADLOCK</div><div><br/></div><div>语句加锁情况受到所在事务的隔离级别、语句执行时使用的索引类型、是否精确匹配、是否是唯一性搜索、具体执行的语句类型等情况的判断，需要具体情况具体分析</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: unset;"><br/></span></div><div><span style="font-size: unset;"><br/></span></div><div><span style="font-size: unset;"><br/></span></div><div><span style="font-size: unset;"><br/></span></div><div><span style="font-size: unset;"><br/></span></div></span>
</div></body></html> 