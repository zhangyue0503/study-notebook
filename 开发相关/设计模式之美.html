<html>
<head>
  <title>设计模式之美</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608449 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="942"/>
<h1>设计模式之美</h1>

<div><span><div><img src="设计模式之美_files/Image.png" type="image/png" data-filename="Image.png"/><br/></div><div><br/></div><div>面向过程编程以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点</div><div><br/></div><div>面向对象编程以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石</div><div><br/></div><div>封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。</div><div><br/></div><div>抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</div><div><br/></div><div>继承是用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。</div><div><br/></div><div>多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</div><div><br/></div><div>看似是面向对象，实际是面向过程的:</div><ul><li><div>1.滥用 getter、setter 方法：在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器（比如例子中的 List 容器），也要防范集合内部数据被修改的危险。</div></li><li><div>2. 滥用全局变量和全局方法：在定义 Utils 类之前，你要问一下自己，你真的需要单独定义这样一个 Utils 类吗？是否可以把 Utils 类中的某些方法定义到其他类中呢？将 Constants 类拆解为功能更加单一的多个类，比如跟 MySQL 配置相关的常量，我们放到 MysqlConstants 类中；跟 Redis 配置相关的常量，我们放到 RedisConstants 类中。当然，还有一种我个人觉得更好的设计思路，那就是并不单独地设计 Constants 常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。</div></li><li><div>3.定义数据和方法分离的类：传统的 MVC 结构分为 Model 层、Controller 层、View 层这三层。不过，在做前后端分离之后，三层结构在后端开发中，会稍微有些调整，被分为 Controller 层、Service 层、Repository 层。Controller 层负责暴露接口给前端调用，Service 层负责核心业务逻辑，Repository 层负责数据读写。而在每一层中，我们又会定义相应的 VO（View Object）、BO（Business Object）、Entity。一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Repository 类中。这就是典型的面向过程的编程风格。实际上，这种开发模式叫作基于贫血模型的开发模式，也是我们现在非常常用的一种 Web 项目的开发模式。</div></li></ul><div><br/></div><div>如何决定该用抽象类还是接口？如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示一种 has-a 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。</div><div><br/></div><div>定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。</div><div><br/></div><div>如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。</div><div><br/></div><div><br/></div><div>关于防止重放攻击：请求参数中还可以加入nonce（随机正整数），两次请求的nonce不能重复，timestamp和nonce结合进一步防止重放攻击。</div><div>如组合token参数：(uid+appid+appsecret+xxx+xxx+nonce+timestamp)，参数带nonce、timestamp，不带appsecret</div><div><br/></div><div><br/></div><div>需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就能给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化，这样一个思考过程能让我们摆脱无从下手的窘境。</div><div><br/></div><div>单一职责设计：我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构</div><div><br/></div><div>一个类的职责是否够单一：</div><ul><li><div>类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；</div></li><li><div>类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；</div></li><li><div>私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性；</div></li><li><div>比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；</div></li><li><div>类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。</div></li></ul><div><br/></div><div>开闭原则：添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，我们有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</div><div><br/></div><div>开闭原则应用：对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候之后，我们就可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求</div><div><br/></div><div>违反里氏替换的情况：</div><ul><li><div>1. 子类违背父类声明要实现的功能</div></li><li><div>2. 子类违背父类对输入、输出、异常的约定</div></li><li><div>3. 子类违背父类注释中所罗列的任何特殊说明</div></li></ul><div><br/></div><div>虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</div><div><br/></div><div>理解“接口隔离原则”的重点是理解其中的“接口”二字。这里有三种不同的理解。</div><ul><li><div>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</div></li><li><div>如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</div></li><li><div>如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</div></li></ul><div><br/></div><div>单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</div><div><br/></div><div>如何写出满足 KISS 原则的代码？</div><ul><li><div>不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。</div></li><li><div>不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。</div></li><li><div>不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。</div></li></ul><div><br/></div><div>YAGNI 原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</div><div><br/></div><div>实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则。实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。除此之外，代码执行重复也算是违反 DRY 原则。</div><div><br/></div><div>提高代码可复用性：</div><ul><li><div>减少代码耦合</div></li><li><div>满足单一职责原则</div></li><li><div>模块化</div></li><li><div>业务与非业务逻辑分离</div></li><li><div>通用代码下沉</div></li><li><div>继承、多态、抽象、封装</div></li><li><div>应用模板等设计模式</div></li></ul><div><br/></div><div>我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。</div><div><br/></div><div>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</div><div><br/></div><div>迪米特法则：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</div><div><br/></div><div>Marin Flower 重构：“重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低”。在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量</div><div><br/></div><div>持续重构，平时就可以看看项目中有哪些写得不够好、可以优化的代码，主动去重构一下。或者，在修改、添加某个功能代码的时候，也可以顺手把不符合编码规范、不好的设计重构一下</div><div><br/></div><div>有些人宁可与手头现有的材料进行长时间地纠缠，也不愿去与别人讨论。其实有时候只要通过一次简单的交流就可以取得很好的效果</div><div><br/></div><div>成功的领导者会在工作中建立对自己理解的问题进行连续检验的机制。虽然他们很自信，但他们对自己在智力上的局限性也有清醒的认识</div><div><br/></div><div>亚里士多德：“同一个想法不是一次两次，而是无数次地重复出现在这个世界上”。大部分“新的”思想实际上来自于其他环境下的已有想法，并且解决问题型领导者们也一直在寻找新的能够应用这些想法的环境</div><div><br/></div><div>放弃或保留你的想法是相当简单的，难的是要做到理智和公正：在你的想法被你的自负高估时，能够放弃它；而当团队的其他成员都坚持一个致命的错误观点时，则要毫不妥协地坚持你的正确观点</div><div><br/></div><div>管理想法的交流：</div><ul><li><div>为团队提供一个聪明的想法</div></li><li><div>鼓励借鉴有用的旧想法</div></li><li><div>认真完善团队成员提出的想法</div></li><li><div>放弃自己的想法并支持团队采纳的想法，但只有当每个成员都充分了解你的想法时才予以放弃</div></li><li><div>尽管时间压力很大，仍然不要吝惜花时间听其他人解释他们的想法</div></li><li><div>检验别人提出的想法</div></li><li><div>为了保持想法的交流，不要轻易否定团队成员的想法</div></li><li><div>如果你不得不否定一个想法，那么一定要明解，你所否定的只是这个想法，而不是提出这个想法的人</div></li><li><div>在给出你的想法之前要先地它进行检验</div></li><li><div>当时间和人力吃紧时，不要再去考虑新的想法而应该专注于现有的想法</div></li><li><div>鼓励队员们放弃以前曾经成功过，但并适用于现在情况的想法</div></li><li><div>如果一个已被否定的想法对问题的其他部分有价值，就应该重新采纳它</div></li></ul><div><br/></div><div>控制质量：</div><ul><li><div>在进行项目的同时检查质量</div></li><li><div>在确定解决方案的同时设计出质量检查工具和过程</div></li><li><div>测量实现进度，与时间表进行对比并随时准备调整方案进程</div></li><li><div>在项目进行中重新评估你所预测的前景及其可能性</div></li><li><div>在把想法付诸实践之前，先征求客户的意见</div></li><li><div>即使想法失效，也要恢复士气</div></li></ul><div><br/></div><div>代码是否需要解耦：比如，看修改代码会不会牵一发而动全身。除此之外，还有一个直接的衡量标准，也是我在阅读源码的时候经常会用到的，那就是把模块与模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。如果依赖关系复杂、混乱，那从代码结构上来讲，可读性和可维护性肯定不是太好，那我们就需要考虑是否可以通过解耦的方法，让依赖关系变得清晰、简单。当然，这种判断还是有比较强的主观色彩，但是可以作为一种参考和梳理依赖的手段，配合间接的衡量标准一块来使用。</div><div><br/></div><div>如何给代码解耦：</div><ul><li><div>封装与抽象</div></li><li><div>中间层：上层依赖中间层不去直接依赖底层</div></li><li><div>模块化：分而治之</div></li><li><div>其它：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则</div></li></ul><div><br/></div><div>在 Google Java 编程规范中，依赖类按照字母序从小到大排列。类中先写成员变量后写函数。成员变量之间或函数之间，先写静态成员变量或函数，后写普通变量或函数，并且按照作用域大小依次排列。除此之外，成员变量之间或函数之间，还会按照作用域范围从大到小的顺序来排列，先写 public 成员变量或函数，然后是 protected 的，最后是 private 的。</div><div><br/></div><div>不要在函数中使用布尔类型的标识参数来控制内部逻辑，true 的时候走这块逻辑，false 的时候走另一块逻辑。这明显违背了单一职责原则和接口隔离原则。建议将其拆成两个函数，可读性上也要更好。如果函数是 private 私有函数，影响范围有限，或者拆分之后的两个函数经常同时被调用，我们可以酌情考虑保留标识参数。</div><div><br/></div><div>注释的内容主要包含这样三个方面：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。类和函数一定要写注释，而且要写得尽可能全面详细。函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码可读性。</div><div><br/></div><div><img src="设计模式之美_files/Image.jpg" type="image/jpeg" data-filename="Image.jpg"/><br/></div><div><br/></div><div><img src="设计模式之美_files/Image [1].jpg" type="image/jpeg" data-filename="Image.jpg"/><br/></div><div><br/></div><div><img src="设计模式之美_files/Image [2].jpg" type="image/jpeg" data-filename="Image.jpg"/><br/></div><div><br/></div><div><img src="设计模式之美_files/Image [3].jpg" type="image/jpeg" data-filename="Image.jpg"/><br/></div><div><br/></div><div><img src="设计模式之美_files/Image [4].jpg" type="image/jpeg" data-filename="Image.jpg"/><br/></div><div><br/></div><div><img src="设计模式之美_files/Image [5].jpg" type="image/jpeg" data-filename="Image.jpg"/><br/></div><div><br/></div><div>单例的实现：</div><ul><li><div>饿汉式：在类加载的期间就已经将静态实例初始化好了</div></li><li><div>懒汉式：支持延迟加载，用到的时候才实例化，注意并发锁问题，性能低</div></li><li><div>双重检测</div></li><li><div>静态内部类</div></li><li><div>枚举</div></li></ul><div><br/></div><div>一旦你选择将某个类设计成单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性。</div><div><br/></div><div>单例存在的问题：</div><ul><li><div>单例对OOP特性的支持不友好</div></li><li><div>单例会隐藏类之间的依赖关系</div></li><li><div>单例对代码的可测试性不友好</div></li><li><div>单例不支持有参数的构造函数</div></li></ul><div><br/></div><div>单例的替代解决方案：静态方法、工厂模式、IOC 容器等。</div><div><br/></div><div>单例模式的唯一性：单例类中对象的唯一性的作用范围是”进程唯一“的。“进程唯一”指的是进程内唯一，进程间不唯一；“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”就意味着线程内、线程间都唯一。“集群唯一”指的是进程内、进程间唯一。</div><div><br/></div><div>线程唯一的单例实现：通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。</div><div><br/></div><div>集群环境下的单例实现：需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成后还需要再存储回外部共享存储区。为了保证任何时刻在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，需要显式地将对象从内存中删除，并且释放对对象的加锁。</div><div><br/></div><div>实现一个多例模式：“单例”指的是一个类只能创建一个对象。对应地，“多例”指的就是一个类可以创建多个对象，但是个数是有限制的。多例的实现比较简单，通过一个 Map 来存储对象类型和对象之间的对应关系，来控制对象的个数。</div><div><br/></div><div>当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离：</div><ul><li><div>第一种情况：类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中。</div></li><li><div>第二种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。</div></li></ul><div><br/></div><div>对于第一种情况，当每个对象的创建逻辑都比较简单的时候，推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类，推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。同理，对于第二种情况，因为单个对象本身的创建逻辑就比较复杂，所以，建议使用工厂方法模式。</div><div><br/></div><div>要不要使用工厂模式的最本质的参考标准：</div><ul><li><div>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</div></li><li><div>代码复用：创建代码抽离到独立的工厂类之后可以复用。</div></li><li><div>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</div></li><li><div>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</div></li></ul><div><br/></div><div>DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</div><div><br/></div><div>建造者模式是用来创建一种类型的复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。但是，如果存在下面情况中的做生意一种，我们就要考虑使用建造者模式了。</div><ul><li><div>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。</div></li><li><div>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。</div></li><li><div>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来设置属性值的方式就不适用了。</div></li></ul><div><br/></div><div><br/></div><div>原型模式：</div><ul><li><div>如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC 、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。</div></li><li><div><span style="font-size: unset; background-color: rgb(204, 204, 204); --inversion-type-background-color: simple; font-family: unset;">如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就变得复杂多了。没有充分的理由，不要为了一点点的性能提升而使用浅拷贝。</span></div></li></ul><div><br/></div><div>代理模式：</div><ul><li><div>一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过代理类继承原始类的方法来实现代理模式。</div></li><li><div>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</div></li><li><div>代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。还可以用在 RPC 、缓存等应用场景中。</div></li></ul><div><br/></div><div>桥接模式：</div><ul><li><div>GoF定义：将抽象和实现解耦，让它们可以独立变化。定义中的“抽象”，指的并非是“抽象类”或“接口”，而是被抽象出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。而定义中的“实现”，也并非“接口的实现类”，而是一套独立的“类库”。“抽象”和“实现”独立开发，通过对象之间的组合关系，组装在一起。</div></li><li><div>另一种理解方式：一个类存在两个（或多个）独立变化 的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。它非常类似于“组合优于继承”的设计原则，通过组合关系来替代继承关系，避免继承层次的指数级爆炸。</div></li></ul><div><br/></div><div>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</div><div><br/></div><div>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。在实际的开发中，应用的5种场景：</div><ul><li><div>封装有缺陷的接口设计</div></li><li><div>统一多个类的接口设计</div></li><li><div>替换依赖的外部系统</div></li><li><div>兼容老版本接口</div></li><li><div>适配不同格式的数据</div></li></ul><div><br/></div><div>门面模式：</div><ul><li><div>害怕接口设计，就相当于完成了一半的开发任务。只要接口设计得好，那代码就差不到哪里去。</div></li><li><div>接口粒度设计得太大，太小都不好。太大会导致接口不可复用，太小会导致接口不易用。在实际的开发中，接口的可复用性和易用性需要“微妙”的权衡。针对这个问题，一个基本的处理原则是，尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口，来提供更易用的接口。</div></li></ul><div><br/></div><div>组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。使用组合模式的前提是，你的业务场景必须能够表示成树形结构。</div><div><br/></div><div>享元模式：</div><ul><li><div>单例是为了对象全局唯一，多例是为了限制对象数量，享元是为了共享对象。<span style="font-size: unset; background-color: rgb(204, 204, 204); --inversion-type-background-color: simple; font-family: unset;">池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库中取一个连接，不需要重新创建）。而享元模式的“复用”可以理解为“共享使用”。</span></div></li><li><div>如果对象的生命周期很短，也不会被密集使用，利用享元模式反倒会浪费更多的内存。</div></li></ul><div><br/></div><div>观察者模式：</div><ul><li><div>设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦。</div></li><li><div>基于消息队列的实现方式，被观察者和观察者解耦更加彻底，两部分的耦合更小。被观察者完全不感知观察者，同理，观察者也完全不感知被观察者。被观察者只管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相应的逻辑。</div></li></ul><div><br/></div><div>模板方法模式<span style="font-size: unset; background-color: rgb(204, 204, 204); --inversion-type-background-color: simple; font-family: unset;">两大作用：利用和扩展。其中，复用每日的是，所有的子类可以复用类中提供的模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。</span></div><div><span style="font-size: unset; background-color: rgb(204, 204, 204); --inversion-type-background-color: simple;"><br/></span></div><div><span style="font-size: unset; background-color: rgb(204, 204, 204); --inversion-type-background-color: simple; font-family: unset;">模板方法模式和回调Callback：</span></div><ul><li><div><span style="font-size: unset; background-color: rgb(204, 204, 204); --inversion-type-background-color: simple; font-family: unset;">回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。</span></div></li><li><div><span style="font-size: unset; background-color: rgb(204, 204, 204); --inversion-type-background-color: simple; font-family: unset;">回调相比模板模式的优势：</span></div></li><ul><li><div><span style="font-size: unset; background-color: rgb(204, 204, 204); --inversion-type-background-color: simple; font-family: unset;">像Java这种只支持单继承的语言主，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力</span></div></li><li><div><span style="font-size: unset; background-color: rgb(204, 204, 204); --inversion-type-background-color: simple; font-family: unset;">回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类。</span></div></li><li><div><span style="font-size: unset; background-color: rgb(204, 204, 204); --inversion-type-background-color: simple; font-family: unset;">如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可。</span></div></li></ul></ul><div><span style="font-size: unset; background-color: rgb(204, 204, 204); --inversion-type-background-color: simple;"><br/></span></div><div>策略模式用来解耦策略的定义、创建、使用：</div><ul><li><div>定义，包含一个策略接口和一组实现这个接口的策略类。</div></li><li><div>策略的创建由工厂类来完成，封装策略创建的细节。</div></li><li><div>使用，策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。</div></li></ul><div><br/></div><div>职责链模式：</div><ul><li><div>在 GoF 定义中，一旦某个处理器能处理这个请求，就不会继续将请求传递给后续的处理器了。当然，在实际的开发中，也存在对这个模式的变体，那就是请求不会中途终止传递，而是会被所有的处理器都处理一遍。</div></li><li><div>职责链模式有两种常用的实现。一种是使用链表来存储处理器，另一种是使用数组来存储处理器，后面一种实现方式更加简单。</div></li></ul><div><br/></div><div><span style="font-size: unset; background-color: rgb(204, 204, 204); --inversion-type-background-color: simple; font-family: unset;">状态模式是状态机的一种实现方式。有3个部分组成：状态、事件、动作。事件触发状态的转移及动作的执行。</span></div><div><br/></div><div>状态机三种实现方式：</div><ul><li><div>分支逻辑法：简单、直接</div></li><li><div>查表法：状态很多、状态转移复杂的状态机适用（二维数据实现，如游戏）</div></li><li><div>状态模式：状态不多、状态转移简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机适用（如电商订单、外卖订单等）</div></li></ul><div><br/></div><div>迭代器模式：</div><ul><li><div>foreach 其实就是迭代器的语法糖，底层还是用得迭代器</div></li><li><div>一个完整的迭代器，一般会涉及容器和容器迭代器两部分内容。容器迭代器一般包含 hasNext()、current()、next() 等方法</div></li><li><div>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一</div></li><li><div>迭代器模式让添加新的遍历算法更加容易，更符合开闭原则</div></li><li><div>在遍历时，增加或删除集合中的元素可能导致“不可预期”的问题，两种方案，要么不允许增删，要么增删元素后报错</div></li></ul><div><br/></div><div>访问者模式：</div><ul><li><div>针对的是一组类型不同的对象。不过，尽管这组对象的类型是不同的，但是，它们继承相同的父类或者实现相同的接口。在不同的应用场景下，我们需要对这组对象进行一系列不相关的业务操作，但为了避免不断添加功能导致类不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，我们使用访问者模式，将对象与操作解耦，将这些业务操作抽离出来，定义在独立细分的访问者类中</div></li><li><div>所谓 Single Dispatch ，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定。所谓 Double Dispathc ，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定</div></li></ul><div><br/></div><div>备忘录模式：</div><ul><li><div>一是存储副本以便恢复，二是不违背封装原则的前提下进行对象的备份和恢复</div></li><li><div>对于大备份来说，只备份必要的恢复信息，结合最新的数据来恢复，或者全量与增量备份相结合，低频全量备份，高频增量备份，两者结合来做恢复</div></li></ul><div><br/></div><div>命令模式重点在与将请求（函数）封装成对象，类似于回调的能力。主要作用和应用场景，是用来控制命令的执行。不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换。</div><div><br/></div><div>中介者模式就像一个中间层，可以把多对多变成多对一，但也可能让这个中介类变成“上帝类”。它与观察者模式的区别是：观察者的参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介者模式的应用专利场景中，参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者</div><div><br/></div><div><img src="设计模式之美_files/Image [1].png" type="image/png" data-filename="Image.png"/><br/></div><div><br/></div><div>面对复杂系统的开发，我们要善于应用分层技术，把容易复用、跟具体业务关系不大的代码，尽量下沉到下层，把容易变动、跟具体业务强相关的代码，尽量上移到上层</div><div><br/></div><div>应对大型复杂项目开发：</div><ol><li><div>吹毛求疵般地执行编码规范</div></li><li><div>编写高质量的单元测试</div></li><li><div>不流于形式的 Code Review</div></li><li><div>开发未动、文档先行</div></li><li><div>持续重构、重构、重构</div></li><li><div>对项目与团队进行拆分</div></li></ol><div><br/></div><div>一个对象的状态在对象创建之后就不再改变，这就是所谓的不变模式。其中涉及的类就是不变类（Immutable Class），对象就是不变对象（Immutable Object）。不变模式可以分为两类（类似于深浅拷贝）（PHP7不可变数组）：</div><ul><li><div>普通不变模式：对象中包含的引用对象是可以改变的</div></li><li><div>深度不变模式：对象包含的引用对象也不可变</div></li></ul><div><br/></div><div><span>幂等，针对同一个接口，多次发起同一个业务请求，必须保证业务只执行一次。在确定重试还是新请求，就需要给同一业务一个唯一标识，也就是”幂等号“。幂等号要保证全局唯一性，不建议有业务含义。</span></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 